<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java 修饰符</title>
    <url>/java/java%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<img src="/java/java%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/java.png" class="">

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的进程管理</title>
    <url>/linux/Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>使用ps查看某个时间点的进程运行情况。ps auxf  -&gt; 列出类似于进程树的的程序显示</p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>使用top动态查看进程的变化。top  [-d 数字]  | top [-bnp]</p>
<p>参数：</p>
<p>-d：配置界面更新的秒数</p>
<p>-b：以批处理的方式处理输出  </p>
<p>-n：与-b搭配，配置执行几次top输出的结果</p>
<p>-p：指定监控的pid</p>
<p>在top执行过程中可以使用的命令</p>
<p>?：显示top中可以输入的按键命令</p>
<p>P：以CPU的使用资源排序</p>
<p>M：以MEM的使用资源排序</p>
<p>N：以PID排序</p>
<p>T：以使用的CPU时间累积（time+）排序</p>
<p>k：给某个PID信号</p>
<p>r：重新配置PID的nice值</p>
<p>q：离开top</p>
<h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p>查看进程间关系。pstree  [-A|-U]  -[up]</p>
<p>参数：</p>
<p>-A：用ASCII字符来连接进程间关系</p>
<p>-U：用utf-8字符来连接进程间关系</p>
<p>-p：列出PID</p>
<p>-u：列出每个进程所属账号</p>
<h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><p>通过信号来管理进程</p>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill -singnal  PID</p>
<h2 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h2><p>killall  -signal  命令名称</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>java 面向对象</title>
    <url>/java/java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<img src="/java/java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/java.png" class="">

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看系统资源</title>
    <url>/linux/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><p>查看内存使用情况</p>
<h1 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h1><p>查看系统与内核相关信息</p>
<h1 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h1><p>查看洗启动时间与工作负载</p>
<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>跟踪网络</p>
<h1 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h1><p>分析内核产生的信息</p>
<h1 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h1><p>检测CPU 内存 硬盘输入输出状态</p>
<h1 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h1><p>找出真正使用该文件的程序</p>
<h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>列出被进程所打开的 文件名</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中的工作管理</title>
    <url>/linux/linux%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>工作管理（job controll），在 bash下（登录系统取得的 bash shell），对自身的多个工作的管理</p>
<ul>
<li><p>将命令扔到后台执行:  &amp;</p>
<ul>
<li>此时会得到job number和pid</li>
<li>需要处理后台工作的输出信息，防止影响前台操作</li>
</ul>
</li>
<li><p>查看目前的后台工作状态：jobs</p>
</li>
<li><p>将目前的工作丢到后台中暂停:    ctrl + z</p>
</li>
<li><p>将后台暂停的工作变成运行状态： bg %jobnumber</p>
</li>
<li><p>将后台工作拿到前台来处理:  fg  %jobnumber</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 常用命令</title>
    <url>/npm/npm%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h1><p>为了能下载依赖包速度快点，推荐使用淘宝镜像，使用下面命令修改镜像地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h1 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h1><p>下面命令初始化一个模块，按提示配置 package.json 中的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init </span><br></pre></td></tr></table></figure>

<p><code>-y</code> 表示使用默认值配置 package.json 文件中的字段，</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用下面命令安装模块：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install (with no args, <span class="keyword">in</span> package dir)</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;name&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;tag&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version range&gt;</span><br><span class="line">npm install &lt;<span class="built_in">alias</span>&gt;@npm:&lt;name&gt;</span><br><span class="line">npm install &lt;git-host&gt;:&lt;git-user&gt;/&lt;repo-name&gt;</span><br><span class="line">npm install &lt;git repo url&gt;</span><br><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">aliases: npm i, npm add</span><br><span class="line">common options: [-P|--save-prod|-D|--save-dev|] </span><br></pre></td></tr></table></figure>

<p>可选参数：</p>
<ul>
<li><strong>-P, –save-prod</strong>： 表示生产环境依赖包</li>
<li><strong>-D, –save-dev</strong>： 表示开发环境依赖包</li>
</ul>
<p>例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接写包名 从镜像地址下载 lodash</span></span><br><span class="line">npm i lodash</span><br><span class="line"><span class="comment">#从git url 下载lodash</span></span><br><span class="line">npm i git+https://github.com/lodash/lodash.git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update [-g] [&lt;pkg&gt;...]</span><br><span class="line"></span><br><span class="line">aliases: up, upgrade</span><br></pre></td></tr></table></figure>

<p><code>-g</code> 参数表示更新全局安装包</p>
<p>如果不指定包名称，将更新所有的安装包到满足需要的最新版本。</p>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional|--no-save]</span><br><span class="line"></span><br><span class="line">aliases: remove, rm, r, un, unlink</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm uninstall lodash --no-save</span><br></pre></td></tr></table></figure>

<h1 id="查看已装包列表"><a href="#查看已装包列表" class="headerlink" title="查看已装包列表"></a>查看已装包列表</h1><p>通过下面命令查看已安装列表，带 <code>-g</code> 表示查看全局目录的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm ls [-g]</span><br></pre></td></tr></table></figure>

<h1 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h1><p>使用 <code>-f</code> 参数可以强制清理缓存</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm cache clear [-f]</span><br></pre></td></tr></table></figure>

<h1 id="npm-配置"><a href="#npm-配置" class="headerlink" title="npm 配置"></a>npm 配置</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> &lt;key&gt; &lt;value&gt; [-g|--global]</span><br><span class="line">npm config get &lt;key&gt;</span><br><span class="line">npm config delete &lt;key&gt;</span><br><span class="line">npm config list [-l] [--json]</span><br><span class="line">npm config edit</span><br><span class="line">npm get &lt;key&gt;</span><br><span class="line">npm <span class="built_in">set</span> &lt;key&gt; &lt;value&gt; [-g|--global]</span><br><span class="line"></span><br><span class="line">aliases: c</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config list  <span class="comment">#获取所有配置信息</span></span><br></pre></td></tr></table></figure>

<h1 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">help</span> &lt;term&gt; [&lt;terms..&gt;]</span><br></pre></td></tr></table></figure>

<p>当指定了具体的命令时，会打开对应命令的文档，如 <code>npm help install</code> 会打开 <code>install</code> 命令的帮助文档。</p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>npx</title>
    <url>/npm/npx/</url>
    <content><![CDATA[<h1 id="1-npx-是什么"><a href="#1-npx-是什么" class="headerlink" title="1 npx 是什么"></a>1 npx 是什么</h1><p>npx 是 npm v5.2.0 引入的命令，即 npm 自带的命令。</p>
<h1 id="2-npx-有什么作用"><a href="#2-npx-有什么作用" class="headerlink" title="2 npx 有什么作用"></a>2 npx 有什么作用</h1><p>通过 npx 我们可以直接执行依赖包里面的二进制文件，而无需给出依赖包路径，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx webpack --config webpack.prod.js</span><br></pre></td></tr></table></figure>



<p>没有 npx 时，当我们想在命令行直接使用依赖包时，需要给出依赖包的路径，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.\node_modules\.bin\webpack --config webpack.prod.js</span><br></pre></td></tr></table></figure>

<h1 id="3-npx-典型使用场景"><a href="#3-npx-典型使用场景" class="headerlink" title="3 npx 典型使用场景"></a>3 npx 典型使用场景</h1><h2 id="3-1-一次性使用的命令"><a href="#3-1-一次性使用的命令" class="headerlink" title="3.1 一次性使用的命令"></a>3.1 一次性使用的命令</h2><p>对于一些一次性命令，可以直接使用npx，如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure>

<p>指定模块运行版本，如下面命令指定 node 的 0.12.8 版本来运行命令 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx node@0.12.8 -v</span><br></pre></td></tr></table></figure>

<h1 id="4-npx-原理"><a href="#4-npx-原理" class="headerlink" title="4 npx 原理"></a>4 npx 原理</h1><p>npx 运行时，会从 node_modeule/.bin 路径和环境变量 $PATH 中，检测命令是否存在，当不存在时，会直接帮我们安装。</p>
<p>npx 甚至支持运行远程仓库的可执行文件，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx github:piuccio/cowsay hello</span><br></pre></td></tr></table></figure>

<p>再比如 <code>npx http-server</code> 可以一句话帮你开启一个静态服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx http-server</span><br></pre></td></tr></table></figure>

<h1 id="5-npx-高级用法"><a href="#5-npx-高级用法" class="headerlink" title="5 npx 高级用法"></a>5 npx 高级用法</h1><h3 id="5-1-强制使用本地模块"><a href="#5-1-强制使用本地模块" class="headerlink" title="5.1 强制使用本地模块"></a>5.1 强制使用本地模块</h3><p>使用 <code>--no-install</code> 参数，不下载远程模块， 强制使用本地模块，当本地不存在此模块时，会报错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx --no-install http-server</span><br></pre></td></tr></table></figure>

<h3 id="5-2-强制安装远程模块"><a href="#5-2-强制安装远程模块" class="headerlink" title="5.2 强制安装远程模块"></a>5.2 强制安装远程模块</h3><p>使用 <code>--ignore-existing</code> 参数忽略本地同名模块，强制使用远程模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx --ignore-existing create-react-app my-react-app</span><br></pre></td></tr></table></figure>

<h3 id="5-3-指定模块的安装版本"><a href="#5-3-指定模块的安装版本" class="headerlink" title="5.3 指定模块的安装版本"></a>5.3 指定模块的安装版本</h3><p>使用 <code>-p</code> 参数可以指定 npx 所要安装的模块。下面命令先安装 node ，再执行<code>node -v</code>。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx -p node@0.12.8 node -v </span><br></pre></td></tr></table></figure>

<p><code>-p</code> 参数还可以安装多个模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx -p lolcatjs -p cowsay [command]</span><br></pre></td></tr></table></figure>

<h3 id="5-4-执行多条命令"><a href="#5-4-执行多条命令" class="headerlink" title="5.4 执行多条命令"></a>5.4 执行多条命令</h3><p>如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx -p lolcatjs -p cowsay &#x27;cowsay hello | lolcatjs&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 报错</span></span><br></pre></td></tr></table></figure>

<p><code>-c</code>参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx -p lolcatjs -p cowsay -c <span class="string">&#x27;cowsay hello | lolcatjs&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/csdn_yudong/article/details/81670477">https://blog.csdn.net/csdn_yudong/article/details/81670477</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/02/npx.html">http://www.ruanyifeng.com/blog/2019/02/npx.html</a></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>python 中文编码</title>
    <url>/python/python%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>代码中包含中文，就需要在头部指定编码。</p>
<p>在文件开头加入 <strong># -*- coding: UTF-8 -*-</strong> 或者 <strong># coding=utf-8</strong>，确保读取中文时不会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;你好，世界&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>#coding=utf-8 的等号两边不要有空格</p>
</li>
<li><p>python3.x 源码默认使用 utf-8 编码，故能正常解析中文</p>
</li>
<li><p>应将编辑器的存储格式配置为 UTF-8</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>python不同于其他编程语言的语法记录</title>
    <url>/python/python%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BA%8Ejs%E7%9A%84%E5%8F%A6%E7%B1%BB%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>各种编程语言有很多类似的语法，比如标识符的命名规范、循环、判断等等，下面列出 python 相对于其他编程语言特殊的一些基础语法。</p>
<h2 id="1、关键字-in-的用法"><a href="#1、关键字-in-的用法" class="headerlink" title="1、关键字 in 的用法"></a>1、关键字 in 的用法</h2><p>in通常用来判断 key 是否存在于字典的键，但是 python 中 in 还可以用于判断字符串是否包含某个子串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;cd&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span> </span><br><span class="line"><span class="comment">#返回值为true,表示后者包含前者</span></span><br></pre></td></tr></table></figure>

<h2 id="2、代码块的表示"><a href="#2、代码块的表示" class="headerlink" title="2、代码块的表示"></a>2、代码块的表示</h2><p>通常代码块用大括号 {} 包裹，python 用缩进幅度来表示所在的代码块</p>
<h2 id="3、列表-字符串截取"><a href="#3、列表-字符串截取" class="headerlink" title="3、列表/字符串截取"></a>3、列表/字符串截取</h2><p>list[start:end] 表示截取下标范围 [ start, end ) 的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#list[start:end:step]表示在[start,end)的范围中，且每隔step个提取元素</span></span><br><span class="line">a=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>];</span><br><span class="line"><span class="built_in">print</span>( a[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出为[&#x27;c&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="4、-号用来表示重复"><a href="#4、-号用来表示重复" class="headerlink" title="4、* 号用来表示重复"></a>4、* 号用来表示重复</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print ([&#x27;a&#x27;]*4)</span><br><span class="line"></span><br><span class="line">#输出为 [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>python 项目环境搭建</title>
    <url>/python/python%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>python 项目环境搭建</p>
<p>1、装所需 python 版本</p>
<p>2、pycharm 配置 python 解释器路径</p>
<p>3、配置 pip 镜像地址（pip.ini放到用户home目录下）</p>
<p>4、pycharm 打开目录从项目根目录打开，requirements.txt 文件会自动被 pycharm 识别</p>
<p>5、按照 pycharm 的提示对所需依赖进行安装</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/maven/Maven/</url>
    <content><![CDATA[<h1 id="1-Maven-介绍"><a href="#1-Maven-介绍" class="headerlink" title="1 Maven 介绍"></a>1 Maven 介绍</h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><p>Maven 是一个项目管理工具，可被用于构建和管理各种项目。例如java, C#，Ruby，Scala 和其他语言编写的项目。</p>
<p>Maven 基于项目对象模型（缩写：POM），利用一个中央信息片断能管理一个项目的构建（编译、测试、运行、打包、安装、部署）、依赖管理等。</p>
<h2 id="1-2-Maven-特点"><a href="#1-2-Maven-特点" class="headerlink" title="1.2 Maven 特点"></a>1.2 Maven 特点</h2><ul>
<li>项目设置遵循统一的规则。</li>
<li>任意工程中共享。</li>
<li>依赖管理包括自动更新。</li>
<li>一个庞大且不断增长的库。</li>
<li>可扩展，能够轻松编写 Java 或脚本语言的插件。</li>
<li>只需很少或不需要额外配置即可即时访问新功能。</li>
<li><strong>基于模型的构建</strong> − Maven 能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。</li>
<li><strong>项目信息的一致性站点</strong> − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。</li>
<li><strong>发布管理和发布单独的输出</strong> − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven 能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。</li>
<li><strong>向后兼容性</strong> − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。</li>
<li>子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号，</li>
<li><strong>并行构建</strong> − 编译的速度能普遍提高20 - 50 %。</li>
<li><strong>更好的错误报告</strong> − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。</li>
</ul>
<h2 id="1-3-项目目录结构"><a href="#1-3-项目目录结构" class="headerlink" title="1.3 项目目录结构"></a>1.3 项目目录结构</h2><p>Maven 提倡按照如下标准目录结构进行配置：</p>
<table>
<thead>
<tr>
<th align="left">目录</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">${basedir}</td>
<td align="left">存放 pom.xml 和所有的子目录</td>
</tr>
<tr>
<td align="left">${basedir}/src/main/java</td>
<td align="left">项目的 java 源代码</td>
</tr>
<tr>
<td align="left">${basedir}/src/main/resources</td>
<td align="left">项目的资源，比如说 property 文件，springmvc.xml</td>
</tr>
<tr>
<td align="left">${basedir}/src/test/java</td>
<td align="left">项目的测试类，比如说 Junit 代码</td>
</tr>
<tr>
<td align="left">${basedir}/src/test/resources</td>
<td align="left">测试用的资源</td>
</tr>
<tr>
<td align="left">${basedir}/src/main/webapp/WEB-INF</td>
<td align="left">web 应用文件目录，web 项目的信息，比如存放 web.xml、本地图片、jsp 视图页面</td>
</tr>
<tr>
<td align="left">${basedir}/target</td>
<td align="left">打包输出目录</td>
</tr>
<tr>
<td align="left">${basedir}/target/classes</td>
<td align="left">编译输出目录</td>
</tr>
<tr>
<td align="left">${basedir}/target/test-classes</td>
<td align="left">测试编译输出目录</td>
</tr>
<tr>
<td align="left">Test.java</td>
<td align="left">Maven 只会自动运行符合该命名规则的测试类</td>
</tr>
<tr>
<td align="left">~/.m2/repository</td>
<td align="left">Maven 默认的本地仓库目录位置</td>
</tr>
</tbody></table>
<h1 id="2-Maven-POM"><a href="#2-Maven-POM" class="headerlink" title="2 Maven POM"></a>2 Maven POM</h1><p>Maven 使用 POM（Project Object Model，项目对象模型）用来描述项目基本信息。</p>
<p>执行项目时，Maven 会在当前目录中找并读取 pom.xml 文件，获取所需的配置信息来执行。</p>
<p>所有 pom.xml 都需要有 project 元素和三个必需字段：groupId，artifactId，version。</p>
<table>
<thead>
<tr>
<th align="left">节点</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">project</td>
<td align="left">工程的根标签。</td>
</tr>
<tr>
<td align="left">modelVersion</td>
<td align="left">模型版本需要设置为 4.0。</td>
</tr>
<tr>
<td align="left">groupId</td>
<td align="left">这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td>
</tr>
<tr>
<td align="left">artifactId</td>
<td align="left">这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td>
</tr>
<tr>
<td align="left">version</td>
<td align="left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></td>
</tr>
</tbody></table>
<h1 id="3-Maven-构建生命周期"><a href="#3-Maven-构建生命周期" class="headerlink" title="3 Maven 构建生命周期"></a>3 Maven 构建生命周期</h1><p>Maven 的典型生命周期由下面几个阶段组成：</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">处理</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">验证 validate</td>
<td align="left">验证项目</td>
<td align="left">验证项目是否正确且所有必须信息是可用的</td>
</tr>
<tr>
<td align="left">编译 compile</td>
<td align="left">执行编译</td>
<td align="left">源代码编译在此阶段完成</td>
</tr>
<tr>
<td align="left">测试 Test</td>
<td align="left">测试</td>
<td align="left">使用适当的单元测试框架（例如JUnit）运行测试。</td>
</tr>
<tr>
<td align="left">包装 package</td>
<td align="left">打包</td>
<td align="left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td>
</tr>
<tr>
<td align="left">检查 verify</td>
<td align="left">检查</td>
<td align="left">对集成测试的结果进行检查，以保证质量达标</td>
</tr>
<tr>
<td align="left">安装 install</td>
<td align="left">安装</td>
<td align="left">安装打包的项目到本地仓库，以供其他项目使用</td>
</tr>
<tr>
<td align="left">部署 deploy</td>
<td align="left">部署</td>
<td align="left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td>
</tr>
</tbody></table>
<h1 id="4-settings-xml"><a href="#4-settings-xml" class="headerlink" title="4 settings.xml"></a>4 settings.xml</h1><p>settings.xml 是 maven 的全局配置文件，pom.xml 是所在项目的局部配置文件。Settings.xml中包含类似本地仓储位置、修改远程仓储服务器、认证信息等配置。</p>
<p>settings.xml文件一般存在于两个位置：</p>
<ul>
<li>全局配置: ${M2_HOME}/conf/settings.xml</li>
<li>用户配置: user.home/.m2/settings.xml     （用户配置优先于全局配置）</li>
</ul>
<p>配置优先级从高到低：pom.xml&gt; user settings &gt; global settings</p>
<h1 id="5-Maven-仓库"><a href="#5-Maven-仓库" class="headerlink" title="5 Maven 仓库"></a>5 Maven 仓库</h1><p>Maven 项目中依赖的第三方库所在的位置叫做仓库。</p>
<p>Maven 仓库有三种类型：</p>
<ul>
<li><p>本地（local）</p>
<ul>
<li><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">   http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:/MyLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>中央（central）</p>
<ul>
<li>这个仓库由 Maven 社区管理，包含了大量常用的库。</li>
<li>不需要配置，需要通过网络才能访问。</li>
</ul>
</li>
<li><p>远程（remote，私服）</p>
<ul>
<li>开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件</li>
</ul>
</li>
</ul>
<h1 id="6-Maven-快照"><a href="#6-Maven-快照" class="headerlink" title="6 Maven 快照"></a>6 Maven 快照</h1><p>快照是模块的临时版本。maven 根据模块的版本号( pom 文件中的 version )中是否带有<code>-SNAPSHOT</code>来判断是快照版本还是正式版本。</p>
<ul>
<li><p>对于快照版本，执行 mvn deploy 时会自动发布到快照版本库中，并覆盖老的快照版本。依赖快照版本的模块，在不更改版本号的情况下，编译打包时，maven 自动从镜像服务器上下载最新的快照版本。</p>
</li>
<li><p>对于正式发布版本，执行 mvn deploy 时会自动发布到正式版本库中。依赖正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块，则<strong>不会</strong>主动去镜像服务器上下载。</p>
</li>
</ul>
<p>在开发阶段，使用快照版本进行开发，能够使依赖快照版本的模块不需要修改 pom 文件版本号也能下载新的版本，从而提升开发效率。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Tortoisegit pull时，提示Couldn&#39;t load this key(unable to open file)</title>
    <url>/tortoisegit/Tortoisegit%20pull%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BACouldn&#39;t%20load%20this%20key(unable%20to%20open%20file)/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>之前新建了个ppk文件，删了旧的，今天在本地执行pull操作时，提示下面错误</p>
<img src="/tortoisegit/Tortoisegit%20pull%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BACouldn't%20load%20this%20key(unable%20to%20open%20file)/error.png" class="">

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>从网上搜的方法是，配置remote，可惜并没有看到remote选项</p>
<img src="/tortoisegit/Tortoisegit%20pull%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BACouldn't%20load%20this%20key(unable%20to%20open%20file)/png1.png" class="">



<p>于是，通过在pull弹出中，如下图操作，找到remote配置</p>
<img src="/tortoisegit/Tortoisegit%20pull%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BACouldn't%20load%20this%20key(unable%20to%20open%20file)/png2.png" class="">



<p>如下图，选择最新的ppk文件，然后确定</p>
<img src="/tortoisegit/Tortoisegit%20pull%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BACouldn't%20load%20this%20key(unable%20to%20open%20file)/png3.png" class="">





<p>重新pull时，就不会再提示无法加载了key文件了</p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Tortoisegit</category>
      </categories>
      <tags>
        <tag>Tortoisegit</tag>
      </tags>
  </entry>
  <entry>
    <title>修改完github用户名后，在本地pull之前拉的工程，提示没有权限</title>
    <url>/tortoisegit/%E4%BF%AE%E6%94%B9%E5%AE%8Cgithub%E7%94%A8%E6%88%B7%E5%90%8D%E5%90%8E%EF%BC%8C%E5%9C%A8%E6%9C%AC%E5%9C%B0pull%E4%B9%8B%E5%89%8D%E6%8B%89%E7%9A%84%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>修改完github用户名后，在本地pull之前的工程，提示”make sure you have the correct access rights”，如图:</p>
<img src="/tortoisegit/%E4%BF%AE%E6%94%B9%E5%AE%8Cgithub%E7%94%A8%E6%88%B7%E5%90%8D%E5%90%8E%EF%BC%8C%E5%9C%A8%E6%9C%AC%E5%9C%B0pull%E4%B9%8B%E5%89%8D%E6%8B%89%E7%9A%84%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/1.png" class="">



<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><img src="/tortoisegit/%E4%BF%AE%E6%94%B9%E5%AE%8Cgithub%E7%94%A8%E6%88%B7%E5%90%8D%E5%90%8E%EF%BC%8C%E5%9C%A8%E6%9C%AC%E5%9C%B0pull%E4%B9%8B%E5%89%8D%E6%8B%89%E7%9A%84%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/2.png" class="">



<p>重新pull，就会提示成功</p>
<img src="/tortoisegit/%E4%BF%AE%E6%94%B9%E5%AE%8Cgithub%E7%94%A8%E6%88%B7%E5%90%8D%E5%90%8E%EF%BC%8C%E5%9C%A8%E6%9C%AC%E5%9C%B0pull%E4%B9%8B%E5%89%8D%E6%8B%89%E7%9A%84%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/3.png" class="">

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>微服务特点：</p>
<ul>
<li>低耦合</li>
<li>弱依赖技术</li>
<li>以业务为单元组织代码</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>进程 线程 服务</title>
    <url>/%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><strong>程序</strong>是计算机指令的集合，以二进制的形式，存储在磁盘上。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><strong>进程</strong>是系统资源申请、调度和独立运行的最小单位，是正在运行的<strong>程序</strong>。</p>
<p>一个程序可以启动多个进程，如每次打开浏览器都会启动新的进程。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是在进程上下文创建的，系统从进程的地址空间中分配资源，供线程使用。真正执行代码的是线程。</p>
<p>创建进程时，操作系统会为此进程创建第一个线程，此线程为主线程，执行 main 或 winmain 函数。</p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><strong>服务</strong>是<strong>常驻</strong>在内存中的进程。</p>
]]></content>
      <categories>
        <category>编程通用</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<p>本文主要介绍一些网络名词。</p>
<h2 id="网络性能相关"><a href="#网络性能相关" class="headerlink" title="网络性能相关"></a>网络性能相关</h2><h3 id="比特"><a href="#比特" class="headerlink" title="比特"></a>比特</h3><p>比特( bit )是计算机中<strong>数据量的单位</strong>，来源于 binary digit（二进制数据），因此一个比特就是一个二进制数字中的一个 1 或 0。</p>
<p>通过用**比特率( bit rate )**来描述网络速率，速率的单位是 b / s (比特每秒，或 bit / s)，有时写成 bps（即bit per second）。速率高时，可以使用 Kb/s   Mb/s   Gb/s  Tb/s 为单位 。现在人们描述速率时，常常忽略单位中的b/s，如 100M 以太网，表示网络速率是 100Mb/s。</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>在计算机网络中，<strong>带宽</strong>表示网络的通信线路所能传送数据的能力。<strong>网络带宽</strong>表示单位时间内，从网络中的一点到另一点所能通过的<strong>最高数据率</strong>。</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>**吞吐量 **表示在单位时间内，通过某个网络（或信道、网口）的数据量。</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>**时延 **指数据从网络的一端传送到另一端所需的时间。</p>
<p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p>
<h4 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h4><p><strong>发送时延</strong> 指发送数据所需要是时间。从发送数据帧的第一个比特算起，到最后一个比特发送完毕所需的时间。 发送时延 = 数据帧长度(b) / 发送速率( b/s )。</p>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a><strong>传播时延</strong></h4><p><strong>传播时延</strong> 指数据在传输信道媒体上需要的时间。</p>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a><strong>处理时延</strong></h4><p><strong>处理时延</strong> 指主机或路由在收到分组后，处理分组的时间。</p>
<h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p><strong>排队时延</strong> 指分组在传输中，在路由器输入输出队里中等待的时间。</p>
<h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><p><strong>往返时间 RTT (Round-Trip Time)</strong> 表示从发送数据开始 ，到发送方收到来自接收方确认所经历的时间。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>ISP</strong></p>
<p>ISP（Internet Service Provider）因特网服务提供商。IP 地址管理机构不会将单个IP直接分配给个人，而是将 IP 地址批量有偿分配给经审查合格的 ISP，机构或个人再有偿从 ISP 获取 IP。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>无法将“ssh-keygen”项识别为 cmdlet、函数、脚本文件或可运行程序的名称</title>
    <url>/tortoisegit/%E6%97%A0%E6%B3%95%E5%B0%86%E2%80%9Cssh-keygen%E2%80%9D%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA%20cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>无法将“ssh-keygen”项识别为 cmdlet、函数、脚本文件或可运行程序的名称</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用git bash运行ssh-keygen命令即可</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>angulerjs 调试</title>
    <url>/web/angularjs/angularjs%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="将-dom-元素包装成-angular-元素"><a href="#将-dom-元素包装成-angular-元素" class="headerlink" title="将 dom 元素包装成 angular 元素"></a>将 dom 元素包装成 angular 元素</h1><p>将 dom 元素包装成 angular 元素后，可以获取和使用一些 angular 属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;domid&#x27;</span>);</span><br><span class="line">$angularEle = angular.element(dom);</span><br></pre></td></tr></table></figure>

<h1 id="通过-angular-元素拿到-scope-对象"><a href="#通过-angular-元素拿到-scope-对象" class="headerlink" title="通过 angular 元素拿到 scope 对象"></a>通过 angular 元素拿到 scope 对象</h1><p>angular 元素的 scope() 方法可以返回离其最近的$scope对象，进而可以获取$scope对象上的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$angularEle.scope();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title>angulerjs 事件</title>
    <url>/web/angularjs/angulerjs-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-事件的作用"><a href="#1-事件的作用" class="headerlink" title="1 事件的作用"></a>1 事件的作用</h1><p>事件的作用：在组件间进行通信。</p>
<h1 id="2-事件的使用"><a href="#2-事件的使用" class="headerlink" title="2 事件的使用"></a>2 事件的使用</h1><p>事件的使用：事件发生者传播事件，事件关心者监听事件，进而在监听事件中进行相应的操作。</p>
<h2 id="2-1-angularjs-事件和-js-事件区别"><a href="#2-1-angularjs-事件和-js-事件区别" class="headerlink" title="2.1 angularjs 事件和 js 事件区别"></a>2.1 angularjs 事件和 js 事件区别</h2><p>angularjs 事件和原生 js 事件的不同之处在于，angularjs 事件是通过 scope 来监听和传播的，而 js 原生事件是通过 dom 来监听和传播的。</p>
<h2 id="2-2-angularjs-事件传播"><a href="#2-2-angularjs-事件传播" class="headerlink" title="2.2 angularjs 事件传播"></a>2.2 angularjs 事件传播</h2><h3 id="2-2-1-向上传播-scope-emit"><a href="#2-2-1-向上传播-scope-emit" class="headerlink" title="2.2.1 向上传播 scope.$emit"></a>2.2.1 向上传播 scope.$emit</h3><p>通过 scope.$emit(evtName,  data ) 把事件通过作用域链向上传播。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在与scope在同一个作用域链上的所有父scope，只要通过 scope.$on添加了监听，都会触发监听器的执行</span><br><span class="line">scope.$emit(&#x27;progressChange&#x27;, 20);//20即为要传递给监听器的第二个数据参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-向下传播-scope-broadcast"><a href="#2-2-2-向下传播-scope-broadcast" class="headerlink" title="2.2.2 向下传播 scope.$broadcast"></a>2.2.2 向下传播 scope.$broadcast</h3><p>通过 scope.$broadcast(evtName,  data ) 把事件通过作用域链向下传播。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在与scope在同一个作用域链上的所有子scope，只要通过 scope.$on添加了监听，都会触发监听器的执行</span></span><br><span class="line">scope.$broadcast(<span class="string">&#x27;progressChange&#x27;</span>, <span class="number">20</span>);<span class="comment">//20即为要传递给监听器的第二个数据参数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-angularjs-事件监听"><a href="#2-3-angularjs-事件监听" class="headerlink" title="2.3 angularjs 事件监听"></a>2.3 angularjs 事件监听</h2><h3 id="2-3-1-监听方法"><a href="#2-3-1-监听方法" class="headerlink" title="2.3.1 监听方法"></a>2.3.1 监听方法</h3><p>通过 scope.$on(evtName,  handleFun) 方法，可以为指定事件注册监听器。</p>
<p>scope.$on函数返回值为反注册函数，我们可以调用它来取消监听器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cancelHandle = scope.$on(<span class="string">&#x27;progressChange&#x27;</span>, changeHandle);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleHandle</span>(<span class="params">evt, data</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//data为传播者传递过来的数据</span></span><br><span class="line">	<span class="comment">//进行刷新组件内容等操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelHandle();<span class="comment">//可以取消监听器</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-事件对象"><a href="#2-3-2-事件对象" class="headerlink" title="2.3.2 事件对象"></a>2.3.2 事件对象</h3><p>事件监听器的第一个参数即事件对象，事件对象有以下属性，可以通过事件对象属性对事件进行一些操作。</p>
<p>1、targetScope（作用域对象）</p>
<p>​    发送或广播事件的作用域</p>
<p>2、currentScope（作用域对象）</p>
<p>​    当前处理事件的作用域</p>
<p>3、name（字符串）</p>
<p>​    事件名称</p>
<p>4、stopPropagation（函数）</p>
<p>   当事件通过$emit进行传播时，可以通过 stopPropagation 取消后续的传播</p>
<p>5、preventDefault（函数）</p>
<p>​    preventDafault 执行后不会阻止事件传播，但是会把 defaultPrevented 标记设置为 true，子作用域可以通过此字段来决定是否需要再处理这个事件。</p>
<p>6、defaultPrevented（布尔值）</p>
<p>​    可以通过 defaultPrevented 来决定是否需要处理此事件</p>
]]></content>
      <categories>
        <category>web</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title>angulerjs 作用域</title>
    <url>/web/angularjs/angulerjs-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="作用域的作用"><a href="#作用域的作用" class="headerlink" title="作用域的作用"></a>作用域的作用</h1><p>在 angularjs 中，作用域 $scope 充当 MVC 中 M 的角色，将视图和控制器连接在了一起。$scope 的所有属性，都能被视图自动访问到。</p>
<p>angularjs 在启动时，会将 $rootScope 和 ng-app 绑定在一起， $rootScope 在所有 $scope 的顶层，是根作用域。</p>
<p>作用域具有的功能：</p>
<ol>
<li>给表达式提供上下文</li>
<li>隔离业务功能和数据</li>
<li>监视数据模型变化，将变化通知给整个应用</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>web</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title>angulerjs 模块</title>
    <url>/web/angularjs/angulerjs-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="angularjs模块的作用"><a href="#angularjs模块的作用" class="headerlink" title="angularjs模块的作用"></a>angularjs模块的作用</h2><p>在angularjs中，一个应用可以包含多个模块，每个模块定义了具体的功能。</p>
<p>模块的作用：</p>
<ol>
<li>保持命名空间清洁</li>
<li>编写测试代码方法</li>
<li>代码复用</li>
<li>使应用可以按照任意顺序加载代码</li>
</ol>
<h2 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h2><p>angular.module( appName’, []）这个方法可以用来定义模块，相当于模块的 setter 方法。</p>
<p>第一个参数是模块名称</p>
<p>第二个参数是模块依赖列表，数组的每个元素都是模块名称，这些依赖会在本模块加载前由注入器进行预加载。</p>
<h2 id="模块的引用"><a href="#模块的引用" class="headerlink" title="模块的引用"></a>模块的引用</h2><p>angular.module( ‘appName’ ) 这个方法用来引用模块，相当于模块的 getter 方法。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel</title>
    <url>/web/babel/Babel/</url>
    <content><![CDATA[<h1 id="1-Babel-是什么"><a href="#1-Babel-是什么" class="headerlink" title="1 Babel 是什么"></a>1 Babel 是什么</h1><p>Babel 是一个 JS 编译器，能够将 ES6+ 版本的 JS 语法编译为向后兼容的 JS 语法，进而使我们无需等待浏览器支持就可以使用新语法。</p>
<h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><p>通过下面命令安装所需包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure>

<h2 id="2-1-安装包介绍"><a href="#2-1-安装包介绍" class="headerlink" title="2.1 安装包介绍"></a>2.1 安装包介绍</h2><h3 id="2-1-1-babel-core"><a href="#2-1-1-babel-core" class="headerlink" title="2.1.1 @babel/core"></a>2.1.1 @babel/core</h3><p>​    @babel/core 是  Babel 的核心模块，可以将代码解析成 AST，各个插件会在 AST 的基础上进行语法转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"></span><br><span class="line">babel.transform(<span class="string">&quot;code&quot;</span>, optionsObject);</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-babel-cli"><a href="#2-1-2-babel-cli" class="headerlink" title="2.1.2 @babel/cli"></a>2.1.2 @babel/cli</h3><p>@babel/cli 是 Babel 的命令行工具，可以使我们通过命令行使用使用 Babel。</p>
<p>安装后可以通过下面方式使用 @babel/cli：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib</span><br></pre></td></tr></table></figure>

<p>这个命令将解析 src 目录中的所有 JS 文件，并将每个文件的转换结果输出到 lib 目录。 由于我们没告诉它应该如何转换，因此输出代码将与输入相同（不保留代码样式）。 我们可以通过选项参数来指定所需的转换。</p>
<h3 id="2-1-3-Plugins-amp-Presets"><a href="#2-1-3-Plugins-amp-Presets" class="headerlink" title="2.1.3 Plugins &amp; Presets"></a>2.1.3 Plugins &amp; Presets</h3><h4 id="2-1-3-1-Plugins（插件）"><a href="#2-1-3-1-Plugins（插件）" class="headerlink" title="2.1.3.1 Plugins（插件）"></a>2.1.3.1 Plugins（插件）</h4><p>Babel 通过具体 Plugins（插件）来进行语法转换，如 @babel/plugin-transform-arrow-functions 可以将箭头函数转换为普通函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-arrow-functions</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [ <span class="string">&quot;myPlugin&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>短名称</p>
<p>如果插件名称的前缀为 <code>babel-plugin-</code>，则可以使用它的短名称</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;myPlugin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-plugin-myPlugin&quot;</span> <span class="comment">// 两个插件实际是同一个</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这也适用于带有 scope 的插件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@org/babel-plugin-name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@org/name&quot;</span> <span class="comment">// 两个插件实际是同一个</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-3-2-Presets（预设）"><a href="#2-1-3-2-Presets（预设）" class="headerlink" title="2.1.3.2 Presets（预设）"></a>2.1.3.2 Presets（预设）</h4><p>@babel/presets-* 是一组插件的集合，安装一个 Presets 可以替代单独安装多个插件。可以通过创建自己的 Presets 来创建任意插件的组合。</p>
<p>@babel/preset-env 是最常用的 Presets，包含了支持 ES6+ 特性的大多插件。如果源码使用了不在 @babel/preset-env 中的语法，编译时会报错，可根据具体错误提示安装对应插件，并将对应插件添加到 babel 配置文件中。</p>
<ul>
<li><p>配置</p>
<p>直接配置 Presets 名称 Babel 会在 nodde_module 目录中查找：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;babel-preset-myPreset&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以配置 Presets 的绝对/相对路径：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;./myProject/myPreset&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>短名称</p>
<p>如果 Presets 名称的前缀为 <code>babel-preset-</code>，则还可以使用它的短名称：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;myPreset&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-myPreset&quot;</span> <span class="comment">// 这两个相同</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短名称也适用于带有冠名（scope）的 Presets：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@org/babel-preset-name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@org/name&quot;</span> <span class="comment">// 这两个相同</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-3-3-执行顺序"><a href="#2-1-3-3-执行顺序" class="headerlink" title="2.1.3.3 执行顺序"></a>2.1.3.3 执行顺序</h4><ul>
<li><p>插件比 presets 先运行</p>
</li>
<li><p>插件按照<strong>从前往后</strong>的顺序执行</p>
</li>
<li><p>Presets 按照<strong>从后往前</strong>的顺序执行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行顺序： transform-decorators-legacy  transform-class-properties</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-decorators-legacy&quot;</span>, <span class="string">&quot;transform-class-properties&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行顺序：stage-2、react 然后是 es2015。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>, <span class="string">&quot;react&quot;</span>, <span class="string">&quot;stage-2&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-3-4-参数配置"><a href="#2-1-3-4-参数配置" class="headerlink" title="2.1.3.4 参数配置"></a>2.1.3.4 参数配置</h4><p>插件和 Presets 都可以接受参数，插件名和参数对象组成一个数组。</p>
<p>下面几种情况都属于不配置参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;pluginA&quot;</span>, [<span class="string">&quot;pluginA&quot;</span>], [<span class="string">&quot;pluginA&quot;</span>, &#123;&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件配置参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;transform-async-to-module-method&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;bluebird&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;coroutine&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Presets 配置参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;loose&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-4-babel-polyfill"><a href="#2-1-4-babel-polyfill" class="headerlink" title="2.1.4 @babel/polyfill"></a>2.1.4 @babel/polyfill</h3><p>polyfill 是垫片的意思。Babel 将 ES 标准分为 syntax 和 built-in 两种类型，对于可以通过改写覆盖方法实现的就是 built-in，如 Array.prototype.includes、Array.from、Object.assign、Promise 等，而对于如 const、let、import、class 则被分类为 syntax。 </p>
<p>对于 built-in 类型会通过 @babel/polyfill 来进行转译，其实现方法即通过 Object.defineProperty 来实现这些标准。</p>
<h3 id="2-1-5-core-js"><a href="#2-1-5-core-js" class="headerlink" title="2.1.5 core-js"></a>2.1.5 core-js</h3><p>Babel 在 7.4.0 版本中宣布废弃 @babel/polyfill，使用 core-js 替代。</p>
<h4 id="2-1-5-1-安装"><a href="#2-1-5-1-安装" class="headerlink" title="2.1.5.1 安装"></a>2.1.5.1 安装</h4><p>生产环境也需要 core-js，所以使用 –save 安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install core-js --save</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-2-配置"><a href="#2-1-5-2-配置" class="headerlink" title="2.1.5.2 配置"></a>2.1.5.2 配置</h4><p>在 babel 配置文件中通过配置 <code>useBuiltIns</code> 来控制 built-in 类型垫片的注入。可以设置成 <code>entry</code>、<code>usage</code>和<code>false</code>， 默认值为 <code>false</code> 。</p>
<ul>
<li>entry：在入口注入目标环境所有不支持的 built-in，会增加代码体积。</li>
<li>usage：编译时根据源码对 built-in  的使用情况，在对应页面注入相应的实现</li>
<li>false：表示不注入垫片</li>
</ul>
<h3 id="2-1-6-babel-plugin-transform-runtime"><a href="#2-1-6-babel-plugin-transform-runtime" class="headerlink" title="2.1.6 @babel/plugin-transform-runtime"></a>2.1.6 @babel/plugin-transform-runtime</h3><p>@babel/plugin-transform-runtime 可以将编译后文件中的重复 helper 函数提取出来，并且能够提供沙箱环境，达到了节省代码体积、不会污染全局的效果。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 core-js</span></span><br><span class="line">npm uninstall --save @babel/runtime</span><br><span class="line">npm install --save @babel/runtime-corejs3</span><br></pre></td></tr></table></figure>

<p>@babel/plugin-transform-runtime 的默认配置不会包含 core-js ，需要通过 corejs 选项来设置，并且需要安装对应 corejs 的版本。</p>
<table>
<thead>
<tr>
<th>corejs option</th>
<th>Install command</th>
</tr>
</thead>
<tbody><tr>
<td>false</td>
<td>npm install –save @babel/runtime</td>
</tr>
<tr>
<td>2</td>
<td>npm install –save @babel/runtime-corejs2</td>
</tr>
<tr>
<td>3</td>
<td>npm install –save @babel/runtime-corejs3</td>
</tr>
</tbody></table>
<h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h1><p>项目根目录配置 babel.config.json 文件：</p>
<p>targets 属性配置目标环境，babel 会根据目标环境来进行按需转译。</p>
<p>不使用 @babel/plugin-transform-runtime 的配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;corejs&quot;</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 @babel/plugin-transform-runtime 的配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">&quot;plugins&quot;</span>: [[<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>, &#123; <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span> &#125;]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/6844903602822053895">https://juejin.im/post/6844903602822053895</a></p>
<p><a href="https://babeljs.io/docs/en/next/babel-preset-env.html">https://babeljs.io/docs/en/next/babel-preset-env.html</a></p>
<p><a href="https://www.cnblogs.com/sefaultment/p/11631314.html">https://www.cnblogs.com/sefaultment/p/11631314.html</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>Babel</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios</title>
    <url>/web/axios/Axios/</url>
    <content><![CDATA[<h1 id="Axios是什么"><a href="#Axios是什么" class="headerlink" title="Axios是什么"></a>Axios是什么</h1><p>Axios 是一个基于 promise 的 HTTP 库，可以在浏览器和 node.js 中使用。</p>
<h1 id="Axios特点"><a href="#Axios特点" class="headerlink" title="Axios特点"></a>Axios特点</h1><ul>
<li>支持在 浏览器 和 node 中使用</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li>
</ul>
<h1 id="Axios安装"><a href="#Axios安装" class="headerlink" title="Axios安装"></a>Axios安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install axios</span></span><br></pre></td></tr></table></figure>

<h1 id="Axios使用"><a href="#Axios使用" class="headerlink" title="Axios使用"></a>Axios使用</h1><h2 id="axios-…"><a href="#axios-…" class="headerlink" title="axios({…})"></a>axios({…})</h2><p>通过执行 axios({config})来创建请求。下面是 config 参数的可配置值。只有 <code>url</code> 是必需的， <code>method</code>默认使用 <code>get</code> 方法.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认是 get</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params` 是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属：FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属： Stream</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认的</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span></span><br><span class="line">  <span class="comment">// 如果设置为0，将不会 follow 任何重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#x27;proxy&#x27; 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: : &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可支持请求的别名"><a href="#可支持请求的别名" class="headerlink" title="可支持请求的别名"></a>可支持请求的别名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>get 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  	 .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(response);</span><br><span class="line">  	 &#125;)</span><br><span class="line">  	 .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(error);</span><br><span class="line">  	 &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    		<span class="attr">params</span>: &#123;</span><br><span class="line">      			<span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    	  &#125;</span><br><span class="line">  	  &#125;)</span><br><span class="line">  	  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(response);</span><br><span class="line">  	   &#125;)</span><br><span class="line">  	  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(error);</span><br><span class="line">  	  &#125;);</span><br></pre></td></tr></table></figure>

<p>post 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成，acct、perms分别为第一个和第二个请求的返回值</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

<h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>可以使用自定义配置新建一个 axios 实例，axios.create([config])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>请求的响应包含以下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // `data` 由服务器提供的响应</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class="line">  status: 200,</span><br><span class="line"></span><br><span class="line">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class="line">  statusText: &#x27;OK&#x27;,</span><br><span class="line"></span><br><span class="line">  // `headers` 服务器响应的头</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `config` 是为请求提供的配置信息</span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>then</code> 时，你将接收下面这样的响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h2><h3 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&#x27;https://api.example.com&#x27;</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">&#x27;Authorization&#x27;</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例时设置配置的默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实例已创建后修改默认值</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">&#x27;Authorization&#x27;</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure>

<h3 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h3><p>config参数 &gt; defaults 属性 &gt;  lib/defaults.js</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>移除拦截：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>Axios</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint使用</title>
    <url>/web/eslint/eslint%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-lint-简介"><a href="#1-lint-简介" class="headerlink" title="1 lint 简介"></a>1 lint 简介</h2><p>lint 最早用于 c 语言，用来检查代码。目前作为通用术语，用来表示代码检查工具。</p>
<p>JS 经历的主流 lint 工具如下：</p>
<p>1、JSLint</p>
<p>2、JSHint</p>
<p>3、Eslint</p>
<h2 id="2-ESlint-配置"><a href="#2-ESlint-配置" class="headerlink" title="2 ESlint 配置"></a>2 ESlint 配置</h2><h3 id="2-1-初始化项目"><a href="#2-1-初始化项目" class="headerlink" title="2.1 初始化项目"></a>2.1 初始化项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在新建好的文件夹下，执行如下命令，得到 package.json</span><br><span class="line">npm init -y </span><br></pre></td></tr></table></figure>

<h3 id="2-2-安装-amp-初始化-ESLint"><a href="#2-2-安装-amp-初始化-ESLint" class="headerlink" title="2.2 安装&amp;初始化 ESLint"></a>2.2 安装&amp;初始化 ESLint</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：全局安装 &amp; 初始化  </span></span><br><span class="line">npm install eslint -g   <span class="comment">//安装</span></span><br><span class="line">eslint --init           <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：本地安装 &amp; 初始化   ====》推荐方式</span></span><br><span class="line"><span class="comment">//安装</span></span><br><span class="line">npm insall eslint       </span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">.\node_modules\.bin\eslint --init   <span class="comment">//window平台</span></span><br><span class="line">./node_modules/.bin/eslint --init  <span class="comment">//linux平台</span></span><br></pre></td></tr></table></figure>

<img src="/web/eslint/eslint%E9%85%8D%E7%BD%AE/eslint_init.PNG" class="">

<p>根据项目实际情况选择，完成后可得到规则配置文件 .eslintrc.js  或 .eslintrc.ymal 或 eslintrc.json，下面是对 .eslintrc.js 文件的内容解析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//通过定义 env 来预定义对应的全局变量</span></span><br><span class="line">    <span class="comment">//可选 env 的配置值如下：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        browser - 浏览器环境中的全局变量。</span></span><br><span class="line"><span class="comment">        node - Node.js 全局变量和 Node.js 作用域。</span></span><br><span class="line"><span class="comment">        commonjs - CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</span></span><br><span class="line"><span class="comment">        shared-node-browser - Node.js 和 Browser 通用全局变量。</span></span><br><span class="line"><span class="comment">        es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。</span></span><br><span class="line"><span class="comment">        worker - Web Workers 全局变量。</span></span><br><span class="line"><span class="comment">        amd - 将 require() 和 define() 定义为像 amd 一样的全局变量。</span></span><br><span class="line"><span class="comment">        mocha - 添加所有的 Mocha 测试全局变量。</span></span><br><span class="line"><span class="comment">        jasmine - 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。</span></span><br><span class="line"><span class="comment">        jest - Jest 全局变量。</span></span><br><span class="line"><span class="comment">        phantomjs - PhantomJS 全局变量。</span></span><br><span class="line"><span class="comment">        protractor - Protractor 全局变量。</span></span><br><span class="line"><span class="comment">        qunit - QUnit 全局变量。</span></span><br><span class="line"><span class="comment">        jquery - jQuery 全局变量。</span></span><br><span class="line"><span class="comment">        prototypejs - Prototype.js 全局变量。</span></span><br><span class="line"><span class="comment">        shelljs - ShellJS 全局变量。</span></span><br><span class="line"><span class="comment">        meteor - Meteor 全局变量。</span></span><br><span class="line"><span class="comment">        mongo - MongoDB 全局变量。</span></span><br><span class="line"><span class="comment">        applescript - AppleScript 全局变量。</span></span><br><span class="line"><span class="comment">        nashorn - Java 8 Nashorn 全局变量。</span></span><br><span class="line"><span class="comment">        serviceworker - Service Worker 全局变量。</span></span><br><span class="line"><span class="comment">        atomtest - Atom 测试全局变量。</span></span><br><span class="line"><span class="comment">        embertest - Ember 测试全局变量。</span></span><br><span class="line"><span class="comment">        webextensions - WebExtensions 全局变量。</span></span><br><span class="line"><span class="comment">        greasemonkey - GreaseMonkey 全局变量。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;es6&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;node&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//extend 属性值</span></span><br><span class="line">    <span class="comment">//eslint:all 表示启用当前安装的 ESLint 中所有的核心规则，慎用，因为会随 eslint 的版本变动而更新</span></span><br><span class="line">    <span class="comment">//可以配置文件的绝对/相对路径，相对路径相对于当前配置文件（除非当前配置在home路径或非 eslint 安装目录的父级目录）。</span></span><br><span class="line">    <span class="comment">// &quot;./node_modules/coding-standard/.eslintrc-es6&quot;</span></span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="comment">//eslint:recommended 表示所有在 https://eslint.bootcss.com/docs/rules/ 被标记为对号的规则将会默认开启</span></span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:react/recommended&quot;</span>，</span><br><span class="line">        <span class="string">&quot;airbnb&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 globals 选项配置全局变量</span></span><br><span class="line">    <span class="comment">//注意：要启用 no-global-assign 规则来禁止对只读的全局变量进行修改</span></span><br><span class="line">    <span class="string">&quot;globals&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Atomics&quot;</span>: <span class="literal">false</span>, <span class="comment">//false表示该变量只读</span></span><br><span class="line">        <span class="string">&quot;SharedArrayBuffer&quot;</span>: <span class="literal">false</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//默认值 esprima，不解析非 es5 语法</span></span><br><span class="line">    <span class="string">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,<span class="comment">//让 eslint 支持 babel 语法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认情况下，ESLint 支持 ECMAScript 5 语法</span></span><br><span class="line">    <span class="comment">//配置parserOptions来 启用对 ECMAScript 其它版本和 JSX 的支持</span></span><br><span class="line">    <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ecmaFeatures&quot;</span>: &#123;<span class="comment">//ecmaFeatures配置想额外使用的语言特性</span></span><br><span class="line">            <span class="comment">//对JSX 语法的支持不用于对 React 的支持,想要支持React，推荐使用 eslint-plugin-reac</span></span><br><span class="line">            <span class="string">&quot;jsx&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ecmaVersion来配置ecma对应版本语法的支持;</span></span><br><span class="line">        <span class="comment">//要额外支持新的 ES6 全局变量，使用 &#123; &quot;env&quot;:&#123; &quot;es6&quot;: true &#125; &#125;;</span></span><br><span class="line">        <span class="string">&quot;ecmaVersion&quot;</span>: <span class="number">2018</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sourceType默认值为&quot;script&quot;</span></span><br><span class="line">        <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parser选项配置解析器 默认值为esprima，可选值还有eslint-babel, @typescript-eslint/parser</span></span><br><span class="line">    <span class="string">&quot;parser&quot;</span>: <span class="string">&quot;eslint-babel&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//plugins 选项配置第三方插件，插件安装后才能使用</span></span><br><span class="line">    <span class="comment">//全局安装的 eslint 只能使用全局安装的插件</span></span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react&quot;</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用rules选项配置项目要使用的规则</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &quot;off&quot; or 0 - 关闭规则</span></span><br><span class="line"><span class="comment">        &quot;warn&quot; or 1 - 开启规则 提示信息为告警级别</span></span><br><span class="line"><span class="comment">        &quot;error&quot; or 2 - 开启规则 提示信息为报错级别</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">quotes</span>: [<span class="string">&quot;error&quot;</span>, <span class="string">&quot;double&quot;</span>],<span class="comment">//当规则有其他选项时，可使用数组来指定规则的值</span></span><br><span class="line">        <span class="string">&quot;plugin1/rule1&quot;</span>: <span class="string">&quot;error&quot;</span> <span class="comment">//使用插件中的规则时，需要使用 插件名/规则ID 的形式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-配置ESLint规则"><a href="#2-3-配置ESLint规则" class="headerlink" title="2.3 配置ESLint规则"></a>2.3 配置ESLint规则</h3><h3 id="2-3-1-配置方式"><a href="#2-3-1-配置方式" class="headerlink" title="2.3.1 配置方式"></a>2.3.1 配置方式</h3><p>主要有两种方式类配置ESLint：</p>
<ul>
<li>注释</li>
<li>配置文件</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>通过在源码文件中添加注释来配置lint规则，此方法通常用于临时临时禁止某些严格的lint警告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//放在文件顶部整个文件都不会有警告了</span><br><span class="line">/* eslint-disable */ </span><br></pre></td></tr></table></figure>



<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置文件类型"><a href="#配置文件类型" class="headerlink" title="配置文件类型"></a>配置文件类型</h5><p>文件类型及优先级排序如下：</p>
<ol>
<li><code>.eslintrc.js</code></li>
<li><code>.eslintrc.yaml</code></li>
<li><code>.eslintrc.yml</code></li>
<li><code>.eslintrc.json</code></li>
<li><code>.eslintrc</code>（弃用）</li>
<li><code>package.json</code> //在 <code>package.json</code> 里创建<code>eslintConfig</code>属性，在此属性中进行配置</li>
</ol>
<h5 id="配置文件使用方式"><a href="#配置文件使用方式" class="headerlink" title="配置文件使用方式"></a>配置文件使用方式</h5><p>配置文件有两种使用方式，无论哪种方式配置文件都会覆盖默认设置。</p>
<ul>
<li><h6 id="eslintrc-和-package-json"><a href="#eslintrc-和-package-json" class="headerlink" title=".eslintrc.* 和 package.json"></a>.eslintrc.* 和 package.json</h6><p>​    使用 <code>.eslintrc.*</code> 和 <code>package.json</code> 文件，eslint 将自动从被检测目录开始寻找（可通过配置<code>root:true</code>来阻止 eslint），直到系统根目录，当想对项目的不同部分分别进行配置时，这种方式很有用。</p>
<p> 此方式需要注意：</p>
<ul>
<li><p><code>.eslintrc.*</code> 文件可以进行层叠配置。</p>
<p>eslint 会将被检测文件目录层次结构中的 eslint 配置文件规则进行组合，离被检测文件最近的规则优先级最高。如检测下面代码结构中的 test.js 文件时，<code>your-project/tests/.eslintrc</code>文件优先级要高于<code>your-project/.eslintrc</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your-project</span><br><span class="line">├── .eslintrc</span><br><span class="line">├── lib</span><br><span class="line">│ └── source.js</span><br><span class="line">└─┬ tests</span><br><span class="line">  ├── .eslintrc</span><br><span class="line">  └── test.js</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>同一目录下 <code>.eslintrc</code> 和 <code>package.json</code> 同时存在时，<code>.eslintrc</code> 优先级高会被使用，<code>package.json</code> 文件将不会被使用。</li>
</ul>
</li>
<li><h6 id="命令行参数-c"><a href="#命令行参数-c" class="headerlink" title="命令行参数 -c"></a>命令行参数 -c</h6><p>使用 <code>-c</code> 参数，来传递配置文件。想要 eslint 忽略任何 <code>.eslintrc.*</code> 文件，需使用 <code>--no-eslintrc</code> 的同时，加上 <code>-c</code> 标记。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">eslint -c myconfig.json myfiletotest.js</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="配置规则优先级总结"><a href="#配置规则优先级总结" class="headerlink" title="配置规则优先级总结"></a>配置规则优先级总结</h5><ul>
<li><p>优先级从高到底：</p>
<ul>
<li>行内配置<ol>
<li><code>/*eslint-disable*/</code> 和 <code>/*eslint-enable*/</code></li>
<li>``/<em>global</em>/`</li>
<li><code>/*eslint*/</code></li>
<li>``/<em>eslint-env</em>/`</li>
</ol>
</li>
<li>命令行选项（或 CLIEngine 等价物）：<ol>
<li><code>--global</code></li>
<li>``–rule`</li>
<li><code>--env</code></li>
<li><code>-c</code>、<code>--config</code></li>
</ol>
</li>
<li>项目级配置：<ol>
<li>与要检测的文件在同一目录下的 <code>.eslintrc.*</code> 或 <code>package.json</code> 文件</li>
<li>继续在父级目录寻找 <code>.eslintrc</code> 或 <code>package.json</code> 文件，直到根目录（包括根目录）或直到发现一个包含 <code>&quot;root&quot;: true</code> 的配置文件。</li>
</ol>
</li>
<li>如果不是上面类型中的任何一种情况，则退回到 <code>~/.eslintrc</code> 中自定义的默认配置。</li>
</ul>
</li>
<li><p>具体规则说明：</p>
<p><a href="https://eslint.bootcss.com/docs/rules/">https://eslint.bootcss.com/docs/rules/</a></p>
</li>
</ul>
<h3 id="2-4-配置忽略文件"><a href="#2-4-配置忽略文件" class="headerlink" title="2.4 配置忽略文件"></a>2.4 配置忽略文件</h3><ul>
<li>.eslintignore</li>
<li>–ignore-path</li>
<li>package.json</li>
</ul>
<h5 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a>.eslintignore</h5><p>在项目根目录，创建<code>.eslintignore</code>文件，在文件中指定需要忽略的文件和目录。每一行都是一个 glob 模式表明哪些路径应该忽略检测。</p>
<p>Globs 匹配使用 <a href="https://github.com/kaelzhang/node-ignore">node-ignore</a>，所以大量可用的特性有：</p>
<ul>
<li>注释以 <code>#</code> 开头</li>
<li>路径是相对于 <code>.eslintignore</code> 的位置或当前工作目录。这也会影响通过 <code>--ignore-pattern</code>传递的路径。</li>
<li>忽略模式同 <code>.gitignore</code> <a href="https://git-scm.com/docs/gitignore">规范</a></li>
<li>以 <code>!</code> 开头的行是否定模式，它将会重新包含一个之前被忽略的模式。</li>
</ul>
<p>除了 <code>.eslintignore</code> 文件中的模式，eslint总是忽略 <code>/node_modules/*</code> 和 <code>/bower_components/*</code> 中的文件。</p>
<h5 id="–ignore-path"><a href="#–ignore-path" class="headerlink" title="–ignore-path"></a>–ignore-path</h5><p>在命令行使用 <code>--ignore-path</code> 选项指定忽略项所在配置文件。指定 <code>--ignore-path</code> 意味着任何现有的 <code>.eslintignore</code> 文件将不被使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslint --ignore-path .jshintignore file.js</span><br></pre></td></tr></table></figure>

<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><p>如果没有发现 <code>.eslintignore</code> 文件，也没有指定替代文件，ESLint 将在 package.json 文件中查找 <code>eslintIgnore</code> 键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mypackage&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">      &quot;env&quot;: &#123;</span><br><span class="line">          &quot;browser&quot;: true,</span><br><span class="line">          &quot;node&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintIgnore&quot;: [&quot;hello.js&quot;, &quot;world.js&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-命令行说明"><a href="#2-5-命令行说明" class="headerlink" title="2.5 命令行说明"></a>2.5 命令行说明</h3><p>命令行选项可以通过<code>.\node_modules\.bin\eslint -h</code>  查看，得到如下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eslint [options] file.js [file.js] [dir]</span><br><span class="line"></span><br><span class="line">Basic configuration:</span><br><span class="line"><span class="comment">//禁用 .eslintrc.* 和 package.json 文件中的配置</span></span><br><span class="line">  --no-eslintrc                  Disable use <span class="keyword">of</span> configuration <span class="keyword">from</span> .eslintrc.*</span><br><span class="line"><span class="comment">//指定一个其他的配置文件      </span></span><br><span class="line">  -c, --config path::<span class="built_in">String</span>      Use <span class="built_in">this</span> configuration, overriding .eslintrc.* config options <span class="keyword">if</span> present</span><br><span class="line"><span class="comment">//--ext 只有在参数为目录时，才生效  </span></span><br><span class="line">  --env [<span class="built_in">String</span>]                 Specify environments</span><br><span class="line">  --ext [<span class="built_in">String</span>]                 Specify JavaScript file extensions - <span class="keyword">default</span>: .js</span><br><span class="line">  --<span class="built_in">global</span> [<span class="built_in">String</span>]              Define <span class="built_in">global</span> variables</span><br><span class="line">  --parser <span class="built_in">String</span>                Specify the parser to be used</span><br><span class="line">  --parser-options <span class="built_in">Object</span>        Specify parser options</span><br><span class="line">  --resolve-plugins-relative-to path::<span class="built_in">String</span>  A folder where plugins should be resolved <span class="keyword">from</span>, CWD by <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">Specifying rules and plugins:</span><br><span class="line">  --rulesdir [path::<span class="built_in">String</span>]      Use additional rules <span class="keyword">from</span> <span class="built_in">this</span> directory</span><br><span class="line">  --plugin [<span class="built_in">String</span>]              Specify plugins</span><br><span class="line">  --rule <span class="built_in">Object</span>                  Specify rules</span><br><span class="line"></span><br><span class="line">Fixing problems:</span><br><span class="line">  --fix                          Automatically fix problems</span><br><span class="line">  --fix-dry-run                  Automatically fix problems without saving the changes to the file system</span><br><span class="line">  --fix-type <span class="built_in">Array</span>               Specify the types <span class="keyword">of</span> fixes to apply (problem, suggestion, layout)</span><br><span class="line"></span><br><span class="line">Ignoring files:</span><br><span class="line">  --ignore-path path::<span class="built_in">String</span>     Specify path <span class="keyword">of</span> ignore file</span><br><span class="line">  --no-ignore                    Disable use <span class="keyword">of</span> ignore files and patterns</span><br><span class="line">  --ignore-pattern [<span class="built_in">String</span>]      Pattern <span class="keyword">of</span> files to ignore (<span class="keyword">in</span> addition to those <span class="keyword">in</span> .eslintignore)</span><br><span class="line"></span><br><span class="line">Using stdin:</span><br><span class="line">  --stdin                        Lint code provided on &lt;STDIN&gt; - <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  --stdin-filename <span class="built_in">String</span>        Specify filename to process STDIN <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line">Handling warnings:</span><br><span class="line">  --quiet                        Report errors only - <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  --max-warnings Int             <span class="built_in">Number</span> <span class="keyword">of</span> warnings to trigger nonzero exit code - <span class="keyword">default</span>: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output</span>:</span><br><span class="line">  -o, --output-file path::<span class="built_in">String</span>  Specify file to write report to</span><br><span class="line">  -f, --format <span class="built_in">String</span>            Use a specific output format - <span class="keyword">default</span>: stylish</span><br><span class="line">  --color, --no-color            Force enabling/disabling <span class="keyword">of</span> color</span><br><span class="line"></span><br><span class="line">Inline configuration comments:</span><br><span class="line">  --no-inline-config             Prevent comments <span class="keyword">from</span> changing config or rules</span><br><span class="line">  --report-unused-disable-directives  Adds reported errors <span class="keyword">for</span> unused eslint-disable directives</span><br><span class="line"></span><br><span class="line"><span class="attr">Caching</span>:</span><br><span class="line">  --cache                        Only check changed files - <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  --cache-file path::<span class="built_in">String</span>      Path to the cache file. Deprecated: use --cache-location - <span class="keyword">default</span>: .eslintcache</span><br><span class="line">  --cache-location path::<span class="built_in">String</span>  Path to the cache file or directory</span><br><span class="line"></span><br><span class="line"><span class="attr">Miscellaneous</span>:</span><br><span class="line">  --init                         Run config initialization wizard - <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  --env-info                     Output execution environment information - <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  --debug                        Output debugging information</span><br><span class="line">  -h, --help                     Show help</span><br><span class="line">  -v, --version                  Output the version number</span><br><span class="line">  --print-config path::<span class="built_in">String</span>    Print the configuration <span class="keyword">for</span> the given file</span><br></pre></td></tr></table></figure>





<p>参考链接：</p>
<p><a href="https://eslint.bootcss.com/docs/">https://eslint.bootcss.com/docs/</a></p>
<p><a href="https://eslint.org/docs/user-guide/configuring">https://eslint.org/docs/user-guide/configuring</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>eslint</category>
      </categories>
  </entry>
  <entry>
    <title>css 之 Flex 布局</title>
    <url>/web/css/Flex/</url>
    <content><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h1><p>Flex 布局是 w3c2009 年提出的方案，目前已得到所有浏览器的支持。</p>
<p>Flex（Flexible Box）为弹性布局。采用 Flex 布局的元素被称为<strong>容器</strong>，其<strong>直接子元素</strong>被称为<strong>成员</strong>。成员元素的 float 、clear、vertical-align 属性将失效。</p>
<p>容器有<strong>主轴</strong>和<strong>副轴（副轴和主轴垂直）</strong>，主轴默认为 x 轴，副轴默认为 y 轴，容器左上角为 主、副轴的默认起始点。</p>
<p>下面将元素的 <code>display</code> 属性设置成 <code>flex</code> 或 <code>inline-flex</code> ，即创建了一个 Flex 容器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"> diaplay:flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-可以解决什么问题"><a href="#2-可以解决什么问题" class="headerlink" title="2 可以解决什么问题"></a>2 可以解决什么问题</h1><p>Flex 布局可以解决如下问题：</p>
<ul>
<li>响应式设计</li>
<li>列等高问题</li>
<li>内容居中</li>
</ul>
<h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3 使用方法"></a>3 使用方法</h1><h2 id="3-1-容器可配置属性"><a href="#3-1-容器可配置属性" class="headerlink" title="3.1 容器可配置属性"></a>3.1 容器可配置属性</h2><h3 id="3-1-1-flex-direction"><a href="#3-1-1-flex-direction" class="headerlink" title="3.1.1 flex-direction"></a>3.1.1 flex-direction</h3><p>此属性用来配置<strong>主轴方向</strong> 和 <strong>成员排列方向</strong>，默认主轴为 x 轴，成员沿 x 轴从左到右依次排序。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: row |  //默认值，配置 x 轴为主轴，成员沿 x 轴，从左到右排列</span><br><span class="line">                row-reverse | //配置 x 轴为主轴，表示成员沿 x 轴，从右到左排列</span><br><span class="line">                column | //表示成员沿 y 轴，从上到下排列</span><br><span class="line">                column-reverse; //表示成员沿 y 轴，从下到上排列</span><br></pre></td></tr></table></figure>

<p>下面图依次展示了不同值的排列效果：</p>
<img src="/web/css/Flex/flex-direction.png" class="">

<h3 id="3-1-2-flex-wrap"><a href="#3-1-2-flex-wrap" class="headerlink" title="3.1.2 flex-wrap"></a>3.1.2 flex-wrap</h3><p>当一行排不下时，可以用此属性设置成员是否要换行。默认值为不换行，各成员缩小比例避免溢出容器。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap |  //默认值，不换行</span><br><span class="line">             wrap | // 换行</span><br><span class="line">             wrap-reverse; //反方向换行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面图依次展示了 nowap、wrap、wrap-reverse 的设置效果：</p>
<img src="/web/css/Flex/flex-wrap.png" class="">

<h3 id="3-1-3-flex-flow"><a href="#3-1-3-flex-flow" class="headerlink" title="3.1.3 flex-flow"></a>3.1.3 flex-flow</h3><p><code>flex-flow</code> 是 <code>flex-direction</code>  属性和 <code>flex-wrap</code> 属性的简写形式，默认值为<code>row nowrap</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-justify-content"><a href="#3-1-4-justify-content" class="headerlink" title="3.1.4 justify-content"></a>3.1.4 justify-content</h3><p>此属性用来设置成员在主轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | //默认值，左对齐</span><br><span class="line">                   flex-end | //右对齐</span><br><span class="line">                   center | //居中</span><br><span class="line">                   space-between | //两端对齐，成员间的间隔相同 </span><br><span class="line">                   space-around;//成员间的间隔相同，成员间的间隔比成员和边框的距离大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是假设主轴为水平方向时各个值的设置效果</p>
<img src="/web/css/Flex/justify-content.png" class="">

<h3 id="3-1-5-align-items"><a href="#3-1-5-align-items" class="headerlink" title="3.1.5 align-items"></a>3.1.5 align-items</h3><p>此属性用来设置成员在副轴上的对齐方式。默认值为 stretch，使得当成员没有设置副轴方向大小（或设置为auto）时，则成员撑满副轴方向的空间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch |//默认值，当成员没设置高度或设置为auto时，成员会填满副轴方向的空间</span><br><span class="line">      		   center | //在副轴方向居中</span><br><span class="line">               flex-start |//与副轴的起点对齐</span><br><span class="line">               flex-end | //与副轴的终点对齐</span><br><span class="line">               baseline | //成员的第一行文字基线对齐           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是假设主轴为水平方向时，各值的设置效果</p>
<img src="/web/css/Flex/align-items.png" class="">

<h3 id="3-1-6-align-content"><a href="#3-1-6-align-content" class="headerlink" title="3.1.6 align-content"></a>3.1.6 align-content</h3><p>当 flex-wrap 配置了 wrap 时，可通过 align-content 来配置多根轴线在副轴的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: stretch | //在副轴沾满整个空间</span><br><span class="line">  				flex-start | //与副轴的开始对齐</span><br><span class="line">  				flex-end | //与副轴的终点对齐</span><br><span class="line">      			center | //在副轴巨中</span><br><span class="line">      			space-between | //与副轴两端对齐，轴线之间的间隔平均分布 </span><br><span class="line">      			space-around //每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/web/css/Flex/align-content.png" class="">

<h2 id="3-2-成员可配置属性"><a href="#3-2-成员可配置属性" class="headerlink" title="3.2 成员可配置属性"></a>3.2 成员可配置属性</h2><h3 id="3-2-1-order"><a href="#3-2-1-order" class="headerlink" title="3.2.1 order"></a>3.2.1 order</h3><p>此属性定义成员的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-flex-grow"><a href="#3-2-2-flex-grow" class="headerlink" title="3.2.2 flex-grow"></a>3.2.2 flex-grow</h3><p>此属性用来定义成员的放大比例，默认值为 0，即如果存在剩余空间成员也不放大。</p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。</p>
<p>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/web/css/Flex/flex-grow.png" class="">

<h3 id="3-2-3-flex-shrink"><a href="#3-2-3-flex-shrink" class="headerlink" title="3.2.3 flex-shrink"></a>3.2.3 flex-shrink</h3><p>此属性定义了成员的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。</p>
<p>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/web/css/Flex/flex-shrink.png" class="">

<h3 id="3-2-3-flex-base"><a href="#3-2-3-flex-base" class="headerlink" title="3.2.3 flex-base"></a>3.2.3 flex-base</h3><p>此属性用来给成员预分配主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-flex"><a href="#3-2-4-flex" class="headerlink" title="3.2.4 flex"></a>3.2.4 flex</h3><p>此属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-align-self"><a href="#3-2-5-align-self" class="headerlink" title="3.2.5 align-self"></a>3.2.5 align-self</h3><p>此属性允许单个成员配置与其他成员不一样的对齐方式（在副轴方向），可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-示例"><a href="#4-示例" class="headerlink" title="4 示例"></a>4 示例</h1><h2 id="4-1-居中"><a href="#4-1-居中" class="headerlink" title="4.1 居中"></a>4.1 居中</h2><p>给 flex 布局的成员设置 margin:auto  时 ，自动的外边距会占据全部的可用空间，从而达到居中的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;containerCenter&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.containerCenter</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">background-color</span>: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: hotpink;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mixins">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mixins</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css flex 自适应</tag>
      </tags>
  </entry>
  <entry>
    <title>css 定位控制页面布局</title>
    <url>/web/css/css%20%E5%AE%9A%E4%BD%8D%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>浮动布局的优势在于灵活，却无法实现精确定位，很多布局效果无法实现。</p>
<p>css 定位（css position）可以实现精确定位网页元素的位置。当把元素的 css 属性 position 配置为非 static 后，我们称此元素为 <strong>定位元素</strong> 。<strong>定位元素</strong> 可通过设置坐标值  left、top、right、bottom 来精确控制元素在文档中的位置。</p>
<h1 id="position-属性值"><a href="#position-属性值" class="headerlink" title="position 属性值"></a>position 属性值</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态定位是自然流元素，是position 的默认值，表示按照文档流顺序定位元素，不能通过 left、top、right、bottom来改变元素位置。 </p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><p>相对定位，不脱离文档流，可以通过修改坐标值来调整元素位置。</p>
<p>坐标值的参考物为元素的原始位置。</p>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><p>绝对定位，当绝对定位元素设置了坐标值后，该元素才会在对应方向脱离文档流，否则不会脱离文档流。</p>
<p>坐标值的参照物为离其最近的为 <strong>定位元素</strong> 的<strong>父元素</strong>。</p>
<p>如果绝对定位元素只设置了 absolute，而没有设置坐标值时，则该元素没有脱离文档流，其位置依旧会被直接父元素所影响。下面示例中的绝对定位元素 .child 只设置了 left，所以其垂直方向没有脱离文档流，其位置依旧会受父元素位置的影响。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.relative</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: lime;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: lightcoral;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;relative&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>absolute 只设置了left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<img src="/web/css/css%20%E5%AE%9A%E4%BD%8D%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/absolute-1.png" class="">

<p>当给其父元素 .wrapper 设置属性 ‘margin:30’ 后，父元素会在垂直方向影响到元素 .child 的位置，因为 .child 在水平方向已脱离文档流（设置了 left 属性），故水平方向并不受父元素影响，效果如下所示：</p>
<img src="/web/css/css%20%E5%AE%9A%E4%BD%8D%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/absolute-2.png" class="">

<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p>固定定位，是绝对定位的特性形式。</p>
<p>坐标值的参考物为浏览器窗口。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css 图片样式</title>
    <url>/web/css/css%E5%9B%BE%E7%89%87%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="img元素"><a href="#img元素" class="headerlink" title="img元素"></a>img元素</h1><p>使用 img 元素时，可以使用边框（ border）、大小（width、height）、横向对齐（设置父元素的text-align）、纵向对齐（vertical-align）、文字环绕（float）等一些效果。 </p>
<p>当只设置图片的宽或高时，图片整体大小会等比例自动修改。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.imgItem</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="number">100px</span>; <span class="comment">/*只设置宽度时，高度会等比例自动调整*/</span></span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;imgItem&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>img 是行内元素（line），当和其他行内元素（如包含在 span 内的文字）在同一行时，有时需要调整 img 的位置，从而使得图片和文字的位置和谐一些，可以配置 img 为相对定位，然后再进行 img 位置的微调整。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.imgItem</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="number">1rem</span>; <span class="comment">/*只设置宽度时，高度会等比例自动调整*/</span></span></span><br><span class="line"><span class="css">                <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">                <span class="attribute">top</span>: <span class="number">2px</span>; <span class="comment">/*微调top值，使img到达理想位置*/</span></span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;imgItem&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span>我是文字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h1><p>background-size 设置背景图片大小。</p>
<p>1、值为 contain</p>
<p>​        缩放背景，将图片完全装入背景区（保持图片宽高比例），背景区有可能会出现空白。</p>
<p>2、值为 cover </p>
<p>​        缩放背景，使其完全覆盖背景区（保持图片的宽高比），当背景图和背景区大小不同时，背景图有些部分会被裁剪掉</p>
<p>3、值为宽度和高度</p>
<p>​        如果只设置一个值，则该值为宽度，高度值为 auto</p>
<p>​        如果设置两个值，则第一个为宽度，第二个为高度</p>
<p>当设定多个图片时，需要提供多个值，通过逗号分隔</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-size: 50% 25%, contain, 3em;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP2</title>
    <url>/web/http/HTTP2/</url>
    <content><![CDATA[<h1 id="HTTP-1-1-特点"><a href="#HTTP-1-1-特点" class="headerlink" title="HTTP/1.1 特点"></a>HTTP/1.1 特点</h1><ul>
<li>TCP 连接数限制<ul>
<li>浏览器和同一域的并行连接数有最大限制（不同浏览器限制不一样）</li>
</ul>
</li>
<li>Head-Of-Line Blocking（HOLB）<ul>
<li>同一个连接上的多个请求，前面的请求会阻塞后面的请求</li>
</ul>
</li>
<li>协议开销大<ul>
<li>Header 内容多</li>
</ul>
</li>
<li>明文传输，不安全</li>
</ul>
<h1 id="HTTP-2-特点"><a href="#HTTP-2-特点" class="headerlink" title="HTTP/2 特点"></a>HTTP/2 特点</h1><ul>
<li><p>二进制传输，解析更高效</p>
</li>
<li><p>HTTP/2 采用二进制格式传输数据，HTTP/1.x 使用文本格式</p>
</li>
<li><p>多路复用</p>
<ul>
<li>同域名下的所有通信在单个连接上完成</li>
<li>数据流以消息的形式发送，消息由一个或多个帧组成，帧之间可以乱序发送，帧首部的流标记用于支持帧重装</li>
</ul>
</li>
<li><p>Header 压缩</p>
<ul>
<li>HTTP/2 在客户端和服务器端使用 “首部表”跟踪和存储之前发送的头部键值对。</li>
<li>首部表在连接状态时始终存在，请求和响应只发送更新部分的头部，不发送以存在部分</li>
</ul>
</li>
<li><p>Server Push</p>
<ul>
<li>服务器可以将客户端需要的内容预先推送过去，也叫 “cache push”，</li>
<li>浏览器有权选择是否接受，如推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收</li>
</ul>
</li>
</ul>
<p>参考：</p>
<p><a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/">https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/</a></p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>HTTP2</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 安全头部</title>
    <url>/web/http/http%20%E5%AE%89%E5%85%A8%E5%A4%B4%E9%83%A8/</url>
    <content><![CDATA[<h1 id="1-HSTS"><a href="#1-HSTS" class="headerlink" title="1 HSTS"></a>1 HSTS</h1><h2 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h2><p><strong>HSTS</strong>（<strong>HTTP Strict Transport Secrity</strong>），服务器用此头部告知浏览器此网站只能使用 HTTPS 协议来访，浏览器应该自动把所有尝试使用 HTTP 的请求自动替换为 HTTPS 请求。</p>
<p>Chrome、Firefox等浏览器会产生一个307 Internal Redirect（内部跳转），自动跳转到HTTPS 请求。</p>
<img src="/web/http/http%20%E5%AE%89%E5%85%A8%E5%A4%B4%E9%83%A8/hsts.png" class="">

<h2 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=&lt;expire-time&gt;</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=&lt;expire-time&gt;; includeSubDomains</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=&lt;expire-time&gt;; preload</span><br></pre></td></tr></table></figure>

<ul>
<li><code>max-age=&lt;expire-time&gt;</code></li>
</ul>
<p>设置在浏览器收到这个请求后的<expire-time>秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。</p>
<ul>
<li><code>includeSubDomains</code> 可选</li>
</ul>
<p>如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。</p>
<ul>
<li><code>preload</code> 可选</li>
</ul>
<p>查看 <a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security#%E9%A2%84%E5%8A%A0%E8%BD%BD_HSTS">预加载 HSTS</a> 获得详情。不是标准的一部分</p>
<h2 id="1-3-注意"><a href="#1-3-注意" class="headerlink" title="1.3 注意"></a>1.3 注意</h2><p>当网站没有证书错误时，浏览器才认为网站支持 HTTPS，然后才会使用 <code>Strict-Transport-Security</code> 的值，否则不会将 HTTP 自动转为 HTTPS。</p>
<h1 id="2-CSP"><a href="#2-CSP" class="headerlink" title="2 CSP"></a>2 CSP</h1><h2 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h2><p><strong>CSP</strong>（<strong>Content-Security-Policy</strong>  内容安全策略），服务器用此头部来配置资源的可信来源白名单，从而减少和报告 XSS 攻击。当不包含 CSP 头部时，浏览器将使用同源策略。</p>
<h2 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>&lt;policy-directive&gt;; &lt;policy-directive&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>policy 参数由一系列描述策略指令的字符串组成。每个策略指令都描述了某个特定类型资源的生效范围。策略应该包含一个 default-src 策略指令，作为资源类型的默认策略。</p>
<p>除此之外, <meta>元素也可以被用来配置该策略, 例如：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h2><p>配置网站所有内容均来自自身（不包括子域名）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure>

<p>配置网站所有内容来自自身 或者 trusted.com及其子域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27; *.trusted.com</span><br></pre></td></tr></table></figure>

<p>配置网站内容中支持来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br></pre></td></tr></table></figure>

<h1 id="3-X-Content-Type-Options"><a href="#3-X-Content-Type-Options" class="headerlink" title="3 X-Content-Type-Options"></a>3 X-Content-Type-Options</h1><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><p>此头部可以用来限制客户端（如浏览器）按照 content-type 配置的 mime 类型对返回数据进行解析。禁止客户端的 MIME 类型嗅探（在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探，不同浏览器可能会执行不同的操作）。</p>
<h2 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">X-Content-Type-Options</span><span class="punctuation">: </span>nosniff</span><br></pre></td></tr></table></figure>

<ul>
<li><p>nosniff</p>
<p>下面两种情况的请求将被阻止：</p>
<ul>
<li>请求类型是”<code>style</code>“ 但是 MIME 类型不是 “<code>text/css</code>“，</li>
<li>请求类型是”<code>script</code>“ 但是 MIME 类型不是  <a href="https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type">JavaScript MIME 类型</a>。</li>
</ul>
</li>
</ul>
<h1 id="4-X-Frame-Options"><a href="#4-X-Frame-Options" class="headerlink" title="4 X-Frame-Options"></a>4 X-Frame-Options</h1><h2 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a>4.1 作用</h2><p>此头部用来限制客户端（如浏览器）是否可以在 frame iframe embed 或 object 中展示网页。</p>
<h2 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2 语法"></a>4.2 语法</h2><p>支持下面三种值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Frame-Options: deny</span><br><span class="line">X-Frame-Options: sameorigin</span><br><span class="line">X-Frame-Options: allow-from https://example.com/</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>deny</code></p>
<p>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p>
</li>
<li><p><code>sameorigin</code></p>
<p>表示该页面可以在相同域名页面的 frame 中展示。</p>
</li>
<li><p><code>allow-from *uri*</code></p>
<p>表示该页面可以在指定来源的 frame 中展示。</p>
</li>
</ul>
<h2 id="4-3-注意"><a href="#4-3-注意" class="headerlink" title="4.3 注意"></a>4.3 注意</h2><p>设置 meta 标签是无效的！例如 <code>&lt;meta http-equiv=&quot;X-Frame-Options&quot; content=&quot;deny&quot;&gt;</code> 没有任何效果。不要这样用！只有当像下面示例那样设置 HTTP 头 <code>X-Frame-Options</code> 才会生效。</p>
<h1 id="5-X-Xss-Protection"><a href="#5-X-Xss-Protection" class="headerlink" title="5 X-Xss-Protection"></a>5 X-Xss-Protection</h1><h2 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h2><p>此响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>)时，浏览器将停止加载页面。可以为尚不支持 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a> 的旧版浏览器的用户提供保护。</p>
<h2 id="5-2-语法"><a href="#5-2-语法" class="headerlink" title="5.2 语法"></a>5.2 语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 0</span><br><span class="line">X-XSS-Protection: 1</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">X-XSS-Protection: 1; report=&lt;reporting-uri&gt;</span><br></pre></td></tr></table></figure>

<p>0</p>
<p>禁止XSS过滤。</p>
<p>1</p>
<p>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</p>
<p>1;mode=block</p>
<p>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</p>
<p>1; report=<reporting-URI>  (Chromium only)</p>
<p>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri"><code>report-uri</code></a>指令的功能发送违规报告。</p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>css 居中</title>
    <url>/web/css/css%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>要实现一个页面效果其实可以用很多方法来实现，下面从使用场景的角度来列出常用方法。</p>
<h1 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1 水平居中"></a>1 水平居中</h1><h2 id="1-1-容器居中（margin）"><a href="#1-1-容器居中（margin）" class="headerlink" title="1.1 容器居中（margin）"></a>1.1 容器居中（margin）</h2><p>容器自身居中，给容器使用 <code>margin:0 auto</code> 就可以达到效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">                <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">4rem</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-容器内子元素-flex"><a href="#1-2-容器内子元素-flex" class="headerlink" title="1.2 容器内子元素(flex)"></a>1.2 容器内子元素(flex)</h2><p>给 flex 布局的成员设置 margin:auto  时 ，自动的外边距会占据全部的可用空间，从而达到居中的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.containerCenter</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: hotpink;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;containerCenter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="1-3-文本居中-text-align"><a href="#1-3-文本居中-text-align" class="headerlink" title="1.3 文本居中(text-align)"></a>1.3 文本居中(text-align)</h2><p>让文本居中，可以在块级容器上使用 <code>text-aligin:center</code>  来达到效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>给块状的父元素设置 text-align: center<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">                给块状的父元素设置 text-align: center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2 垂直居中"></a>2 垂直居中</h1><h2 id="2-1-遮罩（position）"><a href="#2-1-遮罩（position）" class="headerlink" title="2.1 遮罩（position）"></a>2.1 遮罩（position）</h2><p>这个方法可以适用于遮罩场景。使用 position，将其值配置为 fixed 、 relative 或 absolute  使得元素位置可移动。再通过 top left 等属性调整元素位置。下面例子中，当配置值为 relative 时，需要将html body 的高度都设置为 100% 才能达到让 .center 元素垂直居中的效果，所以下面使用 absolute 来举例。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">                <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">                <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">                <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - (<span class="number">200px</span> / <span class="number">2</span>));</span></span><br><span class="line"><span class="css">                <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - (<span class="number">200px</span> / <span class="number">2</span>));</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-文字居中（line-height）"><a href="#2-2-文字居中（line-height）" class="headerlink" title="2.2 文字居中（line-height）"></a>2.2 文字居中（line-height）</h2><p>当希望使文字在垂直方向居中时，可以将 line-height 和 height 设置成一样，来达到效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.textCenter</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center; <span class="comment">/*横向居中*/</span></span></span><br><span class="line"><span class="css">                <span class="attribute">line-height</span>: <span class="number">200px</span>; <span class="comment">/*将行高和height设置成一样值，使其垂直居中*/</span></span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: violet;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textCenter&quot;</span>&gt;</span>我是文字我想居中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-flex"><a href="#3-flex" class="headerlink" title="3 flex"></a>3 flex</h1><p>把 flex 单独提出来，是因为 flex 设置容器内元素的垂直和水平居中都非常方便，并且无论其子元素是块状还是行内元素。</p>
<p>主轴（默认为水平方向）居中使用<code>justify-content:center</code>。</p>
<p>副轴（默认为垂直方向）居中使用<code>align-items: center</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.containerCenter</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;containerCenter&quot;</span>&gt;</span></span><br><span class="line">    hello</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Blob</title>
    <url>/web/javascript/Blob%EF%BC%88Binary%20Large%20Object%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Blob（Binary Large Object）是对数据块的引用或句柄，通过 Blob 表示二进制数据、文本文件，进而可以对其进行一些操作。</p>
<h1 id="Blob-语法"><a href="#Blob-语法" class="headerlink" title="Blob 语法"></a>Blob 语法</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var aBlob = new Blob( array[, options ]);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>array</code> 是一个由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBufferView"><code>ArrayBufferView</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a> 等对象构成的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> ，或者其他类似对象的混合体，它将会被放进 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>。DOMStrings会被编码为UTF-8。</li>
<li><code>options</code> 它可能会指定如下两个属性：<ul>
<li><code>type</code>，默认值为 <code>&quot;&quot;</code>，表示 array 参数中数据的 MIME 类型。</li>
<li><code>endings</code>，用于指定包含行结束符<code>\n</code>的字符串如何被写入<ul>
<li><code>&quot;transparent&quot;</code>，默认值，表示保持 Blob 中的结束符</li>
<li> <code>&quot;native&quot;</code>，表示行结束符会被更改为适合宿主操作系统文件系统的换行符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  返回值</li>
<li>Blob 对象</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aFileParts = [<span class="string">&#x27;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&#x27;</span>]; <span class="comment">// 一个包含DOMString的数组</span></span><br><span class="line"><span class="keyword">var</span> oMyBlob = <span class="keyword">new</span> Blob(aFileParts, &#123;<span class="attr">type</span> : <span class="string">&#x27;text/html&#x27;</span>&#125;); <span class="comment">// 得到 blob</span></span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Blob-size"><a href="#Blob-size" class="headerlink" title="Blob.size"></a>Blob.size</h3><p>Blob.size 为只读，返回 <code>Blob</code> 对象中所包含数据的大小（字节）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fileInput是一个HTMLInputElement元素: &lt;input type=&quot;file&quot; multiple id=&quot;myfileinput&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myfileinput&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// files是一个FileList对象(类似于NodeList)</span></span><br><span class="line"><span class="keyword">var</span> files = fileInput.files;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    alert(files[i].name + <span class="string">&quot;文件的大小为 &quot;</span> + files[i].size + <span class="string">&quot; 字节&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Blob-type"><a href="#Blob-type" class="headerlink" title="Blob.type"></a>Blob.type</h3><p>Blob.type 为只读，返回一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fileInput是一个 HTMLInputElement，HTML Input 元素: &lt;input type=&quot;file&quot; multiple id=&quot;myfileinput&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myfileinput&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// files 是一个 FileList 对象（与 NodeList 相似，是多个 File 对象的集合）</span></span><br><span class="line"><span class="keyword">var</span> files = fileInput.files;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅允许 *.png, *.jpeg *.gif 类型的图片文件</span></span><br><span class="line"><span class="keyword">var</span> allowedFileTypes = [<span class="string">&quot;image/png&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, <span class="string">&quot;image/gif&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 检查文件的文件类型是否属于 allowFileTypes 中的一种</span></span><br><span class="line">    <span class="keyword">if</span> (allowedFileTypes.indexOf(files[i].type) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 对符合条件的文件进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Blob-slice"><a href="#Blob-slice" class="headerlink" title="Blob.slice"></a>Blob.slice</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Blob.slice([start[, end[, contentType]])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<ul>
<li><p><code>start</code> 可选，表示拷贝的起始位置下标，默认值为 0。</p>
<p>如果是负数，将会从数据的末尾从后到前开始计算。如 -10 表示  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a> 的倒数第十个字节。</p>
<p>如果值大于源 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a> 的长度，则返回一个长度为 0 并且不包含任何数据的一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a> 对象。</p>
</li>
<li><p><code>end</code> 可选，表示拷贝结束位置的下标，默认值为原始 Blob 的 size 属性值。</p>
<p>负数表示从数据的末尾从后到前开始计算。</p>
</li>
<li><p><code>contentType</code> 可选，新 Blob 的文档类型，默认值是一个空的字符串</p>
<p>此值会被设置为新 Blob 的 type 属性值。</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>返回一个新的 <code>Blob</code> 对象，包含了源 <code>Blob</code> 对象中指定范围内的数据。</li>
</ul>
</li>
</ul>
<h3 id="Blob-stream"><a href="#Blob-stream" class="headerlink" title="Blob.stream"></a>Blob.stream</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Blob.stream()</span><br></pre></td></tr></table></figure>

<p>返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 对象，能读取 Blob 内容。</p>
<h3 id="Blob-text"><a href="#Blob-text" class="headerlink" title="Blob.text"></a>Blob.text</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Blob.text()</span><br></pre></td></tr></table></figure>

<p>方法返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 对象，包含 Blob 中的内容，使用 UTF-8 格式编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textPromise = Blob.text();</span><br><span class="line"></span><br><span class="line">Blob.text().then(<span class="function"><span class="params">text</span> =&gt;</span> <span class="comment">/* 执行的操作…… */</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="keyword">await</span> blob.text();</span><br></pre></td></tr></table></figure>



<h3 id="Blob-arrayBuffer"><a href="#Blob-arrayBuffer" class="headerlink" title="Blob.arrayBuffer"></a>Blob.arrayBuffer</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Blob.arrayBuffer()</span><br></pre></td></tr></table></figure>

<p>方法返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 对象，包含 Blob 中的数据， <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBuffer"><code>ArrayBuffer</code></a> 使用二进制格式编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bufferPromise = blob.arrayBuffer();</span><br><span class="line"></span><br><span class="line">blob.arrayBuffer().then(<span class="function"><span class="params">buffer</span> =&gt;</span> <span class="comment">/* 处理 ArrayBuffer 数据的代码……*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">await</span> blob.arrayBuffer();</span><br></pre></td></tr></table></figure>

<h1 id="Blob-数据来源"><a href="#Blob-数据来源" class="headerlink" title="Blob 数据来源"></a>Blob 数据来源</h1><ul>
<li><p>由其他 Blob 复制而来</p>
</li>
<li><p>从客户端数据库读取</p>
</li>
<li><p>通过 HTTP 由 web下载</p>
</li>
<li><p>使用 Blob 构造函数，从字符串、ArrayBuffer对象、或其他 Blob 创建</p>
</li>
<li><p>File 对象，File 对象是 Blob 对象的子类</p>
<p>​    <strong>File对象来源</strong></p>
<ul>
<li><input type="file"></li>
<li>拖放 API</li>
<li>文件系统 API</li>
</ul>
</li>
</ul>
<p>​        </p>
<p>​    </p>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title>FormData</title>
    <url>/web/javascript/FormData/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>可以用来构造表单数据，然后作为 data 发送给服务器。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(form)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<ul>
<li><p>form（可选）</p>
<p>当指定 form 时，会使用 form 中的表单值（包括 form 中的文件内容）初始化 formData。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的 form 元素都需要有 name 属性，否则无法访问到值。</span></span><br><span class="line"><span class="keyword">var</span> myForm = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myForm&#x27;</span>);</span><br><span class="line">formData = <span class="keyword">new</span> FormData(myForm);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(); <span class="comment">// 当前为空</span></span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Chris&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FormData.append(name, value);</span><br><span class="line">FormData.append(name, value, filename);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>name：表单元素的 name 属性值</li>
<li>value：表单元素的 value 属性值，可以是 字符串 或 Blob 类型</li>
<li>filename（可选）：传递给服务器的文件名称。<ul>
<li>当第二个参数为 Blob 类型时，filename 默认值为 blob</li>
<li>当第二个参数为 File 对象时，filename 默认值为该文件名称</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>空</li>
</ul>
</li>
<li>功能<ul>
<li>添加新值到 <code>FormData</code> 对象集合的后面，即使新值 key 已存在。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Chris&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;userpic&#x27;</span>, myFileInput.files[<span class="number">0</span>], <span class="string">&#x27;chris.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FormData.delete(name);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>name：要删除的键（Key）。</li>
</ul>
</li>
<li>返回值<ul>
<li>空</li>
</ul>
</li>
<li>功能<ul>
<li>从 FormData 中删除指定键和对应的值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.delete(<span class="string">&#x27;username&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FormData.entries();</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值<ul>
<li> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols"><code>iterator</code></a> 对象</li>
</ul>
</li>
<li>功能<ul>
<li>返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols"><code>iterator</code></a> 对象 ，此对象可以遍历访问 FormData中 的键值对</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> pair <span class="keyword">of</span> formData.entries()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(pair[<span class="number">0</span>]+ <span class="string">&#x27;, &#x27;</span>+ pair[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FormData.get(name);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>name：将要获取值的键名。</li>
</ul>
</li>
<li><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2></li>
<li>功能<ul>
<li>返回 FormData 对象中和指定的键关联的第一个值。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Chris&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line">formData.get(<span class="string">&#x27;username&#x27;</span>); <span class="comment">// Returns &quot;Chris&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="getAll"><a href="#getAll" class="headerlink" title="getAll"></a>getAll</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FormData.getAll(name);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>要获取值的 key</li>
</ul>
</li>
<li>返回值<ul>
<li>包含由 key 所对应值组成的数组</li>
</ul>
</li>
<li>功能<ul>
<li>返回该 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a> 对象指定 key 的所有值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Chris&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line">formData.getAll(<span class="string">&#x27;username&#x27;</span>); <span class="comment">// Returns [&quot;Chris&quot;, &quot;Bob&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FormData.has(name);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>name：要查询的 key</li>
</ul>
</li>
<li>返回值<ul>
<li>查询结果</li>
</ul>
</li>
<li>功能<ul>
<li>查询 FormData 对象是否存在某个key</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.has(<span class="string">&#x27;username&#x27;</span>); <span class="comment">// Returns false</span></span><br></pre></td></tr></table></figure>

<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FormData.keys();</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值<ul>
<li> formData  包含的所有 key 的迭代器</li>
</ul>
</li>
<li>功能<ul>
<li>返回一个迭代器（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols"><code>iterator</code></a>），用来遍历了该 formData  包含的所有key</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.append(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出所有的 key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> formData.keys()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(key); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//key1</span></span><br><span class="line"><span class="comment">//key2</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FormData.set(name, value);</span><br><span class="line">FormData.set(name, value, filename);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<ul>
<li>同 FormData.append</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>对 FormData 对象里的某个 key 设置一个新的值，如果该 key 不存在，则添加。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.set(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;Chris&#x27;</span>);</span><br><span class="line">formData.set(<span class="string">&#x27;userpic&#x27;</span>, myFileInput.files[<span class="number">0</span>], <span class="string">&#x27;chris.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FormData.values();</span><br></pre></td></tr></table></figure>

<ul>
<li>功能<ul>
<li>返回一个允许遍历该对象中所有值的迭代器</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formData.append(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> formData.values()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//value1</span></span><br><span class="line"><span class="comment">//value2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>FormData</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 事件循环</title>
    <url>/web/javascript/JS%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>此篇文章写的浏览器端的事件循环（ EventLoop），Node 端会有所不同。</p>
<h1 id="1-事件循环（EventLoop）"><a href="#1-事件循环（EventLoop）" class="headerlink" title="1 事件循环（EventLoop）"></a>1 事件循环（EventLoop）</h1><p><strong>事件循环</strong>是 JS 主线程处理任务的过程，包含如下元素：</p>
<ul>
<li>堆</li>
<li>调用栈（也叫执行栈）<ul>
<li>由一系列函数调用组成的栈</li>
</ul>
</li>
<li>消息队列（也叫任务队列、宏任务队列、callback queue）<ul>
<li>由待处理的宏任务组成的队列，如 被触发的 click 事件、到达定时时间的任务、已完成的网络请求 等</li>
</ul>
</li>
<li>微队列<ul>
<li>由待处理的微任务组成，如 Promise 的回调，MutationObserver  回调等</li>
</ul>
</li>
</ul>
<h2 id="1-1-事件循环视图"><a href="#1-1-事件循环视图" class="headerlink" title="1.1 事件循环视图"></a>1.1 事件循环视图</h2><img src="/web/javascript/JS%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/eventLoop.PNG" class="">

<p>上图展示了事件循环的过程：</p>
<ol>
<li>当前正在执行的函数被压入执行栈（stack）中<ol>
<li>函数执行过程中调用 Promise、MutationObserver 等 WebAPI 产生的异步任务需要执行时，会被插入<strong>微任务队列（microtask queue）</strong> 中。</li>
<li>函数执行过程中调用 Ajax、setTimeout 等 WebAPI 产生的异步任务需要执行时，会被插入<strong>宏任务队列（task queue）</strong>  中。</li>
</ol>
</li>
<li>执行栈中的所有函数执行完成后（即栈空后），JS 主线程会首先从 microtask queue 中取出一个微任务进行执行，执行微任务就是把微任务对应的回调函数压入执行栈中进行执行，即回到步骤 1 。微任务队列为空时才会执行第 3 步。</li>
<li>微任务队列为空时，JS 主线程再从 task queue 中取出一个宏任务进行执行，执行宏任务也是将宏任务对应的回调函数压入执行栈中进行执行，即回到了步骤 1。</li>
</ol>
<h1 id="2-堆"><a href="#2-堆" class="headerlink" title="2 堆"></a>2 堆</h1><p>对象会被分配到<code>堆</code>内存中。</p>
<h1 id="3-调用栈（执行栈）"><a href="#3-调用栈（执行栈）" class="headerlink" title="3 调用栈（执行栈）"></a>3 调用栈（执行栈）</h1><p>函数被执行时，会产生对应的执行上下文（Execute Context，<strong>EC</strong>，也叫执行环境），<strong>EC</strong> 会被压入<code>调用栈</code> 执行。</p>
<p>当有多个函数被嵌套调用时，会有多个 <strong>EC</strong> 被压入<code>调用栈</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> foo(x * y) + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar(<span class="number">7</span>)); <span class="comment">// 返回 42</span></span><br></pre></td></tr></table></figure>

<p>上面代码执行过程：</p>
<ol>
<li>主代码的 <strong>EC</strong> 被压入栈中执行。</li>
<li>当调用 bar 函数时，bar 的 <strong>EC</strong> 被压入栈中执行。</li>
<li>当 bar 调用 foo 时，foo 的 <strong>EC</strong> 被压入栈中执行。</li>
<li>当 foo 执行完成时，foo  的 <strong>EC</strong> 被弹出栈。</li>
<li>当 bar 执行完成时，bar 的 <strong>EC</strong> 也被弹出栈。</li>
<li>主代码块执行完成，其 <strong>EC</strong> 也被弹出栈，此时栈被清空了。</li>
</ol>
<h1 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h1><p>消息队列（也叫<strong>任务队列</strong>、<strong>宏任务队列</strong>、<strong>callback queue</strong>、<strong>task queue</strong>）由待处理的消息组成，事件循环会依次处理消息队列中的消息。</p>
<p>消息被处理时会被移出消息队列，并作为输入参数来调用与之关联的回调，回调被执行会被压入调用栈中执行。</p>
<h2 id="4-1-宏任务"><a href="#4-1-宏任务" class="headerlink" title="4.1 宏任务"></a>4.1 宏任务</h2><p>宏任务（MacroTask，也叫 Task），由下面类型的代码形成，并被加入到宏任务队列：</p>
<ul>
<li><p>被触发的事件回调，如 onClick、onLoad</p>
</li>
<li><p>setTimeout / setInterval </p>
</li>
</ul>
<h1 id="5-微任务队列"><a href="#5-微任务队列" class="headerlink" title="5 微任务队列"></a>5 微任务队列</h1><p>微任务队列由微任务组成，事件循环会依次处理微任务队列中的微任务。</p>
<h2 id="5-1-微任务"><a href="#5-1-微任务" class="headerlink" title="5.1 微任务"></a>5.1 微任务</h2><p>微任务（MicroTask，也叫 Jobs），下面类型的代码属于微任务，并被加入微任务队列：</p>
<ul>
<li><p>Promise</p>
</li>
<li><p>MutationObserver</p>
<ul>
<li><p>监控 DOM 树的更改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择需要观察变动的节点</span></span><br><span class="line"><span class="keyword">const</span> targetNode = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;some-id&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察器的配置（需要观察什么变动）</span></span><br><span class="line"><span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当观察到变动时执行的回调函数</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList, observer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Use traditional &#x27;for loops&#x27; for IE 11</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mutation.type === <span class="string">&#x27;childList&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;A child node has been added or removed.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mutation.type === <span class="string">&#x27;attributes&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;The &#x27;</span> + mutation.attributeName + <span class="string">&#x27; attribute was modified.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个观察器实例并传入回调函数</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上述配置开始观察目标节点</span></span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后，可停止观察</span></span><br><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>queueMicrotask</p>
<ul>
<li>```js<br>queueMicrotask(() =&gt; {<br>  /* 微任务中将运行的代码 */<br>});<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 使用场景</span><br><span class="line">  </span><br><span class="line">    - 代码执行结果的一致性</span><br><span class="line">  </span><br><span class="line">    - 串行执行任务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 6 执行顺序</span><br><span class="line"></span><br><span class="line">JS 主线程执行顺序：</span><br><span class="line"></span><br><span class="line">1. 当前执行栈中的代码 </span><br><span class="line">2. 当前执行栈所产生的 microtask（直到微任务队列中任务全部执行完成，即为空时才进行下一步）</span><br><span class="line">3. 渲染绘制 </span><br><span class="line">4. 下个 task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">        console.log(5)</span><br><span class="line">    	setTimeout(function()&#123;</span><br><span class="line">            console.log(9);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        Promise.resolve().then(function() &#123;</span><br><span class="line">            console.log(6);</span><br><span class="line">        &#125;) </span><br><span class="line">&#125;, 0);</span><br><span class="line">    </span><br><span class="line">new Promise(function executor(resolve) &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">   </span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">            console.log(7);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">     Promise.resolve().then(function() &#123;</span><br><span class="line">         console.log(3);</span><br><span class="line"></span><br><span class="line">          Promise.resolve().then(function() &#123;</span><br><span class="line">         console.log(4);</span><br><span class="line"></span><br><span class="line">          setTimeout(function()&#123;</span><br><span class="line">            console.log(8);</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">//输出顺序为：</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4</span><br><span class="line">undefined</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>参考资料：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html">https://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS 事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>URL 对象</title>
    <url>/web/javascript/URL%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>使用 URL 对象可以解析 url 路径，指定 File 或 Blob 对象。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> urlObj = <span class="keyword">new</span> URL(url [, base])</span><br></pre></td></tr></table></figure>

<p>参数</p>
<ul>
<li><p><code>url</code>：表示绝对或相对 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>。</p>
<p>​    如果 <code>url</code> 是相对 URL，则会将 <code>base</code> 用作基准 URL。</p>
<p>​    如果  <code>url</code> 是绝对URL，则参数 <code>base</code> 将被忽略。</p>
</li>
<li><p><code>base</code> ：可选，表示基准 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>，默认值为 <code>&#39;&#39;</code>。</p>
<p>​    当 <em>url</em> 是相对 URL 时，base 才会生效。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="string">&#x27;https://developer.mozilla.org&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> URL(<span class="string">&quot;/&quot;</span>, m);                                </span><br><span class="line"><span class="comment">// =&gt; &#x27;https://developer.mozilla.org/&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> URL(m);                                    </span><br><span class="line"><span class="comment">// =&gt; &#x27;https://developer.mozilla.org/&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/hash"><code>hash</code></a></p>
<p>返回从<code>&#39;#&#39;</code>开始的字符串的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/href#Examples&#x27;</span>);</span><br><span class="line"></span><br><span class="line">url.hash <span class="comment">// Returns &#x27;#Examples&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/host"><code>host</code></a></p>
<p>返回域（即主机名）和 端口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/host&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = url.host <span class="comment">// &quot;developer.mozilla.org&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org:443/en-US/docs/Web/API/URL/host&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = url.host <span class="comment">// &quot;developer.mozilla.org&quot;</span></span><br><span class="line"><span class="comment">// The port number is not included because 443 is the scheme&#x27;s default port</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org:4097/en-US/docs/Web/API/URL/host&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = url.host <span class="comment">// &quot;developer.mozilla.org:4097&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/hostname"><code>hostname</code></a></p>
<p>返回 URL 域名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/hostname&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = url.hostname; <span class="comment">// Returns:&#x27;developer.mozilla.org&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/href"><code>href</code></a></p>
<p>返回完整的 url。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/href&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = url.href; <span class="comment">// Returns: &#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/href&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/origin"><code>origin</code></a> 只读</p>
<p>返回协议名、域名和端口号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> URL(<span class="string">&quot;blob:https://mozilla.org:443/&quot;</span>).origin;</span><br><span class="line"><span class="comment">// 返回:&#x27;https://developer.mozilla.org:443&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/password"><code>password</code></a></p>
<p>返回域名前面指定的密码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://anonymous:flabada@developer.mozilla.org/en-US/docs/Web/API/URL/password&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = url.password; <span class="comment">// Returns:&quot;flabada&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/pathname"><code>pathname</code></a></p>
<p>以 ‘/‘ 起头紧跟着 URL 文件路径的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = url.pathname; <span class="comment">// Returns:&quot;/en-US/docs/Web/API/URL/pathname&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/port"><code>port</code></a></p>
<p>返回 URL 端口号。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/protocol"><code>protocol</code></a></p>
<p>返回 URL 协议名，末尾带 <code>&#39;:&#39;。</code></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/search"><code>search</code></a></p>
<p>返回以“？”开头字符的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&#x27;https://developer.mozilla.org/en-US/docs/Web/API/URL/search?q=123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queryString = url.search; <span class="comment">// Returns:&quot;?q=123&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/searchParams"><code>searchParams</code></a> 只读</p>
<p>返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a>对象，可用于访问<code>search</code>中找到的各个查询参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://some.site/?id=123</span></span><br><span class="line"><span class="keyword">const</span> parsedUrl = <span class="keyword">new</span> URL(<span class="built_in">window</span>.location.href);</span><br><span class="line"><span class="built_in">console</span>.log(parsedUrl.searchParams.get(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/username"><code>username</code></a></p>
<p>包含在域名前面指定的用户名。</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/toString"><code>toString()</code></a></p>
<p>返回包含整个 URL 的字符串。 是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/href"><code>URL.href</code></a>的同义词，不能用于修改值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> URL(<span class="string">&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL/toString&quot;</span>);</span><br><span class="line"></span><br><span class="line">url.toString() </span><br><span class="line"><span class="comment">// 返回：&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL/toString&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/toJSON"><code>toJSON()</code></a></p>
<p>返回包含整个 URL 的字符串（与<code>href</code>属性相同）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> URL(<span class="string">&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL/toString&quot;</span>);</span><br><span class="line"></span><br><span class="line">url.toJSON();</span><br><span class="line"><span class="comment">//返回:&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL/toString&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL"><code>createObjectURL()</code></a></p>
<p>返回 URL 实例，这个新的 URL 对象表示指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"></span><br><span class="line"> img.src = <span class="built_in">window</span>.URL.createObjectURL(files[i]);</span><br><span class="line"> img.height = <span class="number">60</span>;</span><br><span class="line"> img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> 	<span class="built_in">window</span>.URL.revokeObjectURL(<span class="built_in">this</span>.src);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是预览上传的视频的方法</span></span><br><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj_url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">video.src = obj_url;</span><br><span class="line">video.play()</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(obj_url);</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL"><code>revokeObjectURL()</code></a></p>
<p>销毁之前使用 <code>URL.createObjectURL()</code>方法创建的 URL 实例。</p>
<p>在每次调用 URL.createObjectURL() 时，都会创建新的 URL 对象。所以当不再需要这些 URL 对象时，每个对象必须通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL"><code>URL.revokeObjectURL()</code></a> 方法来释放。</p>
</li>
</ul>
<p>参考资料：</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL">https://developer.mozilla.org/en-US/docs/Web/API/URL</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title>js 实现链式调用</title>
    <url>/web/javascript/js%20%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-什么是链式调用"><a href="#1-什么是链式调用" class="headerlink" title="1 什么是链式调用"></a>1 什么是链式调用</h1><p>下面的示例即链式调用，像链表一样依次调用对象的多个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).addClass(&#x27;hello&#x27;).removeClass(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="2-链式调用的实现"><a href="#2-链式调用的实现" class="headerlink" title="2 链式调用的实现"></a>2 链式调用的实现</h1><h2 id="2-1-在对象方法的最后返回对象本身"><a href="#2-1-在对象方法的最后返回对象本身" class="headerlink" title="2.1 在对象方法的最后返回对象本身"></a>2.1 在对象方法的最后返回对象本身</h2><p>在方法的最后返回对象本身，即可实现链式调用，如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">b</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a().b();</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>链式调用</tag>
      </tags>
  </entry>
  <entry>
    <title>js 的垃圾回收机制</title>
    <url>/web/javascript/js%20%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>js 的垃圾回收器用来跟踪内存的分配和使用，会定时把分配后不再使用的内存释放掉。</p>
<p>js 垃圾回收器判断内存是否不再使用时，使用了 <code>引用计数</code> 和 <code>标记-清除</code> 两种机制。自 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</p>
<ul>
<li><p>引用计数</p>
<ul>
<li><p>当对象没有被其他对象使用时，将会被回收机制回收。</p>
</li>
<li><p>缺点：无法处理循环引用的场景，进而造成内存泄露。</p>
<ul>
<li><pre><code class="js">function f()&#123;
  var o = &#123;&#125;;
  var o2 = &#123;&#125;;
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return &quot;azerty&quot;;
&#125;

f();
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>标记-清除</p>
<ul>
<li>当对象从根对象（全局对象）出发再无法获取到时，将会被回收机制回收。</li>
<li>缺点：无法从根对象查询到的对象将无法被清除。但是实际开发中很少遇到此种情况。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 js 获取 html 根元素</title>
    <url>/web/javascript/js%20%E8%8E%B7%E5%8F%96%20html%20%E6%A0%B9%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="使用-js-获取-html-根元素"><a href="#使用-js-获取-html-根元素" class="headerlink" title="使用 js 获取 html 根元素"></a>使用 js 获取 html 根元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement  <span class="comment">//html 根元素</span></span><br></pre></td></tr></table></figure>

<h1 id="设置-html-根元素样式"><a href="#设置-html-根元素样式" class="headerlink" title="设置 html 根元素样式"></a>设置 html 根元素样式</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;200px&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>html 根元素</tag>
      </tags>
  </entry>
  <entry>
    <title>js 变量提升</title>
    <url>/web/javascript/js%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h1 id="变量提升是什么"><a href="#变量提升是什么" class="headerlink" title="变量提升是什么"></a>变量提升是什么</h1><p>js 中的变量提升，其实是对变量的声明进行提升，也就是将变量的声明（不包括赋值）提升到其所在作用域的顶部。</p>
<h1 id="全局作用域的变量提升"><a href="#全局作用域的变量提升" class="headerlink" title="全局作用域的变量提升"></a><strong>全局作用域的变量提升</strong></h1><ul>
<li>使用 var 修饰的全局变量会被变量提升</li>
<li>没有使用 var 修饰的全局变量不会被提升，变量必须在声明后才能使用，否则会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 var 修饰的全局变量会被变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(gN1);</span><br><span class="line">&#125;</span><br><span class="line">F1();<span class="comment">//undefined，变量声明被提升，赋值没被提升，故输出为undefined</span></span><br><span class="line"><span class="keyword">var</span> gN1 = <span class="number">1</span>;</span><br><span class="line">F1();<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有使用var修饰的全局变量不会被提升，变量必须在声明后才能使用，否则会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(gN1);</span><br><span class="line">&#125;</span><br><span class="line">F1();<span class="comment">//error： gN1 is not defined</span></span><br><span class="line"> gN1 = <span class="number">1</span>;</span><br><span class="line">F1();<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h1 id="局部作用域的变量提升"><a href="#局部作用域的变量提升" class="headerlink" title="局部作用域的变量提升"></a><strong>局部作用域的变量提升</strong></h1><ul>
<li>局部作用域的变量声明会被提升到作用域顶部</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部作用域的变量声明会被提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n1);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> n1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">F2();</span><br></pre></td></tr></table></figure>

<h1 id="块级作用域的变量提升"><a href="#块级作用域的变量提升" class="headerlink" title="块级作用域的变量提升"></a><strong>块级作用域的变量提升</strong></h1><ul>
<li>块级作用域不会进行变量提升，变量的使用必须在声明之后，否则会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//块级作用域不会进行变量提示，变量的使用必须在声明之后，否则会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n3);<span class="comment">//error： n3 is not defined</span></span><br><span class="line">    <span class="keyword">let</span> n3 = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">F3();</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>1、局部变量、使用 var 声明的全局变量 会被提升</p>
<p>2、块级变量、没有使用 var 声明的全局变量 不会被提升</p>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 this</title>
    <url>/web/javascript/this/</url>
    <content><![CDATA[<p>多数情况下函数的调用方式决定了 this 的值（运行时绑定）。</p>
<p>ES5 使用 bind 方法设置 this 值，使得不用考虑函数如何被调用。</p>
<h1 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h1><p>在全局执行上下文下，无论是否是严格模式，this 都指向全局对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中, window 对象同时也是全局对象：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.b = <span class="string">&quot;MDN&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// &quot;MDN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  </span><br></pre></td></tr></table></figure>



<h1 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h1><h2 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>在函数内部，this 的值取决于函数被调用的方式。</p>
<ul>
<li><p>调用时不设置 this </p>
<ul>
<li><p>非严格模式： window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( f1() );<span class="comment">// window 对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>严格模式： undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">      &quot;use strict&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log( f2() );<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="作为方法调用"><a href="#作为方法调用" class="headerlink" title="作为方法调用"></a>作为方法调用</h2><h3 id="类上下文"><a href="#类上下文" class="headerlink" title="类上下文"></a>类上下文</h3><ul>
<li>类函数中的 this 表示类</li>
<li>实例函数中的 this 表示类的原型</li>
<li>派生类调用 super() 后才有 this，相当于 this = new Base()，Base 为基类</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数中的 this 为构造函数的返回值，默认返回值为创建的实例对象，但返回值可以被修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// logs 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">38</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// logs 38</span></span><br></pre></td></tr></table></figure>



<h3 id="类中的-this"><a href="#类中的-this" class="headerlink" title="类中的 this"></a>类中的 this</h3><p>可以通过 bind 将 this 指向实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Bind sayBye but not sayHi to show the difference</span></span><br><span class="line">    <span class="built_in">this</span>.sayBye = <span class="built_in">this</span>.sayBye.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello from <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Bye from <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Car&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Bird&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarChild</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;CarChild&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">let</span> bird1 = <span class="keyword">new</span> Bird();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 的值依赖于调用者</span></span><br><span class="line">car1.sayHi(); <span class="comment">// Hello from Car</span></span><br><span class="line"></span><br><span class="line">bird1.sayHi = car1.sayHi;</span><br><span class="line">bird1.sayHi(); <span class="comment">// Hello from Bird</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bird1.sayBye = car1.sayBye;<span class="comment">//绑定了 this 的方法, 函数借用中的 &#x27;this&#x27; 不依赖与调用者</span></span><br><span class="line">bird1.sayBye();  <span class="comment">// Bye from Car</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> CarChild();</span><br><span class="line">test1.sayHi();<span class="comment">// Hello from CarChild</span></span><br><span class="line">test1.sayBye();<span class="comment">// Bye from CarChild</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 this</h3><p>当被当做方法调用时，this 被设置为调用该函数的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>



<h3 id="绑定函数上下文"><a href="#绑定函数上下文" class="headerlink" title="绑定函数上下文"></a>绑定函数上下文</h3><ul>
<li><p>call</p>
</li>
<li><p>apply</p>
</li>
<li><p>bind</p>
<ul>
<li><p>使用 bind 创建的新函数，新函数中的 this 永久绑定到第一个参数，无论新函数什么时候被调用，this 都是使用 bind 时的第一个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建的函数 g 中, this 值将永久被绑定到第一个参数 &#123;a:&quot;azerty&quot;&#125;</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">&quot;azerty&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>:<span class="string">&#x27;yoo&#x27;</span>&#125;); <span class="comment">// bind 只生效一次！</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g, <span class="attr">h</span>:h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a, o.f(), o.g(), o.h()); <span class="comment">// 37, 37, azerty, azerty</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="DOM-事件处理函数"><a href="#DOM-事件处理函数" class="headerlink" title="DOM 事件处理函数"></a>DOM 事件处理函数</h3><p>使用 <code>addEventListener</code> 添加的事件处理函数， this 指向触发事件的元素，即 currentTarget。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被调用时，将关联的元素变成蓝色</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.currentTarget); <span class="comment">// 总是 true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 currentTarget 和 target 是同一个对象时为 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.target);        </span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;#A5D9F3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档中的所有元素的列表</span></span><br><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">  elements[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, bluify, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内联事件处理函数"><a href="#内联事件处理函数" class="headerlink" title="内联事件处理函数"></a>内联事件处理函数</h3><p>当代码被内联 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Event_handlers">on-event 处理函数</a> 调用时，它的<code>this</code>指向监听器所在的DOM元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;alert(this.tagName.toLowerCase());&quot;</span>&gt;</span><br><span class="line">  Show <span class="built_in">this</span><span class="comment">// button</span></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>下面示例没有设置内部函数的 <code>this</code>，所以它指向 global/window 对象（因为非严格模式下调用的函数未设置 <code>this</code> 时指向的默认对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;alert((function()&#123;return this&#125;)());&quot;</span>&gt;</span><br><span class="line">  Show inner <span class="built_in">this</span><span class="comment">// window</span></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数中的 this 表示创建时的作用域，而不是运行时的。通过 call apply bind 给箭头函数绑定 this 时，this 会被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalObject = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">var</span> foo = (<span class="function">() =&gt;</span> <span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo() === globalObject); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用call来设定this</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.call(obj) === globalObject); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用bind来设定this</span></span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>webworker</title>
    <url>/web/javascript/webworker/</url>
    <content><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h1><p>对于需要长时间计算的 JS 脚本，可以使用 web worker 重新起个线程，进而提升用户体验。</p>
<h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h1><h2 id="2-1-上下文"><a href="#2-1-上下文" class="headerlink" title="2.1 上下文"></a>2.1 上下文</h2><p>worker 运行在另一个全局上下文中，不同于当前的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>window</code></a>。</p>
<h2 id="2-2-与-Worker-通信"><a href="#2-2-与-Worker-通信" class="headerlink" title="2.2 与 Worker 通信"></a>2.2 与 Worker 通信</h2><p>Worker 线程和主线程间通过消息机制进行。</p>
<h3 id="2-2-1-发送消息"><a href="#2-2-1-发送消息" class="headerlink" title="2.2.1 发送消息"></a>2.2.1 发送消息</h3><p>postMessage(arg)</p>
<h3 id="2-2-2-接收消息"><a href="#2-2-2-接收消息" class="headerlink" title="2.2.2 接收消息"></a>2.2.2 接收消息</h3><p>onmessage(e)</p>
<p>onmessageerror(e)</p>
<h2 id="2-3-运行环境"><a href="#2-3-运行环境" class="headerlink" title="2.3 运行环境"></a>2.3 运行环境</h2><h3 id="2-3-1属性"><a href="#2-3-1属性" class="headerlink" title="2.3.1属性"></a>2.3.1属性</h3><ul>
<li>navigator 对象</li>
<li>appName</li>
<li>appVersion</li>
<li>userAgent</li>
<li>platform</li>
<li>location 对象<ul>
<li>与 window.location 相同，但为只读属性</li>
</ul>
</li>
<li>self 对象<ul>
<li>指向全局 worker 对象</li>
</ul>
</li>
<li>所有的 ECMAScript 对象<ul>
<li>Object Array Date 等</li>
</ul>
</li>
<li>XMLHttpRequest 构造器</li>
</ul>
<h3 id="2-3-2方法"><a href="#2-3-2方法" class="headerlink" title="2.3.2方法"></a>2.3.2方法</h3><p>importScripts()</p>
<ul>
<li>加载 worker 需要使用的 JS 文件</li>
</ul>
<p>close()</p>
<ul>
<li>停止 worker 运行</li>
</ul>
<p>setTimeout</p>
<p>setInternal</p>
<h2 id="2-4-示例"><a href="#2-4-示例" class="headerlink" title="2.4 示例"></a>2.4 示例</h2><p><a href="https://github.com/mdn/simple-web-worker/blob/gh-pages/main.js">https://github.com/mdn/simple-web-worker/blob/gh-pages/main.js</a></p>
<p><a href="https://github.com/mdn/simple-shared-worker">https://github.com/mdn/simple-shared-worker</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.Worker) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3 注意"></a>3 注意</h1><ul>
<li>worker 内部不能直接操作 DOM 节点</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>worker</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域 作用域链</title>
    <url>/web/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<h1 id="1-作用域（Scope）"><a href="#1-作用域（Scope）" class="headerlink" title="1 作用域（Scope）"></a>1 作用域（Scope）</h1><h2 id="1-1-作用域的定义"><a href="#1-1-作用域的定义" class="headerlink" title="1.1 作用域的定义"></a>1.1 作用域的定义</h2><p><strong><code>作用域</code><strong>指的是变量可被访问的有效</strong>范围</strong>。</p>
<h2 id="1-2-作用域的分类"><a href="#1-2-作用域的分类" class="headerlink" title="1.2 作用域的分类"></a>1.2 作用域的分类</h2><p>对于 js 来说，作用域有下面三类：</p>
<ul>
<li><p>全局作用域 </p>
<p>​    变量在全局范围有效。</p>
</li>
<li><p>局部作用域（又叫函数作用域）</p>
<p>​    变量在声明它的函数体中，及在这个函数体嵌套的任意函数体内有效。</p>
</li>
<li><p>块作用域（es6 新增的语法）</p>
<p>​    变量在语句块内有效。</p>
</li>
</ul>
<h1 id="2-变量对象-Variable-Object"><a href="#2-变量对象-Variable-Object" class="headerlink" title="2 变量对象 ( Variable Object )"></a>2 变量对象 ( Variable Object )</h1><p>**<code>变量对象</code><strong>，顾名思义就是保存变量的对象，只要是保存变量的对象，都可以称为</strong><code>变量对象</code><strong>。winows 对象、活动对象、闭包等都是保存变量的对象，都属于</strong><code>变量对象</code>**。</p>
<h1 id="3-活动对象（Activation-Object）"><a href="#3-活动对象（Activation-Object）" class="headerlink" title="3 活动对象（Activation Object）"></a>3 活动对象（Activation Object）</h1><p>活动对象是在函数执行时产生的变量对象，活动对象保存了函数的局部变量、window对象。</p>
<h1 id="4-作用域链-scopes"><a href="#4-作用域链-scopes" class="headerlink" title="4 作用域链 [[scopes]]"></a>4 作用域链 [[scopes]]</h1><p><strong><code>作用域链</code><strong>是函数的一个内部属性 [[scopes]]，是由函数可访问的所有</strong><code>外部作用域对象</code><strong>组成的</strong>数组</strong>。[[scopes]] 属性不能通过程序读取，只能由 js 引擎读取。js 通过**<code>作用域链</code>**实现了静态作用域（指作用域由定义时而非运行时决定）。</p>
<p>**<code>作用域链</code>**将可以将不同函数关联起来，并保证了函数解析变量的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">aArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aVar = <span class="string">&#x27;aVar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(A) ;<span class="comment">//函数被创建时，会包含一个[[scope]]内部属性，用来保存作用域链</span></span><br></pre></td></tr></table></figure>

<p>上面代码 chrome 输出截图：</p>
<img src="/web/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/2.png" class="">

<p>firefox 输出截图：</p>
<img src="/web/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/3.png" class="">

<p>firefox 并没有输出 [[scopes]] 属性，chrome 虽然输出了，但却无法访问 [[scopes]] 属性。</p>
<h1 id="5-执行上下文（或叫执行环境）"><a href="#5-执行上下文（或叫执行环境）" class="headerlink" title="5 执行上下文（或叫执行环境）"></a>5 执行上下文（或叫执行环境）</h1><p><strong>执行上下文</strong>是函数执行时创建的一个内部对象，定义了函数执行时的环境。</p>
<p>函数每次执行时，都会创建对应的<strong>执行上下文</strong>，多次调用函数，将会创建多个<strong>执行上下文</strong>。当函数执行完毕，<strong>执行上下文</strong>将被销毁。</p>
<p><strong>执行上下文</strong>是使用函数自身的作用域 [[scopes]] 属性来进行初始化的，并将活动对象（由函数的局部变量组成）追加为其第一个元素。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B1Alias;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aVar = <span class="string">&#x27;aVar&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bVar=<span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(bVar);</span><br><span class="line">        <span class="built_in">console</span>.log(aVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    B1Alias = B1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br><span class="line">B1Alias();</span><br><span class="line"><span class="built_in">console</span>.dir(B1Alias);</span><br></pre></td></tr></table></figure>

<img src="/web/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/scopeSum.png" class="">

<p>通过上面的示例和调试截图来总结下，将各个概念关联起来：</p>
<p>每个函数被初始化时，会包含一个数组类型的属性  [[Scopes]] （即作用域链），[[Scopes]] 的内容是由此函数可以访问的<strong>外部作用域对象</strong>组成的。</p>
<p>每次函数执行时，都会创建对应的执行上下文，会使用函数的 [[Scopes]] 来初始化执行上下文，并将<strong>活动对象</strong>（由函数的局部变量组成）追加到<strong>执行上下文</strong>的第一个元素。</p>
<p><strong>作用域</strong>是一个范围，当把这个范围关联到某个对象时，可以把这个对象叫做<strong>作用域对象</strong>，如 windows 对象、活动对象、执行上下文 都可以称为<strong>作用域对象</strong>。</p>
<p>保存变量的对象称为<strong>变量对象</strong>，也就是说变量对象包括了<strong>作用域对象</strong>，但并不止作用域对象。</p>
<p>参考：</p>
<p><a href="https://juejin.im/post/5b481cc9e51d45192562850f">https://juejin.im/post/5b481cc9e51d45192562850f</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>作用域链</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/web/javascript/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1 什么是闭包"></a>1 什么是闭包</h1><p>关于什么是闭包有下面两种定义方式：</p>
<ol>
<li>有能力引用外部变量的函数叫做闭包，因为 js 的函数都具有此能力，故 js 的所有函数都可称作做闭包</li>
<li>引用了外部变量的函数叫做闭包</li>
</ol>
<p>个人更倾向于第二种定义方式，有下面两个原因：</p>
<ol>
<li>第二种定义会使得理解 js 中的闭包相关问题时更顺畅</li>
<li>只有当 js 函数引用了外部变量时，其作用域链 [[scope]] 才会包含一个叫做 Closure 的对象（Closure 对象中存储了被引用的外部变量，稍后会有图示）。</li>
</ol>
<p>在下面示例中，B1 就是一个闭包（因为 B1 引用了外部函数 A 的变量），可以看到 B1 的作用域链包含了一个 Closure 成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aVar = <span class="string">&#x27;aVar&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">B1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(aVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B1Alias = A();</span><br><span class="line"><span class="built_in">console</span>.dir(B1Alias);</span><br></pre></td></tr></table></figure>

<img src="/web/javascript/%E9%97%AD%E5%8C%85/6.png" class="">

<ul>
<li><p>当 B1 没有被外部引用时，函数 A 执行完后，A 的局部变量和 B1 会被释放。</p>
</li>
<li><p>当 B1 被外部变量（B1Alias）引用时，即使函数 A 已经执行完成， B1Alias 依旧会将 A 的变量（aVar）保留下来。<strong>而函数 A 执行完，其内部的变量却没有被释放，这就是闭包被关注的根本原因</strong>。</p>
</li>
</ul>
<h1 id="2-闭包的用途"><a href="#2-闭包的用途" class="headerlink" title="2 闭包的用途"></a>2 闭包的用途</h1><h2 id="2-1-封装私有变量、方法"><a href="#2-1-封装私有变量、方法" class="headerlink" title="2.1 封装私有变量、方法"></a>2.1 封装私有变量、方法</h2><p>js 中可以使用函数来封装模块，其实就是利用了闭包的特性。下面代码就使用函数封装了内部的私有变量 privateCounter 和私有方法 changeBy。外部只能通过 makeCounter 返回的公共方法操作私有变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Counter1 = makeCounter();</span><br><span class="line"><span class="keyword">var</span> Counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter1.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter2.value()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure>



<h1 id="3-闭包中常见的问题"><a href="#3-闭包中常见的问题" class="headerlink" title="3 闭包中常见的问题"></a>3 闭包中常见的问题</h1><p>在使用闭包时，很容易出现一些意料之外的执行结果，并且影响性能，容易造成内存泄露，所以应该尽量少使用闭包。</p>
<h2 id="3-1-在循环中创建闭包"><a href="#3-1-在循环中创建闭包" class="headerlink" title="3.1 在循环中创建闭包"></a>3.1 在循环中创建闭包</h2><p>在循环中创建闭包时，如果将循环代码直接用于闭包，则会使所有闭包指向同一个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constFuns</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funs = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//访问外部函数的变量，使其成为一个闭包</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funs = constFuns();</span><br><span class="line"><span class="built_in">console</span>.dir(funs[<span class="number">5</span>]()); <span class="comment">//期望输出5 结果输出10</span></span><br><span class="line"><span class="built_in">console</span>.dir(funs）;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码中，因为 funs 数组中的所有闭包函数在同一个外部函数中定义，所以这些闭包的 Closure 属性共享相同的变量 i，而这个变量 i 是对外部函数变量 i 的引用，而不是复制，当外部函数执行完成时，变量 i 的值变成了 10，导致所有闭包内的变量 i 都变成了 10。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<img src="/web/javascript/%E9%97%AD%E5%8C%85/7.png" class="">

<p>解决上面问题的方法：</p>
<p>1、使用 es6 的 let 语法，从而防止产生闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用let填坑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constFuns</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funs = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//使用了外部函数的变量时，才会使嵌套函数成为闭包。</span></span><br><span class="line">        <span class="comment">//let 不会进行变量提升，也就是说 i 不是外部函数 constFuns 的变量，故循环里面的匿名函数并不是闭包</span></span><br><span class="line">        funs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funs = constFuns();</span><br><span class="line"><span class="built_in">console</span>.dir(funs[<span class="number">5</span>]());</span><br><span class="line"><span class="built_in">console</span>.dir(funs);</span><br></pre></td></tr></table></figure>

<img src="/web/javascript/%E9%97%AD%E5%8C%85/8.png" class="">

<p>可以看到，匿名函数的作用域链中，并没有包含 Closure 成员，而是包含了并不共享的 Block 成员。从而避免了 Closure 共享所带来的问题。</p>
<p>2、使用更多的闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constFuns</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funs = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funs[i] = inner(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> funs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funs = constFuns();</span><br><span class="line"><span class="built_in">console</span>.log(funs[<span class="number">5</span>]());</span><br><span class="line"><span class="built_in">console</span>.dir(funs);</span><br></pre></td></tr></table></figure>

<img src="/web/javascript/%E9%97%AD%E5%8C%85/9.png" class="">

<h2 id="3-2-影响性能"><a href="#3-2-影响性能" class="headerlink" title="3.2 影响性能"></a>3.2 影响性能</h2><p>闭包会对降低程序的处理速度、增加对内存的使用。</p>
<h2 id="3-3-内存泄露"><a href="#3-3-内存泄露" class="headerlink" title="3.3 内存泄露"></a>3.3 内存泄露</h2><p>代码中有循环引用时，容易操作内存泄露。</p>
<h1 id="4-注意"><a href="#4-注意" class="headerlink" title="4 注意"></a>4 注意</h1><h2 id="4-1-嵌套函数没有使用父函数的变量时，不会产生闭包属性"><a href="#4-1-嵌套函数没有使用父函数的变量时，不会产生闭包属性" class="headerlink" title="4.1 嵌套函数没有使用父函数的变量时，不会产生闭包属性"></a>4.1 嵌套函数没有使用父函数的变量时，不会产生闭包属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">aArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aVar = <span class="string">&#x27;aVar&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两个嵌套函数都没有使用父函数的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B1</span>(<span class="params">b1Arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b1Var = <span class="string">&#x27;b1Var&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B2</span>(<span class="params">b2Arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b2Var = <span class="string">&#x27;b2Var&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.dir(B1);</span><br><span class="line">    <span class="built_in">console</span>.dir(B2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/web/javascript/%E9%97%AD%E5%8C%85/4.png" class="">

<h2 id="4-2-嵌套函数在引用父函数的变量后，会产生闭包属性，并且同一外部函数内的嵌套函数共享同一个作用域链（即都会产生闭包属性）。"><a href="#4-2-嵌套函数在引用父函数的变量后，会产生闭包属性，并且同一外部函数内的嵌套函数共享同一个作用域链（即都会产生闭包属性）。" class="headerlink" title="4.2 嵌套函数在引用父函数的变量后，会产生闭包属性，并且同一外部函数内的嵌套函数共享同一个作用域链（即都会产生闭包属性）。"></a>4.2 嵌套函数在引用父函数的变量后，会产生闭包属性，并且同一外部函数内的嵌套函数共享同一个作用域链（即都会产生闭包属性）。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">aArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aVar = <span class="string">&#x27;aVar&#x27;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*嵌套函数 B2 引用父函数的变量  </span></span><br><span class="line"><span class="comment">      嵌套函数 B1 没有引用父函数的变量</span></span><br><span class="line"><span class="comment">      更深一级的嵌套函数 C1 没有引用任何父函数的变量</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      结果：B2 对父函数变量的引用，使其产生了 Closure 属性，并且使平级的 B1 、内部的 C1 都产生了 Closure 属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B1</span>(<span class="params">b1Arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b1Var = <span class="string">&#x27;b1Var&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">C1</span>(<span class="params">c1Arg</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c1Var = <span class="string">&#x27;c1Var&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.dir(C1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B2</span>(<span class="params">b2Arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b2Var = <span class="string">&#x27;b2Var&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(aVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.dir(B1);</span><br><span class="line">    <span class="built_in">console</span>.dir(B2);</span><br><span class="line">    B1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>chrome 输出：</p>
<img src="/web/javascript/%E9%97%AD%E5%8C%85/5.png" class="">]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>$ajax 需要注意的参数</title>
    <url>/web/jquery/$ajax%20%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="processData"><a href="#processData" class="headerlink" title="processData"></a>processData</h1><p>当传递给 $ajax 的数据参数不是字符串时，$ajax 会默认将数据转化为 ‘application/x-<a href="http://www.form-urlencoded’/">www.form-urlencoded’</a> 格式，即 url 编码用 &amp; 分隔的名值对。</p>
<p>可以通过设置 processData 为 false，来阻止 $ajax 转化数据，特别是在传递的数据类型为 formdata 时，一定要将 processData 设置为 false。</p>
<h1 id="contentType"><a href="#contentType" class="headerlink" title="contentType"></a>contentType</h1><p>contentType 告诉服务器发送过去的数据类型，默认类型为 ‘application/x-<a href="http://www.form-urlencoded’./">www.form-urlencoded’。</a></p>
<p>当需要发送 文本、json、xml 等时，需要设置该选项为对应的资源类型，当需要使用 $ajax 上传文件时，需要将该值设置为 false。</p>
<h1 id="beforeSend"><a href="#beforeSend" class="headerlink" title="beforeSend"></a>beforeSend</h1><p>该参数使程序有机会自定义 xmlHttpRequest 对象的 HTTP 头部。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>$ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>node解析html之cheerio</title>
    <url>/web/node/node%E8%A7%A3%E6%9E%90html%E4%B9%8Bcheerio/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>cheerio 是 node 的第三方模块，使用语法和 jquery 类似，可以使用 cheerio 来解析 html 文件，进而对文件进行修改等操作。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install cheerio</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>下面示例会读取 test.html 文件，然后修改其 <code>#wraper</code> 节点的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wraper&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在文件 modfiyhtml.js 中操作 test.html 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&quot;cheerio&quot;</span>);<span class="comment">//引用第三方库</span></span><br><span class="line"><span class="keyword">const</span> fName = path.join(process.cwd(), <span class="string">&quot;./test.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fs.existsSync(fName)) &#123;</span><br><span class="line">    fs.readFile(fName, <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        $ = cheerio.load(data);</span><br><span class="line">        $(<span class="string">&quot;#wraper&quot;</span>).html(<span class="string">&quot;world&quot;</span>);<span class="comment">// 修改#wraper 节点内容 </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log($.html());<span class="comment">//输出修改后的内容</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;not exist&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wraper&quot;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>cheerio</tag>
      </tags>
  </entry>
  <entry>
    <title>prototype 详解</title>
    <url>/web/javascript/prototype/</url>
    <content><![CDATA[<h1 id="1-proto"><a href="#1-proto" class="headerlink" title="1 __proto__"></a>1 <code>__proto__</code></h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><p><code>__proto__</code> 是对象的属性（是对象内部属性 <code>[[Prototype]]</code> 的访问器），表示对象的原型，其值为创建此对象的构造函数的原型（prototype）。</p>
<h2 id="1-2-有什么作用"><a href="#1-2-有什么作用" class="headerlink" title="1.2 有什么作用"></a>1.2 有什么作用</h2><ul>
<li>查询对象的原型</li>
<li>组成原型链<ul>
<li>对象的原型 <code>__proto__</code> 也有 <code>__proto__</code> 属性，由一层层的 <code>__proto__</code> 组成的链表，即所谓的<strong>原型链</strong>。当查询的属性没在当前对象上时，就会从对象的<strong>原型链</strong>上找，直到 <code>__proto__</code> 为 null 还没找到时，才认为查询的属性为 undefined。</li>
</ul>
</li>
</ul>
<h2 id="1-3-注意"><a href="#1-3-注意" class="headerlink" title="1.3 注意"></a>1.3 注意</h2><ul>
<li><p>现在更推荐使用 <code>Object.getPrototypeOf / Object.setPrototypeOf</code> 来获取和设置对象的原型。</p>
</li>
<li><p>修改对象的 <code>__proto__</code> 属性时，对象必须是可扩展的（<code>通过</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible"><code>Object.isExtensible()</code></a> 判断），否则会抛出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a> 错误。</p>
</li>
<li><p>修改的新值必须为 object 或 null，否则不会起作用。</p>
</li>
</ul>
<h1 id="2-prototype"><a href="#2-prototype" class="headerlink" title="2 prototype"></a>2 prototype</h1><h2 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么"></a>2.1 是什么</h2><p><code>prototype</code> 是函数的属性，指向函数的原型。</p>
<h2 id="2-2-有什么作用"><a href="#2-2-有什么作用" class="headerlink" title="2.2 有什么作用"></a>2.2 有什么作用</h2><p><code>prototype</code> 的内容会被所有实例共享，甚至某个实例被创建后再修改构造函数的 <code>prototype</code>，都会反映到其他实例上。</p>
<h2 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h2><p>函数本质上也是对象，故构造函数也有 <code>__proto__</code> 属性。</p>
<p>参考：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p>
<p><a href="https://blog.csdn.net/cc18868876837/article/details/81211729">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>__proto__</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>Effect Hook</title>
    <url>/web/react/Effec%20Hook/</url>
    <content><![CDATA[<h1 id="Effect-Hook-是什么"><a href="#Effect-Hook-是什么" class="headerlink" title="Effect Hook 是什么"></a>Effect Hook 是什么</h1><p>可以将 <code>Effect Hook</code> 看做是 class 组件中 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 三个函数的组合。</p>
<h1 id="Effect-Hook-解决什么问题"><a href="#Effect-Hook-解决什么问题" class="headerlink" title="Effect Hook 解决什么问题"></a>Effect Hook 解决什么问题</h1><p><code>Effect Hook</code> 可以解决 <code>class</code> 组件同一生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了不同生命周期的问题。<code>Effect Hook</code> 会在每次渲染后（<strong>挂载或更新，在 class 组件中，这两个过程是两个不同个生命周期</strong>）被执行，我们可以在 <code>Effect Hook</code> 中执行<strong>副作用操作</strong>，如数据获取、dom 更新、事件的监听和清除、定时器的设定和清理等，从而将相关逻辑聚集在同一个地方。</p>
<p>与  <code>componentDidMount</code>  或  <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 <code>effect</code>（<strong>传给 useEffect 的函数叫做 effect</strong>） 不会阻塞浏览器更新屏幕，这让我们的应用看起来响应更快。</p>
<h1 id="effect-的清除机制"><a href="#effect-的清除机制" class="headerlink" title="effect 的清除机制"></a>effect 的清除机制</h1><p>当我们在 effect 中添加了监听、定时器等需要清理的资源时，可以给 <code>effect</code> 返回一个清理函数，将清理操作放到清理函数中。React 会在组件卸载、和下次执行对应 effect 时，执行此清理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    // 在 effect 函数中，返回一个清理函数，并将清理操作作为清理函数的内容:</span><br><span class="line">    // 清理函数会在下次执行此 effect 时，默认进行执行</span><br><span class="line">    return function cleanup() &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (isOnline === null) &#123;</span><br><span class="line">    return &#x27;Loading...&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 effect 内容不需要清理时，则无需返回函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    //effect 无需清理时 则不需要返回清理函数</span><br><span class="line">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="逻辑分离"><a href="#逻辑分离" class="headerlink" title="逻辑分离"></a>逻辑分离</h2><p>可以使用多个 effect，将不同的逻辑分离开。React 会按照 effect 声明的顺序依次调用组件中的<em>每一个</em> effect。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function FriendStatusWithCounter(props) &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制渲染频率（性能）"><a href="#控制渲染频率（性能）" class="headerlink" title="控制渲染频率（性能）"></a>控制渲染频率（性能）</h2><p>可以通过给 useEffect 传递第二个参数（数组类型）来控制组件的渲染。</p>
<p>下面示例中，将 count 作为数组参数传递给 useEffect 时，react 只有当 count 的值发生变化时，才会调用 effect 函数和清理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">&#125;, [count]); // 仅在 count 更改时更新</span><br></pre></td></tr></table></figure>

<p>当 useEffect 的第二个参数的数组中有多个元素时，只有当所有元素都没有发生变化时，react 才会忽略 effect的执行。</p>
<p>当 useEffect 的第二个参数的数组为空时，这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。</p>
<h2 id="语法校验"><a href="#语法校验" class="headerlink" title="语法校验"></a>语法校验</h2><p>官方推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议</p>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>Hook 简介</title>
    <url>/web/react/Hook%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Hook-是什么"><a href="#Hook-是什么" class="headerlink" title="Hook 是什么"></a>Hook 是什么</h1><p>Hook 是 React 16.8.0 的新特性。</p>
<p>Hook 是钩子函数，通过使用 Hook 可以在 <code>函数组件</code> 中引入 <code>React state</code> 及 <code>生命周期</code> 等特性，它可以让我们在不编写 class 的情况下使用 state 及其他的 React 特性。</p>
<h1 id="Hook-可以解决什么问题"><a href="#Hook-可以解决什么问题" class="headerlink" title="Hook 可以解决什么问题"></a>Hook 可以解决什么问题</h1><p>Hook 可以解决如下问题：</p>
<ul>
<li><p>组件间复用状态逻辑困难</p>
<p>​    React 之前用 <code>render props</code> 和 <code>高阶组件</code> 解决此问题，但需要重新组织组件结构。现在可以<strong>使用 Hook 在无需修改组件结构的情况下复用状态逻辑</strong>。</p>
</li>
<li><p>复杂组件越来越难以理解</p>
<p>​    之前在不同的生命周期中维护的逻辑关联的代码，现在可以使用 <strong>Hook 将组件中逻辑关联的部分拆分成更小的函数（比如设置订阅或请求数据）</strong>。还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</p>
</li>
<li><p>避开 class</p>
<p>​    js 中的 class 和其他语言中的 class 有很大区别，特别是 this 的工作方式，编写 React 组件时，需要额外编写 this 和事件处理器的绑定，而这些代码其实非常冗余。</p>
<p>​    class 不能很好的压缩，会使得热加载出现不稳定的情况。</p>
<p>​    <strong>Hook 能够使你避开 class 也能使用更多的 React 特性。</strong></p>
</li>
</ul>
<h1 id="Hook-对现有代码的影响"><a href="#Hook-对现有代码的影响" class="headerlink" title="Hook 对现有代码的影响"></a>Hook 对现有代码的影响</h1><ul>
<li>可选功能<ul>
<li>无需重写现有代码即可使用 Hook</li>
<li>不是非得用 Hook 不可，如果不想也可以不用</li>
</ul>
</li>
<li>100% 向后兼容</li>
<li>可用版本<ul>
<li>从 React 16.8.0 版本之后可以使用 Hook</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>node路径操作</title>
    <url>/web/node/node%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>node.js 使用函数封装器将每个模块进行封装，并将如下参数传递给模块，使的模块可以在内部直接使用这些参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 模块的代码实际上在这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="当前模块所在路径"><a href="#当前模块所在路径" class="headerlink" title="当前模块所在路径"></a>当前模块所在路径</h1><p>__dirname 可以获取到当前模块所在目录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 /Users/mjr 运行 node example.js</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"><span class="comment">// 打印: /Users/mjr</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(__filename));</span><br><span class="line"><span class="comment">// 打印: /Users/mjr</span></span><br></pre></td></tr></table></figure>

<h1 id="当前模块文件名"><a href="#当前模块文件名" class="headerlink" title="当前模块文件名"></a>当前模块文件名</h1><p>__filename 可以获取到当前模块的绝对文件名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 /Users/mjr 运行 node example.js</span></span><br><span class="line"><span class="built_in">console</span>.log(__filename);</span><br><span class="line"><span class="comment">// 打印: /Users/mjr/example.js</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"><span class="comment">// 打印: /Users/mjr</span></span><br></pre></td></tr></table></figure>

<h1 id="拼接路径"><a href="#拼接路径" class="headerlink" title="拼接路径"></a>拼接路径</h1><p>path.join(<code>[...paths]</code>) 方法可以使用平台特定的分隔符，将所给定的参数片段连接在一起。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">consot path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">path.join(<span class="string">&#x27;/foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz/asdf&#x27;</span>, <span class="string">&#x27;quux&#x27;</span>, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;/foo/bar/baz/asdf&#x27;</span></span><br><span class="line"></span><br><span class="line">path.join(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// 抛出 &#x27;TypeError: Path must be a string. Received &#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 React Hook 需要遵循的规则</title>
    <url>/web/react/Hook%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="使用-Hook-需要遵循的规则"><a href="#使用-Hook-需要遵循的规则" class="headerlink" title="使用 Hook 需要遵循的规则"></a>使用 Hook 需要遵循的规则</h1><p>Hook 的本质是 js 函数，使用 <code>Hook</code> 需要遵循下面两条规则：</p>
<ul>
<li><p>只在顶层使用 <code>Hook</code></p>
<p>为了保证 <code>Hook</code> 在每次都以相同的顺序被调用（<strong>只有 Hook 的调用顺序在多次渲染之间保持一致，React 才能正确地将内部 state 和对应的 Hook 进行关联</strong>），确保总是在 React 函数的顶层调用 <code>Hook</code>，不要在循环、条件、嵌套中调用 <code>Hook</code></p>
</li>
<li><p>只在 React 函数组件中调用 <code>Hook</code>（<code>自定义 Hook</code> 中也可以调用 <code>Hook</code>）</p>
</li>
</ul>
<h2 id="使用-ESlint-插件"><a href="#使用-ESlint-插件" class="headerlink" title="使用 ESlint 插件"></a>使用 ESlint 插件</h2><p>官方推荐使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a> 插件强制执行 <code>Hook</code> 规则。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下载插件</span></span><br><span class="line">npm install eslint-plugin-react-hooks --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置eslint</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&quot;react-hooks&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>, <span class="comment">// 检查 Hook 的规则</span></span><br><span class="line">    <span class="attr">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="string">&quot;warn&quot;</span> <span class="comment">// 检查 effect 的依赖</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的<em>内部</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(function persistForm() &#123;</span><br><span class="line">   // 👍 将条件判断放置在 effect 中</span><br><span class="line">   if (name !== &#x27;&#x27;) &#123;</span><br><span class="line">     localStorage.setItem(&#x27;formData&#x27;, name);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>ReactRedux</title>
    <url>/web/react/ReactRedux/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>ReactRedux 是 Redux 官方为 React 提供的绑定库，让我们可以在 React 中更方便的使用 Redux。</p>
<p>在 ReactRedux 中，用户只需要提供 UI 组件，ReactRedux 会自动生成容器组件来管理状态。</p>
<h1 id="2-怎么使用"><a href="#2-怎么使用" class="headerlink" title="2 怎么使用"></a>2 怎么使用</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>ReactRedux 基于 redux，所以需要将 redux 一并安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install redux react-redux</span><br></pre></td></tr></table></figure>

<h2 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h2><h3 id="2-2-1-Provider-组件"><a href="#2-2-1-Provider-组件" class="headerlink" title="2.2.1 Provider 组件"></a>2.2.1 Provider 组件</h3><p>Provider 是 ReactRedux 提供的组件，这个组件能够连接 Store ，并可以将 Store 提供给所有的子组件。</p>
<p>Provider 内部使用 React 的 Context 机制使 Store 在子组件内共享。</p>
<h4 id="2-2-1-1-语法"><a href="#2-2-1-1-语法" class="headerlink" title="2.2.1.1 语法"></a>2.2.1.1 语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Provider store&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-2-示例"><a href="#2-2-1-2-示例" class="headerlink" title="2.2.1.2 示例"></a>2.2.1.2 示例</h4><p>使用 Provider 把 React 根组件包裹起来，即可将 Store 专递给所有子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">&quot;./TodoList.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  rootEl</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-connect-方法"><a href="#2-2-2-connect-方法" class="headerlink" title="2.2.2 connect 方法"></a>2.2.2 connect 方法</h3><p>connect 是 ReactRedux 提供的方法，能够将 UI 组件和 ReduxStore 连接起来，并返回一个新的、包裹了 UI 组件的、可以管理 UI 组件状态的<strong>容器组件</strong>。</p>
<h4 id="2-2-2-1-语法"><a href="#2-2-2-1-语法" class="headerlink" title="2.2.2.1 语法"></a>2.2.2.1 语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps?, mapDispatchToProps?, mergeProps?, options?</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>mapStateToProps?: (state, ownProps?) =&gt; Object</code></p>
<ul>
<li>参数<ul>
<li>state:  是全局的 ReduxStore</li>
<li>ownProps?:  容器组件的 props 属性</li>
</ul>
</li>
<li>返回值：会作为 UI 组件的 props 属性</li>
<li>功能描述： <ul>
<li>通过 mapStateToProps  可以将 ReduxStore 中的数据映射到 UI 组件的 props 属性。</li>
<li>mapStateToProps 是 ReduxStore 的监听器，当 ReduxStore 更新时，就会触发 Ui 组件的重新渲染。不传递 mapStateToProps 时， UI 组件将不感知 ReduxStore 的更新。    </li>
<li>使用了参数 ownProps 后，当容器组件的 props 发生变化，会触发 UI 组件的更新。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>mapDispatchToProps?: Object | (dispatch, ownProps?) =&gt; Object</code></p>
<ul>
<li>参数<ul>
<li>dispatch: 即 ReduxStore.dispatch</li>
<li>ownProps？: 容器组件的 props 属性</li>
</ul>
</li>
<li>返回值<ul>
<li>函数类型时，返回值为 dispatch 和 UI 组件的 函数类型 props 的对应关系</li>
<li>对象类型时，此对象为 dispatch 和 UI 组件的 函数类型 props 的对应关系</li>
</ul>
</li>
<li>功能描述<ul>
<li>​    通过 mapDispatchToProps 可以将 dispatch 和 UI 组件的 函数类型 props 对应起来</li>
</ul>
</li>
</ul>
</li>
<li><p><code>mergeProps?: (stateProps, dispatchProps, ownProps) =&gt; Object</code></p>
<ul>
<li>参数<ul>
<li>stateProps：mapStateToProps 返回值</li>
<li>dispatchProps： mapDispatchToProps 返回值</li>
<li>ownProps：容器组件的 props 属性</li>
</ul>
</li>
<li>返回值<ul>
<li>返回值会作为 UI 组件的 props 属性</li>
</ul>
</li>
<li>功能描述<ul>
<li>用来自定义 UI 组件的 props 属性</li>
</ul>
</li>
</ul>
</li>
<li><p><code>options?: Object</code></p>
<ul>
<li>参数<ul>
<li>[<code>pure = true</code>] <em>(Boolean)</em>: 为 true 时，connector 将执行 <code>shouldComponentUpdate</code> 并且浅对比 <code>mergeProps</code> 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。<em>默认值为 true。</em></li>
<li>[<code>withRef = false</code>] <em>(Boolean)</em>: 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 <code>getWrappedInstance()</code> 方法获得。<em>默认值为 false。</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-2-示例"><a href="#2-2-2-2-示例" class="headerlink" title="2.2.2.2 示例"></a>2.2.2.2 示例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; updateInputValueAction, addListDataAction &#125; <span class="keyword">from</span> <span class="string">&quot;./store/actions&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;props.inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;props.onInputChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props.addListData&#125;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;hh&quot;</span>, ownProps);</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">inputValue</span>: state.todoList.inputValue,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">onInputChange</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">			dispatch(updateInputValueAction(e.target.value));</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">addListData</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">			dispatch(addListDataAction());</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Refs</title>
    <url>/web/react/Refs/</url>
    <content><![CDATA[<h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h1><p>Refs 是在 React 中获取节点（原生 DOM 或 React 组件）实例的方式。可以通过 Refs 来获取节点实例的引用，通过操作此引用达到操作节点的目的。</p>
<h1 id="2-解决什么问题"><a href="#2-解决什么问题" class="headerlink" title="2 解决什么问题"></a>2 解决什么问题</h1><p>Refs 主要用来解决需要操作节点的场景，如：</p>
<ul>
<li>管理子节点焦点、文本选择</li>
<li>强制动画</li>
<li>集成第三方 DOM 库</li>
</ul>
<h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3 使用方法"></a>3 使用方法</h1><h2 id="3-1-createRef"><a href="#3-1-createRef" class="headerlink" title="3.1 createRef"></a>3.1 createRef</h2><p>React.createRef 是 React 16.3 版本引入的创建 Refs 的方法。</p>
<h3 id="3-1-1-创建-Refs"><a href="#3-1-1-创建-Refs" class="headerlink" title="3.1.1 创建 Refs"></a>3.1.1 创建 Refs</h3><p>通过 React.createRefs() 方法可以创建 Refs。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">      // 1、在组件中调用 createRef 函数创建 Refs 变量</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">      // 2、使用 ref（此属性名固定） 属性将 Refs 变量和节点关联起来</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-访问-Refs"><a href="#3-1-2-访问-Refs" class="headerlink" title="3.1.2 访问 Refs"></a>3.1.2 访问 Refs</h3><p>通过 Refs 变量的 current 属性可以访问节点的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const node = this.myRef.current;// 此时 node 就是节点实例的引用</span><br></pre></td></tr></table></figure>

<p>当组件挂载时，this.myRef.current 会被赋值为节点实例。</p>
<p>当组件被卸载时，this.myRef.current 会被赋值为 null。</p>
<h3 id="3-1-3-示例"><a href="#3-1-3-示例" class="headerlink" title="3.1.3 示例"></a>3.1.3 示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    //1、创建 Refs 变量 this.textInput</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">    this.focusTextInput = this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    // 3、通过 this.textInput.current 属性访问节点实例</span><br><span class="line">    this.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 2、通过给节点配置 ref 属性，将节点实例关联到 this.textInput</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.textInput&#125; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-callback-Refs"><a href="#3-2-callback-Refs" class="headerlink" title="3.2 callback Refs"></a>3.2 callback Refs</h2><p>callback Refs 是指通过给节点的 ref 属性传递回调函数来获取节点实例。</p>
<h3 id="3-2-1-示例"><a href="#3-2-1-示例" class="headerlink" title="3.2.1 示例"></a>3.2.1 示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.textInput = null;</span><br><span class="line"></span><br><span class="line">    this.setTextInputRef = element =&gt; &#123;</span><br><span class="line">        //2、回调函数会在节点挂载和卸载时被调用</span><br><span class="line">        //  节点的实例被作为参数（如 element）传给回调，卸载时 element 的值为 null </span><br><span class="line">      this.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.focusTextInput = () =&gt; &#123;</span><br><span class="line">      // 3、使用引用来操作节点</span><br><span class="line">      if (this.textInput) this.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 组件挂载后，让文本框自动获得焦点</span><br><span class="line">    this.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    //  1、给节点的 `ref` 属性配置回调函数 this.setTextInputRef </span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.setTextInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-注意"><a href="#3-2-2-注意" class="headerlink" title="3.2.2 注意"></a>3.2.2 注意</h3><p>ref 回调可以在组件间传递，进而可以解决嵌套组件间 ref 传递问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">    // ref 属性值通过 props 从外部传递进来</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-String-Refs（过时的-API）"><a href="#3-3-String-Refs（过时的-API）" class="headerlink" title="3.3 String Refs（过时的 API）"></a>3.3 String Refs（过时的 API）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.focusTextInput = this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    // 2、在父节点中通过 this.refs.myInput 属性访问子节点实例</span><br><span class="line">    this.refs.myInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 1、通过给子节点配置 ref 属性，值为字符串 myInput</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&quot;myInput&quot; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果目前还在使用 <code>this.refs.textInput</code> 这种方式访问 refs ，建议用 callback refs 或  createRefs 的方式代替，String 类型的 Refs 在未来版本可能将会被移除。</p>
<h1 id="4-注意"><a href="#4-注意" class="headerlink" title="4 注意"></a>4 注意</h1><p>1、默认情况下，不能在函数组件上使用 ref 属性，因为它没有实例。可以通过 forwardRef 创建函数组件，进而使其可以接收 ref 属性，或者将函数组件转化为 class 组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function MyFunctionComponent() &#123;</span><br><span class="line">  return &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // This will *not* work!</span><br><span class="line">    return (</span><br><span class="line">      &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Refs</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref 转发</title>
    <url>/web/react/Ref%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h1><p><code>Ref 转发</code>指组件接收 ref 参数，并将 ref 参数传递给子节点。</p>
<h1 id="2-解决什么问题"><a href="#2-解决什么问题" class="headerlink" title="2 解决什么问题"></a>2 解决什么问题</h1><p>解决需要在组件外部对组件内部节点进行管理的问题。</p>
<h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h1><ul>
<li>只有通过 <code>React.forwardRef</code> 创建的组件，才有获取和转发 ref 的能力。普通组件的 props 中不存在 ref 属性，组件内部也获取不到 ref 参数。</li>
<li>ref 转发控制的节点既可以是原生的 DOM 节点，也可以是 React 组件。</li>
</ul>
<h2 id="3-1-转发-Ref-到内部节点"><a href="#3-1-转发-Ref-到内部节点" class="headerlink" title="3.1 转发 Ref 到内部节点"></a>3.1 转发 Ref 到内部节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过 React.forwardRef 函数创建的组件，才能接收到外部的 ref 属性，</span><br><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// 你可以直接获取 DOM button 的 ref：</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-在高阶组件中转发-Ref"><a href="#3-2-在高阶组件中转发-Ref" class="headerlink" title="3.2 在高阶组件中转发 Ref"></a>3.2 在高阶组件中转发 Ref</h2><p>高阶组件默认无法透传 ref 属性给被包装组件，可以通过使用 React.forwardRef 来创建高阶组件的返回值以达到透传 ref 属性的能力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">function logProps(WrappedCompoonents)&#123;</span><br><span class="line">    class LogProps extends React.Component&#123;</span><br><span class="line">        componentDidUpdate(prevProps)&#123;</span><br><span class="line">            console.log(&#x27;old props&#x27;, prevProps);</span><br><span class="line">            console.log(&#x27;new props&#x27;, this.props);</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            // 3、提取 forward 属性</span><br><span class="line">            const &#123;forward, ...rest&#125; = this.props;</span><br><span class="line">            // 4、将 forward 配置给被包装组件的 ref</span><br><span class="line">            return &lt;WrappedCompoonents ref=&#123;forward&#125; &#123;...rest&#125;&gt;&lt;/WrappedCompoonents&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   // 1、通过 React.forwardRef 创建有接受 ref 参数能力的组件</span><br><span class="line">   return React.forwardRef((props, ref)=&gt;&#123;</span><br><span class="line">       //2、 将 ref 属性值通过属性 forward 传递给包装组件</span><br><span class="line">        return &lt;LogProps &#123;...props&#125; forward=&#123;ref&#125;&gt;&lt;/LogProps&gt;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Ref</tag>
      </tags>
  </entry>
  <entry>
    <title>State Hook</title>
    <url>/web/react/State%20Hook/</url>
    <content><![CDATA[<h2 id="State-Hook-解决什么问题"><a href="#State-Hook-解决什么问题" class="headerlink" title="State Hook 解决什么问题"></a>State Hook 解决什么问题</h2><p><code>state hook</code> 可以用来给 <code>函数组件</code> 添加 <code>state</code>。</p>
<p>没有 <code>state hook</code> 之前， <code>函数组件</code> 属于 <code>无状态组件</code>，想给 <code>函数组件</code> 添加 state 时，只能将其转换为 class 组件。</p>
<h2 id="State-Hook-的使用方法"><a href="#State-Hook-的使用方法" class="headerlink" title="State Hook 的使用方法"></a>State Hook 的使用方法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">[stateName, setStateFun] = useState(initValue);</span><br></pre></td></tr></table></figure>

<p>在函数组件中，通过调用 <code>useState()</code> 函数来定义 state 变量，它与 class 里面的 this.state 提供的功能相同。</p>
<p><strong>useState 的返回值</strong>：返回一个有两个值的数组。第一个值是 state 变量，第二个值是更新 state 变量的函数。上面示例中，count 就是刚刚定义的 state 变量，setCount 就是用来更新 count 的函数。</p>
<p><strong>useState 的参数</strong>：用来初始化 state 变量。下面示例中的参数 0，即表示 count 的初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">定义：</span><br><span class="line">1、引入useState函数</span><br><span class="line">2、调用useState函数</span><br><span class="line">*/</span><br><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  // 声明一个叫 “count” 的 state 变量，和用来更新 count 的函数 setCount</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="读取State"><a href="#读取State" class="headerlink" title="读取State"></a>读取State</h3><p>在 class 组件中，读取 state 变量时，通过 this.state，如 this.state.count。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>在函数组件中，读取 state 变量时，直接使用即可，如 count。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="更新State"><a href="#更新State" class="headerlink" title="更新State"></a>更新State</h3><p>在 class 组件中，需要调用 <code>this.setState()</code> 来更新 state 变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setState 更新 State 时，会使用新值和旧值进行合并  </span></span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;)&#125;&gt;</span><br><span class="line">    Click me</span><br><span class="line">  &lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在函数组件中，使用 <code>useState()</code> 函数返回的 <code>更新函数</code>（如 setCount 函数）来更新对应的 state 变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//useState 更新 State 时，会直接用新值替换旧值</span></span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">   Click me</span><br><span class="line"> &lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1:  import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"> 2:</span><br><span class="line"> 3:  function Example() &#123;</span><br><span class="line">     //使用useState函数定义state变量</span><br><span class="line"> 4:    const [count, setCount] = useState(0);</span><br><span class="line"> 5:</span><br><span class="line"> 6:    return (</span><br><span class="line"> 7:      &lt;div&gt;</span><br><span class="line">         &#123;/*使用state变量*/&#125;</span><br><span class="line"> 8:        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">         </span><br><span class="line">         &#123;//修改state变量&#125;</span><br><span class="line"> 9:        &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">10:         Click me</span><br><span class="line">11:        &lt;/button&gt;</span><br><span class="line">12:      &lt;/div&gt;</span><br><span class="line">13:    );</span><br><span class="line">14:  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义多个 state 变量方法</strong>：</p>
<ul>
<li><p>多次调用 useState</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ExampleWithManyStates() &#123;</span><br><span class="line">  // 声明多个 state 变量</span><br><span class="line">  const [age, setAge] = useState(42);</span><br><span class="line">  const [fruit, setFruit] = useState(&#x27;banana&#x27;);</span><br><span class="line">  const [todos, setTodos] = useState([&#123; text: &#x27;学习 Hook&#x27; &#125;]);</span><br></pre></td></tr></table></figure></li>
<li><p>将多个变量通过对象或数组的方式存入同一个 state 变量</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123; <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleWindowMouseMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 展开 「...state」 以确保我们没有 「丢失」 width 和 height</span></span><br><span class="line">      <span class="comment">// useState 更新 State 时，会用新值替换旧值，而不是新旧值合并</span></span><br><span class="line">      setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; ...state, <span class="attr">left</span>: e.pageX, <span class="attr">top</span>: e.pageY &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：这是个简化版的实现</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, handleWindowMouseMove);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, handleWindowMouseMove);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>react dom diff</title>
    <url>/web/react/dom%20diff/</url>
    <content><![CDATA[<h1 id="什么是-dom-diff"><a href="#什么是-dom-diff" class="headerlink" title="什么是 dom diff"></a>什么是 dom diff</h1><p>dom diff 指的是两个虚拟 dom 之间的差异点。使用 dom diff（而不是完整的新 dom） 来更新真实 dom，可以提高性能。 </p>
<h1 id="dom-diff-算法"><a href="#dom-diff-算法" class="headerlink" title="dom diff 算法"></a>dom diff 算法</h1><p>react 会通过下面方法算出 dom diff：</p>
<p>首先对比根元素：</p>
<ul>
<li><p>根元素类型不同时，根节点及子组件会被销毁重建</p>
</li>
<li><p>根元素属性不同时，会保留根节点仅更新根节点属性</p>
<ul>
<li>然后循环对比子元素<ul>
<li>当子元素没有 key 属性时时，react 会将相同位置的子元素进行对比。新增子元素时，将新增子元素追加到结尾，要比插入到头部性能更好。</li>
<li>当子元素有 key 属性时，react 会将 key 相同的子元素进行对比，进而避免由插入位置带来的性能问题。<ul>
<li>key 值在列表中应该具有稳定、可预测、唯一的特质。否则会导致组件产生不必要的重建</li>
<li>当数组下标作为 key 时，如果数组重新排序，组件的 state 可能会产生一些无法预期的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考链接：<a href="https://zh-hans.reactjs.org/docs/reconciliation.html">https://zh-hans.reactjs.org/docs/reconciliation.html</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react dom diff</tag>
      </tags>
  </entry>
  <entry>
    <title>react Context</title>
    <url>/web/react/react%20Context/</url>
    <content><![CDATA[<h1 id="1-有什么作用"><a href="#1-有什么作用" class="headerlink" title="1 有什么作用"></a>1 有什么作用</h1><p>使用 Context 可以在组件树中共享全局数据，如主题、语言等，而无需使用 props 将数据在组件树中层层传递。 </p>
<h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2 使用方法"></a>2 使用方法</h1><h2 id="2-1-创建-Context"><a href="#2-1-创建-Context" class="headerlink" title="2.1 创建 Context"></a>2.1 创建 Context</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当组件所在的树中没有匹配到 Provider 时，defaultValue 才生效。</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>

<p>使用 React.createContext 来创建 Context。</p>
<ul>
<li>Context 对象被创建后，可以被其他组件订阅</li>
<li>订阅 Context 对象的组件被称作<code>消费组件</code></li>
<li>一个 Context 可以被多个<code>消费组件</code>订阅</li>
</ul>
<h2 id="2-2-使用-Provider-包裹消费组件"><a href="#2-2-使用-Provider-包裹消费组件" class="headerlink" title="2.2 使用 Provider 包裹消费组件"></a>2.2 使用 Provider 包裹<code>消费组件</code></h2><p>Context.Provider 属性是一个组件，使用 Context.Provider 包裹<code>消费组件</code>，能够将 Context 值的最新变化传递到<code>消费组件</code>，使消费组件被<code>重新渲染</code>。</p>
<ul>
<li><code>消费组件</code>从离自身最近的 Provider 中读取当前的 Context 值，没找到 Provider 时，会使用 Context 被创建时的默认值。</li>
<li>多个 Provider 可以嵌套使用，里层的会覆盖外层的数据。</li>
<li>当 Provider 的 value 值发生变化时，<strong>其内部</strong>的所有消费组件都会被重新渲染。 </li>
<li>Provider 及其内部<code>消费组件</code>不受制于 shouldComponentUpdate 函数，因此<code>消费组件</code>在其祖先组件跳过更新的情况下也能更新。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当 value 的值为 undefined 时，不会使用 Context 对象的 defaultValue 参数的值</span></span><br><span class="line">&lt;MyContext.Provider value=&#123;<span class="string">&quot;somevalue&quot;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-订阅-Context"><a href="#2-2-订阅-Context" class="headerlink" title="2.2 订阅 Context"></a>2.2 订阅 Context</h2><h3 id="2-2-1-Context-Consumer"><a href="#2-2-1-Context-Consumer" class="headerlink" title="2.2.1 Context.Consumer"></a>2.2.1 Context.Consumer</h3><p>当<code>消组件费</code>为函数组件时，使用 Context.Consumer 来包裹子组件，可以订阅 Context 对象。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ThemeContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./theme-context&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeTogglerButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">/*使用</span></span><br><span class="line"><span class="comment">      &lt;Context.Consumer &gt;</span></span><br><span class="line"><span class="comment">      	&#123; (value) =&gt; (</span></span><br><span class="line"><span class="comment">      		//在此处渲染函数组件内容</span></span><br><span class="line"><span class="comment">      	)&#125;</span></span><br><span class="line"><span class="comment">      &lt;/Context.Consumer &gt;</span></span><br><span class="line"><span class="comment">      包裹函数组件渲染内容</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;toggleTheme&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> <span class="attr">theme.background</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">          Toggle Theme</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeTogglerButton;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-contextType"><a href="#2-2-2-contextType" class="headerlink" title="2.2.2 contextType"></a>2.2.2 contextType</h3><p>当<code>消费组件</code>为类组件时，通过将 Context 对象赋值给 Class.contextType 来订阅 Context 对象。此方法只能订阅单一的 Context 对象。</p>
<ul>
<li><p>将 Context 对象赋值给 Class.contextType 后，可以在任何生命周期中，使用 this.context 来获取订阅的 Context 对象的值。</p>
</li>
<li><p><code>消费组件</code>会使用离自己最近的 Context.Provider 的 value 值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;<span class="comment">//订阅 Context 对象</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;<span class="comment">//使用 Context 对象的值</span></span><br><span class="line">    <span class="comment">/* 基于这个值进行渲染工作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-3-订阅多个-Context"><a href="#2-2-3-订阅多个-Context" class="headerlink" title="2.2.3 订阅多个 Context"></a>2.2.3 订阅多个 Context</h3><p>React 需要每个 Context 对象是一个单独的节点，以确保 Context 快速渲染。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Theme context，默认的 theme 是 “light” 值</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录 context</span></span><br><span class="line"><span class="keyword">const</span> UserContext = React.createContext(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Guest&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;signedInUser, theme&#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供初始 context 值的 App 组件</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">UserContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;signedInUser&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Layout</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">UserContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Sidebar</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Content</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个组件可能会订阅多个 context</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;theme =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;user =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ProfilePage</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          )&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-更新-Context-方法"><a href="#2-3-更新-Context-方法" class="headerlink" title="2.3 更新 Context 方法"></a>2.3 更新 Context 方法</h2><h3 id="2-3-1-Provider"><a href="#2-3-1-Provider" class="headerlink" title="2.3.1 Provider"></a>2.3.1 Provider</h3><p>可以通过 Provider 的 value 属性来修改 Context 的值，其内部的消费者会被重新渲染。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当 value 的值为 undefined 时，不会使用 Context 对象的 defaultValue 参数的值</span></span><br><span class="line">&lt;MyContext.Provider value=&#123;<span class="string">&quot;somevalue&quot;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-消费组件"><a href="#2-3-2-消费组件" class="headerlink" title="2.3.2 消费组件"></a>2.3.2 消费组件</h3><p>可以通过给 Context 传递一个函数，使得<code>消费组件</code>可以通过此函数来更新 Context。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//theme-context.js</span></span><br><span class="line"><span class="comment">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  <span class="attr">theme</span>: themes.dark,</span><br><span class="line">  <span class="attr">toggleTheme</span>: <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">//传递函数 给消费组件调用</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> themes = &#123;</span><br><span class="line">  <span class="attr">light</span>: &#123;</span><br><span class="line">    <span class="attr">foreground</span>: <span class="string">&#x27;#000000&#x27;</span>,</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&#x27;#eeeeee&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">dark</span>: &#123;</span><br><span class="line">    <span class="attr">foreground</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&#x27;#222222&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//theme-toggler-button.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;ThemeContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./theme-context&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeTogglerButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;toggleTheme&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> <span class="attr">theme.background</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          Toggle Theme</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeTogglerButton;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;ThemeContext, themes&#125; <span class="keyword">from</span> <span class="string">&#x27;./theme-context&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ThemeTogglerButton <span class="keyword">from</span> <span class="string">&#x27;./theme-toggler-button&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.toggleTheme = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">theme</span>:</span><br><span class="line">          state.theme === themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State 也包含了更新函数，因此它会被传递进 context provider。</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">theme</span>: themes.light,</span><br><span class="line">      <span class="attr">toggleTheme</span>: <span class="built_in">this</span>.toggleTheme,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 整个 state 都被传递进 provider</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Content</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ThemeTogglerButton</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.root);</span><br></pre></td></tr></table></figure>

<h2 id="2-4-调试"><a href="#2-4-调试" class="headerlink" title="2.4 调试"></a>2.4 调试</h2><p>React DevTools 使用 Context.displayName 来确定 context 要显示的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const MyContext = React.createContext(/* some value */);</span><br><span class="line">MyContext.displayName = &#x27;MyDisplayName&#x27;;</span><br><span class="line"></span><br><span class="line">&lt;MyContext.Provider&gt; // &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span><br><span class="line">&lt;MyContext.Consumer&gt; // &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span><br></pre></td></tr></table></figure>

<h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3 注意"></a>3 注意</h1><ol>
<li>Context 会影响性能，不要滥用。</li>
<li>每个 Provider 提供的数据都是隔离开的，如果需要提供全局的数据，只需在 React 根部组件只提供一个 Provider 即可。 </li>
<li>为了避免不必要的重复渲染，应使用 state 来配置 Provider 组件的 value 属性。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Provider每次渲染时，以下的代码会重新渲染内部所有的consumers 组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;something:</span> &#x27;<span class="attr">something</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应按照如下方法，使用 state 来更新 Provider 的 value 属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">value</span>: &#123;<span class="attr">something</span>: <span class="string">&#x27;something&#x27;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react Props</title>
    <url>/web/react/react%20Props/</url>
    <content><![CDATA[<img src="/web/react/react%20Props/react_props.PNG" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; PropTypes &#125; from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">class TodoItem extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123; index, deleteItem, content &#125; = this.props;</span><br><span class="line">		return (</span><br><span class="line">			&lt;li index=&#123;index&#125; onClick=&#123;() =&gt; deleteItem(index)&#125;&gt;</span><br><span class="line">				&#123;content&#125;</span><br><span class="line">			&lt;/li&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TodoItem.propType = &#123;</span><br><span class="line">	content: PropTypes.string,</span><br><span class="line">	index: PropTypes.number,</span><br><span class="line">	deleteItem: PropTypes.func,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default TodoItem;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react jsx</title>
    <url>/web/react/react%20jsx/</url>
    <content><![CDATA[<img src="/web/react/react%20jsx/react_jsx.PNG" class="" title="react_jsx">
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react setState 原理</title>
    <url>/web/react/react%20setState/</url>
    <content><![CDATA[<h1 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setState(stateChange[, callback])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>stateChange</p>
<ul>
<li><p>stateChange 可以为对象 或 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setState((state, props) =&gt; &#123;</span><br><span class="line">//参数 state 和 props 都为最新的，返回值会与 state 进行浅合并</span><br><span class="line">	return &#123;counter: state.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">this.setState(&#123;quantity: 2&#125;) //对象参数会浅拷贝到新的 state 中</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>callback </p>
<ul>
<li>callback 为可选的回调函数，它将在 <code>setState</code> 完成合并并重新渲染组件后执行。通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式</li>
</ul>
</li>
</ul>
<h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h1><ul>
<li><p>setState 内部会将 state 的更改添加到队列，通过批量更新来提高性能。</p>
</li>
<li><p>如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新this.state，除此之外的setState调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 直接添加 JS 原生的事件处理函数，如 addEventListener、setTimeout、setInterval 等产生的调用</p>
</li>
<li><p>setState 总是会触发组件重新渲染（除非 shouldComponentUpdate 返回 false）。</p>
</li>
</ul>
<h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3 注意"></a>3 注意</h1><ul>
<li><p>构造函数是唯一可以给 this.state 直接赋值的地方，其他地方都通过使用 setState 来修改state。</p>
</li>
<li><p>react 会将多个 setState 调用合并为一个，故不要直接使用 state 来更新下一个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Correct</span><br><span class="line">this.setState((state, props) =&gt; (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react state</title>
    <url>/web/react/react%20state/</url>
    <content><![CDATA[<img src="/web/react/react%20state/react_state.PNG" class="">

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react 生命周期</title>
    <url>/web/react/react%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>react 生命周期分为 挂载时、更新时、卸载时 。</p>
<p>render 是唯一必须实现的组件生命周期。</p>
<p>先贴两张声明周期函数的图：</p>
<ul>
<li>常用的生命周期函数<ul>
<li><img src="/web/react/react%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/simple.png" class=""> </li>
</ul>
</li>
<li>全部的生命周期函数<ul>
<li><img src="/web/react/react%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/complex.png" class=""></li>
</ul>
</li>
</ul>
<p>上面两张图的引用地址：</p>
<ul>
<li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></li>
</ul>
<h1 id="1-挂载"><a href="#1-挂载" class="headerlink" title="1 挂载"></a>1 挂载</h1><p>当组件被创建并插入 DOM 中时，生命周期执行顺序如下，常用的生命周期用黑体表示：</p>
<ul>
<li><p><strong>constructor()</strong></p>
</li>
<li><p>static getDerivedStateFromProps(props, state)</p>
</li>
<li><p><strong>render()</strong></p>
</li>
<li><p><strong>componentDidMount()</strong></p>
</li>
</ul>
<p>下面是即将过时的生命周期，新代码应避免使用：</p>
<ul>
<li>UNSAFE_componentWillMount</li>
</ul>
<h2 id="1-1-constructor"><a href="#1-1-constructor" class="headerlink" title="1.1 constructor"></a>1.1 constructor</h2><h3 id="1-1-1-作用"><a href="#1-1-1-作用" class="headerlink" title="1.1.1 作用"></a>1.1.1 作用</h3><ul>
<li><p>初始化父类（使用 <code>super(props)</code> 语句）</p>
</li>
<li><p>初始化 this.state  </p>
</li>
<li><p>为事件处理函数绑定 this </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);<span class="comment">// 必须先执行此句</span></span><br><span class="line">  <span class="comment">// 不要在这里调用 this.setState()</span></span><br><span class="line">  <span class="built_in">this</span>.state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-2-注意"><a href="#1-1-2-注意" class="headerlink" title="1.1.2 注意"></a>1.1.2 注意</h3><ul>
<li> super(props) 必须在其他语句之前</li>
<li>在构造函数中只能直接为 this.state 赋值，其他地方只能通过调用 this.setState 来修改 state </li>
</ul>
<h2 id="1-2-getDerivedStateFromProps"><a href="#1-2-getDerivedStateFromProps" class="headerlink" title="1.2 getDerivedStateFromProps"></a>1.2 getDerivedStateFromProps</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static getDerivedStateFromProps(props, state)</span><br></pre></td></tr></table></figure>

<p>创建组件以及每次组件由于 props 或 state 的改变而重新渲染时，此方法都会被调用。</p>
<p>只要父组件重新被渲染，此函数就会被调用，无论 props 和 states 是否发生变化。</p>
<p>返回值为对象用来更新 state，返回 null 表示不更新 state。</p>
<h3 id="1-2-1-作用"><a href="#1-2-1-作用" class="headerlink" title="1.2.1 作用"></a>1.2.1 作用</h3><p>​    监听  props 变化。 </p>
<h2 id="1-3-render"><a href="#1-3-render" class="headerlink" title="1.3 render"></a>1.3 render</h2><p>render 函数应该为纯函数，使用相同的 state 时，render 的调用结果应该是相同的。</p>
<h3 id="1-3-1-作用"><a href="#1-3-1-作用" class="headerlink" title="1.3.1 作用"></a>1.3.1 作用</h3><p>返回需要在界面展示的 UI 元素。</p>
<p>render 返回值为下面类型之一：</p>
<ul>
<li>react 元素<ul>
<li>自定义组件或 原生的html 元素</li>
</ul>
</li>
<li>数组 或 fragments<ul>
<li>用于返回多个元素</li>
</ul>
</li>
<li>Protals<ul>
<li>可以渲染子节点到不同的 DOM 子树中</li>
</ul>
</li>
<li>字符串或数字<ul>
<li>会被渲染成文本节点</li>
</ul>
</li>
<li>布尔类型或 null<ul>
<li>什么都不渲染（用于支持返回 <code>bool &amp;&amp; &lt;Child /&gt;</code> 的模式）</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-注意"><a href="#1-3-2-注意" class="headerlink" title="1.3.2 注意"></a>1.3.2 注意</h3><p>当 shouldComponentUpdate 返回 false 时，render 则不会被调用。</p>
<h2 id="1-4-componentDidMount"><a href="#1-4-componentDidMount" class="headerlink" title="1.4 componentDidMount"></a>1.4 componentDidMount</h2><p>组件插入 DOM 节点后会执行此函数。</p>
<h3 id="1-4-1-作用"><a href="#1-4-1-作用" class="headerlink" title="1.4.1 作用"></a>1.4.1 作用</h3><p>放置依赖于 DOM 节点的初始化的地方，如网络请求、添加事件监听等。</p>
<h1 id="2-更新"><a href="#2-更新" class="headerlink" title="2 更新"></a>2 更新</h1><p>当组件的 props 或 state 发生变化时，生命周期执行顺序如下，常用的用生命周期用黑体表示：</p>
<ul>
<li><p>static getDerivedStateFromProps(props, state)</p>
</li>
<li><p>shoudComponentUpdate(nextProps， nextState)</p>
</li>
<li><p><strong>render()</strong></p>
</li>
<li><p>getSnapshotBeforeUpdate()</p>
</li>
<li><p>**componentDidUpdate(**prevProps, prevState, snapshot)</p>
</li>
</ul>
<p>下面是即将过时的（17.x 版本时会废弃掉），新代码应避免使用：</p>
<ul>
<li><p>UNSAFE_componentWillUpdate()</p>
</li>
<li><p>UNSAFE_componentWillReceiveProps()</p>
</li>
</ul>
<h2 id="2-1-getDerivedStateFromProps"><a href="#2-1-getDerivedStateFromProps" class="headerlink" title="2.1 getDerivedStateFromProps"></a>2.1 getDerivedStateFromProps</h2><h2 id="2-2-shoudComponentDidUpdate"><a href="#2-2-shoudComponentDidUpdate" class="headerlink" title="2.2 shoudComponentDidUpdate"></a>2.2 shoudComponentDidUpdate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure>

<p>react 会根据此函数的返回值来判断是否需要重新渲染组件，默认返回值为 true，表示需要重新渲染组件。</p>
<h3 id="2-2-1-作用"><a href="#2-2-1-作用" class="headerlink" title="2.2.1 作用"></a>2.2.1 作用</h3><p>此方法可以用来优化性能。</p>
<p>可以使用 <code>PureComponent</code> 组件来替代手动实现此函数，<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少没必要的渲染。</p>
<h3 id="2-2-2-注意"><a href="#2-2-2-注意" class="headerlink" title="2.2.2 注意"></a>2.2.2 注意</h3><ul>
<li>返回 false 不会阻止子组件在 state 更改时的渲染。</li>
<li>后续的 react 版本，当返回 false 时，组件可能已经会被重新渲染</li>
<li>不建议在此函数中进行深层比较，会影响性能</li>
</ul>
<h2 id="2-3-render"><a href="#2-3-render" class="headerlink" title="2.3 render"></a>2.3 render</h2><h2 id="2-4-getSnapshotBeforeUpdate"><a href="#2-4-getSnapshotBeforeUpdate" class="headerlink" title="2.4 getSnapshotBeforeUpdate"></a>2.4 getSnapshotBeforeUpdate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)</span><br></pre></td></tr></table></figure>

<p>此方法的返回值 snapshot（或 null） 会作为 componentDidUpdate 的最后一个参数。</p>
<h3 id="2-4-1-作用"><a href="#2-4-1-作用" class="headerlink" title="2.4.1 作用"></a>2.4.1 作用</h3><p>使得能够在组件发生变化前，获取 dom 的一些信息（如滚动条位置）</p>
<h2 id="2-5-componentDidUpdate"><a href="#2-5-componentDidUpdate" class="headerlink" title="2.5 componentDidUpdate"></a>2.5 componentDidUpdate</h2><p>组件被更新后此函数会被立即调用。</p>
<h3 id="2-1-1-作用"><a href="#2-1-1-作用" class="headerlink" title="2.1.1 作用"></a>2.1.1 作用</h3><p>当组件更新后，可以在此处对 DOM 进行操作。</p>
<h3 id="2-1-2-注意"><a href="#2-1-2-注意" class="headerlink" title="2.1.2 注意"></a>2.1.2 注意</h3><ul>
<li><p>在 componentDidUpdate 中调用 setState 时，必须被包裹在条件语句中个，否则可能会导致死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  // 典型用法（不要忘记比较 props）：</span><br><span class="line">  if (this.props.userID !== prevProps.userID) &#123;</span><br><span class="line">    this.fetchData(this.props.userID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()</p>
</li>
</ul>
<h1 id="3-卸载"><a href="#3-卸载" class="headerlink" title="3 卸载"></a>3 卸载</h1><h2 id="3-1-componentWillUnmount"><a href="#3-1-componentWillUnmount" class="headerlink" title="3.1 componentWillUnmount"></a>3.1 componentWillUnmount</h2><p>此函数在组件卸载销毁之前调用。</p>
<h3 id="3-1-1-作用"><a href="#3-1-1-作用" class="headerlink" title="3.1.1 作用"></a>3.1.1 作用</h3><p>在此方法中执行清理操作，如清除 timer、取消请求、取消监听等。</p>
<h1 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4 错误处理"></a>4 错误处理</h1><p>当渲染过程、生命周期或子组件的构造函数中抛出错误时，会调用如下方法：</p>
<h2 id="4-1-static-getDerivedStateFromError"><a href="#4-1-static-getDerivedStateFromError" class="headerlink" title="4.1 static getDerivedStateFromError()"></a>4.1 static getDerivedStateFromError()</h2><p>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    // 更新 state 使下一次渲染可以显降级 UI</span><br><span class="line">    return &#123; hasError: true &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      // 你可以渲染任何自定义的降级  UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-componentDidCatch"><a href="#4-2-componentDidCatch" class="headerlink" title="4.2 componentDidCatch()"></a>4.2 componentDidCatch()</h2><p>此生命周期在后代组件抛出错误后被调用。 它接收两个参数：</p>
<ol>
<li><code>error</code> —— 抛出的错误。</li>
<li><code>info</code> —— 带有 <code>componentStack</code> key 的对象，其中包含<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html#component-stack-traces">有关组件引发错误的栈信息</a>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    // 更新 state 使下一次渲染可以显示降级 UI</span><br><span class="line">    return &#123; hasError: true &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    // &quot;组件堆栈&quot; 例子:</span><br><span class="line">    //   in ComponentThatThrows (created by App)</span><br><span class="line">    //   in ErrorBoundary (created by App)</span><br><span class="line">    //   in div (created by App)</span><br><span class="line">    //   in App</span><br><span class="line">    logComponentStackToMyService(info.componentStack);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      // 你可以渲染任何自定义的降级 UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react Vritual DOM</title>
    <url>/web/react/react%20%E8%99%9A%E6%8B%9FDom/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Virtual DOM 是一个用来提高应用程序性能的技术。通过将 DOM 对象属性存储在 js 对象中 ，来模拟浏览器真实 DOM ，通过减少 js 线程（也称 js 内核、js 引擎，如 v8 引擎）和 渲染线程之间的通信次数、渲染引擎 的渲染次数 来达到提高性能的目的。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 虚拟Dom virtual dom</tag>
      </tags>
  </entry>
  <entry>
    <title>react事件处理</title>
    <url>/web/react/react%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="内容导图"><a href="#内容导图" class="headerlink" title="内容导图"></a>内容导图</h2><img src="/web/react/react%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/react_event.PNG" class="">

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>事件处理属性名使用驼峰写法（原生html通用写法为小写）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">     &lt;a  href=&quot;#&quot; onClick=&#123;handleClick&#125; &gt; click me &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理函数体内的this"><a href="#事件处理函数体内的this" class="headerlink" title="事件处理函数体内的this"></a>事件处理函数体内的this</h2><p>js的类方法默认不绑定this，可通过下面两种方法绑定this</p>
<p>1、在构造函数中绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">    // 为了在handleClick中使用 `this`，这个绑定是必不可少的</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2、将类方法定义为箭头函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleClick = () =&gt; &#123;//箭头函数会默认绑定this</span><br><span class="line">  console.log(&#x27;this is:&#x27;, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在回调中使用箭头函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  console.log(&#x27;this is:&#x27;, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  // 此语法确保 `handleClick` 内的 `this` 已被绑定。</span><br><span class="line">  // 当回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染，从而导致性能问题  </span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><p>使用e.preventDefault()来阻止默认行为，而不是return false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&#x27;The link was clicked.&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="给事件处理函数传参"><a href="#给事件处理函数传参" class="headerlink" title="给事件处理函数传参"></a>给事件处理函数传参</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、使用箭头函数，需要显式传递e</span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">2、使用bind方式，e会最为最后一个参数默认传进去</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react列表和key</title>
    <url>/web/react/react%E5%88%97%E8%A1%A8%E5%92%8Ckey/</url>
    <content><![CDATA[<img src="/web/react/react%E5%88%97%E8%A1%A8%E5%92%8Ckey/list_key.PNG" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ListItem(props)&#123;</span><br><span class="line">    return &lt;li&gt;&#123;props.num&#125;&lt;/li&gt; ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumList(props)&#123;</span><br><span class="line">    const nums = props.nums;</span><br><span class="line">    const listItems = nums.map(function(num)&#123;</span><br><span class="line">        //重要：map中配置key属性</span><br><span class="line">        return &lt;ListItem key=&#123;num.toString()&#125; num=&#123;num&#125; &gt;&lt;/ListItem&gt;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react条件渲染</title>
    <url>/web/react/react%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<img src="/web/react/react%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/condition_render.PNG" class="">

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react组件</title>
    <url>/web/react/react%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<img src="/web/react/react%E7%BB%84%E4%BB%B6/react_%E7%BB%84%E4%BB%B6.PNG" class="">

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react组合</title>
    <url>/web/react/react%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>react的容器组件可以通过props.children来获取器内部的子组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&#x27; + <span class="attr">props.color</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;props.children&#125;//获取其子组件</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Welcome</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Thank you for visiting our spacecraft!</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将子组件通过容器的prop自定义属性进行传递，然后容器自行在内部组织子组件的位置</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.left&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.right&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">SplitPane</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">left</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        &lt;<span class="attr">Contacts</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      right=&#123;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Chat</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      &#125; /&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react表单</title>
    <url>/web/react/react%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<img src="/web/react/react%E8%A1%A8%E5%8D%95/react_form.PNG" class="">

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>Render Props</title>
    <url>/web/react/render%20Props/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Render Props 就是<strong>函数类型的 Prop</strong>，它的作用是给组件传递渲染逻辑。</p>
<p>接收了 Render Prop 的组件，在内部会通过执行此函数参数来完成自己的渲染逻辑。</p>
<p>通过函数<strong>返回渲染组件</strong> 比 <strong>直接传递渲染组件</strong> 更能灵活的给 <strong>渲染组件</strong>传递属性。比如下面示例中，通过函数可以使渲染组件 <code>h1</code> 更灵活的接收到来自 <code>DataProvider</code> 的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DataProvider 在内部会执行 render 函数来完成自己的渲染逻辑</span></span><br><span class="line"><span class="comment">// render 属性名可以是其他名字，并不必非得叫做 render</span></span><br><span class="line">&lt;DataProvider render=&#123;<span class="function"><span class="params">data</span> =&gt;</span> (       </span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;data.target&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        	//给渲染组件传递参数 ‘world’</span></span><br><span class="line"><span class="xml">        	&#123;this.props.render(&#x27;World&#x27;)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h1><p>可以解决横切关注点（即 组件间逻辑复用问题）。通过 Render Props 能够将组件封装的状态或行为共享给其他组件。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>Render Props 与 React.PureComponent 结合时，有可能使 React.PureCompnent 失去性能优势。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 与上面相同的代码......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouseTracker</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Move the mouse around!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        &#123;/*</span></span><br><span class="line"><span class="xml">          这是不好的！</span></span><br><span class="line"><span class="xml">          每个渲染的 `render` prop的值将会是不同的。</span></span><br><span class="line"><span class="xml">          会使得 React.PureComponent 失去其性能优势</span></span><br><span class="line"><span class="xml">        */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        )&#125;/&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouseTracker</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义为实例方法，</span></span><br><span class="line">  <span class="comment">//`this.renderTheCat` 当我们在渲染中使用它时,它始终指向相同的函数</span></span><br><span class="line">  <span class="function"><span class="title">renderTheCat</span>(<span class="params">mouse</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Move the mouse around!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;this.renderTheCat&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>深入JSX</title>
    <url>/web/react/%E6%B7%B1%E5%85%A5JSX/</url>
    <content><![CDATA[<p>JSX 其实是 React. createElement(component, props, …children) 函数的语法糖。故使用 jsx 前，需先引用 React 库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;//先引用react库</span><br><span class="line">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br><span class="line"></span><br><span class="line">//上面jsx会编译成如下代码：</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;color: &#x27;blue&#x27;, shadowSize: 2&#125;,</span><br><span class="line">  &#x27;Click Me&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="1-JSX-组件标签"><a href="#1-JSX-组件标签" class="headerlink" title="1 JSX 组件标签"></a>1 JSX 组件标签</h2><ul>
<li><p>大写字母开头的 JSX 标签才会被识别为 React 组件</p>
</li>
<li><p>组件标签可以使用点语法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const MyComponents = &#123;</span><br><span class="line">  DatePicker: function DatePicker(props) &#123;</span><br><span class="line">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function BlueDatePicker() &#123;</span><br><span class="line">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件标签不能为表达式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &#x27;./stories&#x27;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  //错误，标签不能为表达式components[props.storyType]</span><br><span class="line">  return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;	</span><br><span class="line">  // 正确！JSX 类型可以是大写字母开头的变量。</span><br><span class="line">  const SpecificStory = components[props.storyType];</span><br><span class="line">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-JSX-中的-Props"><a href="#2-JSX-中的-Props" class="headerlink" title="2 JSX 中的 Props"></a>2 JSX 中的 Props</h2><p>JSX 中的 props 可以为 JS 表达式、字符串，props 属性的默认值为 ture，可以将对象使用展开运算符传递给Props。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用js表达式</span><br><span class="line">&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt;</span><br><span class="line"></span><br><span class="line">//下面两个字符串值等价</span><br><span class="line">&lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt;</span><br><span class="line">&lt;MyComponent message=&#123;&#x27;&lt;3&#x27;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">//下面两者等价，props 属性默认值为 true</span><br><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line">&lt;MyTextBox autocomplete=&#123;true&#125; /&gt;</span><br><span class="line"></span><br><span class="line">//将对象使用展开运算符...传递给Props</span><br><span class="line">function App2() &#123;</span><br><span class="line">  const props = &#123;firstName: &#x27;Ben&#x27;, lastName: &#x27;Hector&#x27;&#125;;</span><br><span class="line">  return &lt;Greeting &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-JSX-中的子元素"><a href="#3-JSX-中的子元素" class="headerlink" title="3 JSX 中的子元素"></a>3 JSX 中的子元素</h2><p>JSX 组件的开始和结束标签之间的内容，会通过 Props.children 传递给组件。</p>
<h3 id="3-1-字符串、表达式、函数"><a href="#3-1-字符串、表达式、函数" class="headerlink" title="3.1 字符串、表达式、函数"></a>3.1 字符串、表达式、函数</h3><p>字符串为子元素时，JSX 会移除行首尾的空格及空行，字符串之间的新行会被压缩为一个空格，下面几种书写方式是等效的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//js表达式为子元素</span><br><span class="line">function Item(props) &#123;</span><br><span class="line">  return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function TodoList() &#123;</span><br><span class="line">  const todos = [&#x27;finish doc&#x27;, &#x27;submit pr&#x27;, &#x27;nag dan to review&#x27;];</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数为子元素</span><br><span class="line">function Repeat(props) &#123;</span><br><span class="line">  let items = [];</span><br><span class="line">  for (let i = 0; i &lt; props.numTimes; i++) &#123;</span><br><span class="line">    items.push(props.children(i));</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ListOfTenThings() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Repeat numTimes=&#123;10&#125;&gt;</span><br><span class="line">      &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125;</span><br><span class="line">    &lt;/Repeat&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-组件"><a href="#3-2-组件" class="headerlink" title="3.2 组件"></a>3.2 组件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line">  &lt;MyFirstComponent /&gt;</span><br><span class="line">  &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;/MyContainer&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-布尔类型、Null-以及-Undefined"><a href="#3-3-布尔类型、Null-以及-Undefined" class="headerlink" title="3.3 布尔类型、Null 以及 Undefined"></a>3.3 布尔类型、Null 以及 Undefined</h3><p>布尔类型、Null 以及 Undefined 将会忽略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以下的 JSX 表达式渲染结果相同：</span><br><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;false&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;null&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;true&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>值得注意的是有一些 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">“falsy” 值</a>，如数字 <code>0</code>，仍然会被 React 渲染。例如，以下代码并不会像你预期那样工作，因为当 <code>props.messages</code> 是空数组时，<code>0</code> 仍然会被渲染：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &amp;&amp;</span><br><span class="line">    &lt;MessageList messages=&#123;props.messages&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，确保 <code>&amp;&amp;</code> 之前的表达式总是布尔值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &gt; 0 &amp;&amp;</span><br><span class="line">    &lt;MessageList messages=&#123;props.messages&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>反之，如果你想渲染 <code>false</code>、<code>true</code>、<code>null</code>、<code>undefined</code> 等值，你需要先将它们<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion">转换为字符串</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  My JavaScript variable is &#123;String(myVariable)&#125;.</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义 Hook</title>
    <url>/web/react/%E8%87%AA%E5%AE%9A%E4%B9%89Hook/</url>
    <content><![CDATA[<h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>在 React 中，主要通过 <code>render props</code> 和 <code>高阶组件</code> 这两种方式来共享组件之间的状态逻辑。</p>
<p><code>自定义Hook</code> 可以在不增加组件的情况下，解决共享组件间状态逻辑的问题。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>自定义Hook</code> 是一个函数，其内部可以调用（只能在顶层调用）其他的 Hook。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。</p>
<p><strong>自定义 Hook 必须以 “use” 开头吗？</strong>必须如此。React用名称来识别Hook，进而去判断Hook使用是否规范。</p>
<p><strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong>不会。<code>自定义Hook</code> 是一种重用<em>状态逻辑</em>的机制(例如设置为订阅并存储当前值)，所以每次使用<code>自定义Hook</code> 时，其中的所有 state 和副作用都是完全隔离的。</p>
<p><strong>自定义 Hook 如何获取独立的 state？</strong>每次<em>调用</em> Hook，它都会获取独立的 state。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义自定义hook</span><br><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用自定义hook</span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  if (isOnline === null) &#123;</span><br><span class="line">    return &#x27;Loading...&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用自定义hook</span><br><span class="line">function FriendListItem(props) &#123;</span><br><span class="line">  const isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;li style=&#123;&#123; color: isOnline ? &#x27;green&#x27; : &#x27;black&#x27; &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>可以在多个 Hook 之间传递消息。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>react 高阶组件</title>
    <url>/web/react/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>高阶组件并不是 React API，只是一种编程技巧而已。</p>
<p>从形式上看，高阶组件是<strong>参数</strong>和<strong>返回值</strong>都是<strong>组件</strong>的<strong>纯函数</strong>。</p>
<p>从功能上看，高阶组件就是给原组件添加功能，将其转变成新的组件。</p>
<h1 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h1><p>HOC 可以用来解决“横切关注点问题”，即不同组件间逻辑复用的问题。</p>
<p>可以将组件间可复用的逻辑使用 HOC 来封装起来，各个组件将自己传递给 HOC 后，HOC 将返回新的添加了特定功能的组件。</p>
<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><h2 id="props-传递"><a href="#props-传递" class="headerlink" title="props 传递"></a>props 传递</h2><p>高阶组件需要将与自己无关的 props 传递给被包装的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 过滤掉 HOC 额外的 props</span><br><span class="line">  const &#123; extraProp, ...passThroughProps &#125; = this.props;</span><br><span class="line"></span><br><span class="line">  // 将 props 注入到被包装的组件中。</span><br><span class="line">  // 通常为 state 的值或者实例方法。</span><br><span class="line">  const injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  // 将 props 传递给被包装组件</span><br><span class="line">  return (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>需要设置新组件的显示名称，以方便调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withSubscription(WrappedComponent) &#123;</span><br><span class="line">  class WithSubscription extends React.Component &#123;/* ... */&#125;</span><br><span class="line">  WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`;</span><br><span class="line">  return WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDisplayName(WrappedComponent) &#123;</span><br><span class="line">  return WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="不要在-render-中调用-HOC"><a href="#不要在-render-中调用-HOC" class="headerlink" title="不要在 render 中调用 HOC"></a>不要在 render 中调用 HOC</h2><p>可以在组件的生命周期方法中调用HOC，但不要在 render 中调用 HOC，否则将导致子树每次渲染都会进行卸载和重新挂载的操作！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">不要在 render 中调用 HOC</span><br><span class="line">*/</span><br><span class="line">render() &#123;</span><br><span class="line">   // 下面语句会使得每次执行 render 函数都会创建一个新的 EnhancedComponent</span><br><span class="line">  // 导致 EnhancedComponentOld !== EnhancedComponentNew</span><br><span class="line">  // 进而导致子树每次渲染都会进行卸载和重新挂载的操作！</span><br><span class="line">    </span><br><span class="line">  const EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  return &lt;EnhancedComponent /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件静态方法"><a href="#组件静态方法" class="headerlink" title="组件静态方法"></a>组件静态方法</h2><p>需要对组件静态方法进行额外复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">被包装后的组件默认没有原始组件的静态方法</span><br><span class="line">可以用下面两种方式进行处理</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//方式一：返回前将静态方法拷贝给包裹后的组件</span><br><span class="line">//可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</span><br><span class="line">import hoistNonReactStatic from &#x27;hoist-non-react-statics&#x27;;</span><br><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方式二：将原始组件的静态方法额外导出，使用的时候再导入</span><br><span class="line">MyComponent.someFunction = someFunction;</span><br><span class="line">export default MyComponent;</span><br><span class="line"></span><br><span class="line">// ...单独导出该方法...</span><br><span class="line">export &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line">// ...并在要使用的组件中，import 它们</span><br><span class="line">import MyComponent, &#123; someFunction &#125; from &#x27;./MyComponent.js&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Refs-不会被传递"><a href="#Refs-不会被传递" class="headerlink" title="Refs 不会被传递"></a>Refs 不会被传递</h2><p>props 中没有包含 ref 属性，故不会被传递，可以通过使用 <code>React.forwardRef</code> API 解决此问题。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>高阶组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/web/redux/Redux/</url>
    <content><![CDATA[<h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h1><p>Redux 是一个可以管理数据的第三方库，能够协助 React 等界面库对数据进行统一管理。</p>
<p>Redux 并不是必须的，当应用中的数据交互比较简单，使用 React 内部的 state、props、context、ref 等可以轻松完成时，就不必使用 Redux 来对数据进行统一管理。 </p>
<h1 id="2-设计核心"><a href="#2-设计核心" class="headerlink" title="2 设计核心"></a>2 设计核心</h1><ul>
<li>唯一数据源</li>
<li>只能通过 Action 触发 Store 的修改</li>
<li>Reducer 是纯函数</li>
</ul>
<h1 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3 中间件"></a>3 中间件</h1><h2 id="3-1-Middleware"><a href="#3-1-Middleware" class="headerlink" title="3.1 Middleware"></a>3.1 Middleware</h2><h3 id="3-1-1-是什么"><a href="#3-1-1-是什么" class="headerlink" title="3.1.1 是什么"></a>3.1.1 是什么</h3><p>在 Redux 中，从形式上讲，Middleware 的格式为 <code>(&#123; getState, dispatch &#125;) =&gt; next =&gt; action</code> 的函数。</p>
<p>在 Redux 中，从功能上讲，Middleware 是 dispatch 之后、reducer 之前的扩展点。</p>
<p>Middleware 最优秀的特性就是可以被链式组合，在一个项目中可以使用多个独立的第三方 middleware。</p>
<h3 id="3-1-2-有什么作用"><a href="#3-1-2-有什么作用" class="headerlink" title="3.1.2 有什么作用"></a>3.1.2 有什么作用</h3><p>在 Redux 中，通过 Middleware 可以扩展 store.dispatch 功能 ，如 可以进行日志记录、创建崩溃报告、调用异步接口或者路由等等。Middleware 最常用的场景就是异步 action。</p>
<h2 id="3-2-redux-thunk"><a href="#3-2-redux-thunk" class="headerlink" title="3.2 redux-thunk"></a>3.2 redux-thunk</h2><h3 id="3-2-1-是什么"><a href="#3-2-1-是什么" class="headerlink" title="3.2.1 是什么"></a>3.2.1 是什么</h3><p>thunk 是包裹了表达式的函数，通过函数来包裹表达式，进而达到延迟/异步执行表达式的目的。</p>
<p>redux-thunk 是 Redux 中，用来延迟执行 dispatch 的中间件。</p>
<h3 id="3-2-2-有什么作用"><a href="#3-2-2-有什么作用" class="headerlink" title="3.2.2 有什么作用"></a>3.2.2 有什么作用</h3><p>redux-thunk 的作用是使 redux 能够异步 dispatch action。</p>
<p>redux-thunk 使 store.dispatch 可以接收函数类型的 actionCreator（dispatch 默认只支持对象类型的 actionCreator），将 strore.dispatch( actionObj ) 包裹在函数类型的 actionCreator 内部，进而达到**异步 dispatch(action) **的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getListDataAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// store.dispatch 接收到此函数类型的 action 时，会直接执行它，并给它传递 dispatch 参数。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">		axios.get(<span class="string">&quot;/api/list.json&quot;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">			dispatch(initListAction(response.data));</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-使用方法"><a href="#3-2-3-使用方法" class="headerlink" title="3.2.3 使用方法"></a>3.2.3 使用方法</h3><ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install redux-thunk</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store/index.js</span></span><br><span class="line"><span class="comment">//基本配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: this API requires redux@&gt;=3.1.0</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store/index.js</span></span><br><span class="line"><span class="comment">// 和 redux-devtools 一起使用时的配置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> composeEnhancers =</span><br><span class="line">    	<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span><br><span class="line">    		? <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;)</span><br><span class="line">    		: compose;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> enhancer = composeEnhancers(applyMiddleware(thunk));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducer, enhancer);</span><br></pre></td></tr></table></figure>

<p>​    </p>
</li>
<li><p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createAction.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getListDataAction 返回的 action 是个函数</span></span><br><span class="line"><span class="comment">// 这个函数被有一个 dispatch 参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getListDataAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">		axios.get(<span class="string">&quot;/api/list.json&quot;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">			dispatch(initListAction(response.data));</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dispatch 一个函数后 store 会立即执行此函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">//getListDataAction() 返回一个函数</span></span><br><span class="line">    <span class="comment">//当 dispatch 接收到一个函数类型的 action 时，会立即执行返回的函数，并传递 dispatch 参数    </span></span><br><span class="line">		store.dispatch(getListDataAction());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-4-源码"><a href="#3-2-4-源码" class="headerlink" title="3.2.4 源码"></a>3.2.4 源码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redux-thunk 中间件核心代码实现******************************</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> dispatch = _ref.dispatch,</span><br><span class="line">	        getState = _ref.getState;</span><br><span class="line">	    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">	      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">	          <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	        <span class="keyword">return</span> next(action);</span><br><span class="line">	      &#125;;</span><br><span class="line">	    &#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> thunk = createThunkMiddleware();<span class="comment">// 注意这里执行了一次</span></span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"><span class="comment">//***************************************************************</span></span><br></pre></td></tr></table></figure>

<h1 id="4-API"><a href="#4-API" class="headerlink" title="4 API"></a>4 API</h1><h2 id="4-1-createStore"><a href="#4-1-createStore" class="headerlink" title="4.1 createStore"></a>4.1 createStore</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createStore(reducer, [preloadedState], enhancer)</span><br></pre></td></tr></table></figure>

<ul>
<li>store.subscribe()</li>
<li>store.dispatch(action)</li>
<li>store.getState()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//createStore 源码中，有 enhancer 参数时的核心代码实现************************</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//...    </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the enhancer to be a function.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*****************************************************************</span></span><br></pre></td></tr></table></figure>



<h2 id="4-2-combineReducers"><a href="#4-2-combineReducers" class="headerlink" title="4.2 combineReducers"></a>4.2 combineReducers</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">combineReducers(reducers)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以合并多个 reducer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rootReducer = combineReducers(&#123;<span class="attr">potato</span>: potatoReducer, <span class="attr">tomato</span>: tomatoReducer&#125;)</span><br><span class="line"><span class="comment">// rootReducer 将返回如下的 state 对象</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">potato</span>: &#123;</span><br><span class="line">    <span class="comment">// ... potatoes, 和一些其他由 potatoReducer 管理的 state 对象 ... </span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tomato</span>: &#123;</span><br><span class="line">    <span class="comment">// ... tomatoes, 和一些其他由 tomatoReducer 管理的 state 对象，比如说 sauce 属性 ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-3-applyMiddlleware"><a href="#4-3-applyMiddlleware" class="headerlink" title="4.3 applyMiddlleware"></a>4.3 applyMiddlleware</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">applyMiddlleware(...middlewares)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数： </p>
<ul>
<li>middlewares 是由中间件组成的数组，middleware 之间无需相互关心</li>
<li>middleware 函数的形式为：({ getState, dispatch }) =&gt; next =&gt; action</li>
</ul>
</li>
<li><p>功能描述：</p>
<ul>
<li>创建一个可以扩展 store 的函数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>添加了 middleware 的 store ，返回值形式为： createStore =&gt; createStore</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//applyMiddlleware 源码*********************************</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将 middlleware 重新放进数组 middlewares 中 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="keyword">new</span> <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">      middlewares[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> store = createStore.apply(<span class="keyword">void</span> <span class="number">0</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">var</span> _dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Dispatching while constructing your middleware is not allowed. &#x27;</span> + <span class="string">&#x27;Other middleware would not be applied to this dispatch.&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">          <span class="attr">getState</span>: store.getState,</span><br><span class="line">          <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _dispatch.apply(<span class="keyword">void</span> <span class="number">0</span>, <span class="built_in">arguments</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  		<span class="comment">/* midddleware 的函数形式：</span></span><br><span class="line"><span class="comment">  		function (_ref) &#123;</span></span><br><span class="line"><span class="comment">  			var dispatch = _ref.dispatch,</span></span><br><span class="line"><span class="comment">  				getState = _ref.getState;</span></span><br><span class="line"><span class="comment">  			return function (next) &#123;</span></span><br><span class="line"><span class="comment">  			  return function (action) &#123;</span></span><br><span class="line"><span class="comment">  				if (typeof action === &#x27;function&#x27;) &#123;</span></span><br><span class="line"><span class="comment">  				  return action(dispatch, getState, extraArgument);</span></span><br><span class="line"><span class="comment">  				&#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  				return next(action);</span></span><br><span class="line"><span class="comment">  			  &#125;;</span></span><br><span class="line"><span class="comment">  			&#125;;</span></span><br><span class="line"><span class="comment">  		&#125;;</span></span><br><span class="line"><span class="comment">  		*/</span></span><br><span class="line">          <span class="keyword">return</span> middleware(middlewareAPI);</span><br><span class="line">        &#125;);</span><br><span class="line">  	  </span><br><span class="line">  	  <span class="comment">/*chain 数组中的函数形式：</span></span><br><span class="line"><span class="comment">  		function (next) &#123;//next 为下一个中间件</span></span><br><span class="line"><span class="comment">  		  return function (action) &#123;</span></span><br><span class="line"><span class="comment">  			if (typeof action === &#x27;function&#x27;) &#123;</span></span><br><span class="line"><span class="comment">  			  return action(dispatch, getState, extraArgument);</span></span><br><span class="line"><span class="comment">  			&#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  			return next(action);</span></span><br><span class="line"><span class="comment">  		  &#125;;</span></span><br><span class="line"><span class="comment">  		&#125;;</span></span><br><span class="line"><span class="comment">  	  */</span></span><br><span class="line">  	  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  	  执行 compose(f, g, h) 返回值为：</span></span><br><span class="line"><span class="comment">        (...args) =&gt; f(g(h(...args))</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        故 _dispatch 为 f(g(h(store.dispatch))</span></span><br><span class="line"><span class="comment">  	  */</span></span><br><span class="line">        _dispatch = compose.apply(<span class="keyword">void</span> <span class="number">0</span>, chain)(store.dispatch);</span><br><span class="line">  	  </span><br><span class="line">        <span class="keyword">return</span> _objectSpread2(&#123;&#125;, store, &#123;</span><br><span class="line">          <span class="attr">dispatch</span>: _dispatch</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//*******************************************************************</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = applyMiddleware(thunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, enhancer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-4-compose"><a href="#4-4-compose" class="headerlink" title="4.4 compose"></a>4.4 compose</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compose( ...functions )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数：</p>
<ul>
<li>多个需要组合的函数，除了最右边的函数，其余函数都只能接收一个参数，每个函数的返回值都会作为相邻左边函数的参数。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回从右到左依次执行函数参数的组合函数，如 <code>compose(f, g, h)  会返回 (...args) =&gt; f(g(h(...args)))</code></li>
</ul>
</li>
<li><p>功能描述：</p>
<ul>
<li>从右到左组合多个函数，使用 compose 来依次执行多个 store enhancer</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//redux 中 compose 核心代码实现*********************************</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, funcs = <span class="keyword">new</span> <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">    funcs[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a(b.apply(<span class="keyword">void</span> <span class="number">0</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//***************************************************************</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-5-bindActionCreator"><a href="#4-5-bindActionCreator" class="headerlink" title="4.5 bindActionCreator"></a>4.5 bindActionCreator</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bindActionCreator(actionCreators, dispatch)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数：</p>
<ul>
<li><p>actionCreators：如下两种类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种： 一个 actionsCreator 的函数</span></span><br><span class="line">initItemAction = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">type</span>: INIT_ITEM,</span><br><span class="line">		value,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：由多个 actionCreator 组成的对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TodoActionCreators <span class="keyword">from</span> <span class="string">&#x27;./TodoActionCreators&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(TodoActionCreators);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   addTodo: Function, </span></span><br><span class="line"><span class="comment">//   removeTodo: Function</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>dispatch： Store.dispatch</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>actionCreators</li>
</ul>
</li>
<li><p>功能描述：</p>
<ul>
<li><p>修改 actionCreators 中每个 actionCreator 的实现，将其包裹在 dispatch 中。修改后的效果为，执行 actionCreator 创建 action时 ，会同时执行 dispatch(action)，使得执行  actionCreator 的返回值为 dispatch(action) 后的结果。</p>
</li>
<li><p>下面例子对比使用 bindActionCreator 前后写法的变化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TodoActionCreators <span class="keyword">from</span> <span class="string">&#x27;./TodoActionCreators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用 bindActionCreator 时,创建完 action, 需要手动执行 dispatch</span></span><br><span class="line"><span class="keyword">let</span> action = TodoActionCreators.addTodo(<span class="string">&#x27;Use Redux&#x27;</span>);</span><br><span class="line">    dispatch(action);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用 bindActionCreator 把 TodoActionCreators 和 dispatch 绑定后，创建完 action 的同时会在内部自动执行 dispatch</span></span><br><span class="line"> <span class="built_in">this</span>.boundActionCreators = bindActionCreators(TodoActionCreators, dispatch);</span><br><span class="line">    boundActionCreators.addTodo(<span class="string">&#x27;Use Redux&#x27;</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码************************************************</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//源码************************************************</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>svg 元素</title>
    <url>/web/svg/svg/</url>
    <content><![CDATA[<h1 id="文本-text-元素"><a href="#文本-text-元素" class="headerlink" title="文本 text 元素"></a>文本 text 元素</h1><p>使用 fill 属性设置 text 字体颜色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">fill</span>=<span class="string">&quot;yellow&quot;</span> &gt;</span>hello<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 x 、y 属性设置 text 位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;30&quot;</span>  &gt;</span>hello<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 text-anchor 属性设置文本对齐方式，属性值有 left 、middle、right。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">text-anchor</span>=<span class="string">&quot;middle&quot;</span> &gt;</span>hello<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="矩形-rect-元素"><a href="#矩形-rect-元素" class="headerlink" title="矩形 rect 元素"></a>矩形 rect 元素</h1><p>设置元素宽高 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rect width=&quot;30&quot; height=&quot;20&quot;  &gt;&lt;/rect&gt;</span><br></pre></td></tr></table></figure>

<p>设置笔画颜色 stroke  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rect stroke=&quot;black&quot;  &gt;&lt;/rect&gt;</span><br></pre></td></tr></table></figure>

<p>设置笔画宽度 stroke-width</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rect stroke-width=&quot;1&quot;  &gt;&lt;/rect&gt;</span><br></pre></td></tr></table></figure>

<p>设置填充颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rect style=&quot;fill:red&quot;  &gt;&lt;/rect&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 声明文件</title>
    <url>/web/ts/TypeScript%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="声明文件是什么"><a href="#声明文件是什么" class="headerlink" title="声明文件是什么"></a>声明文件是什么</h2><p>声明文件是描述 js 库和模块信息的文件。将第三方 js 库的函数和方法体去掉后，只保留导出类型声明，即声明文件的内容。</p>
<h2 id="声明文件的作用"><a href="#声明文件的作用" class="headerlink" title="声明文件的作用"></a>声明文件的作用</h2><p>TypeScript 会使用声明文件来进行类型校验，使用声明文件是为了借用 TypeScript 的类型检查。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>声明文件以 .d.s 为后缀</p>
</li>
<li><p>声明文件或模块的语法格式为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> Module_Name &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TypeScript 引入声明文件语法格式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = &quot; runoob.d.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="CalcThirdPartyJsLib-js-文件代码"><a href="#CalcThirdPartyJsLib-js-文件代码" class="headerlink" title="CalcThirdPartyJsLib.js 文件代码"></a>CalcThirdPartyJsLib.js 文件代码</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Runoob;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Runoob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Calc = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Calc</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">    Calc.prototype.doSum = <span class="function"><span class="keyword">function</span> (<span class="params">limit</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= limit; i++) &#123; </span><br><span class="line">            sum = sum + i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">    Runoob.Calc = Calc; </span><br><span class="line">    <span class="keyword">return</span> Calc; </span><br><span class="line">&#125;)(Runoob || (Runoob = &#123;&#125;)); </span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Runoob.Calc();</span><br></pre></td></tr></table></figure>

<h3 id="Calc-d-ts-文件代码"><a href="#Calc-d-ts-文件代码" class="headerlink" title="Calc.d.ts 文件代码"></a>Calc.d.ts 文件代码</h3><p>如果想在 TypeScript 中引用上面的代码，则需要创建声明文件 Calc.d.ts，代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> Runoob &#123; </span><br><span class="line">   <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> </span>&#123; </span><br><span class="line">      doSum(limit:<span class="built_in">number</span>) : <span class="built_in">number</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CalcTest-ts-文件代码"><a href="#CalcTest-ts-文件代码" class="headerlink" title="CalcTest.ts 文件代码"></a>CalcTest.ts 文件代码</h3><p>把声明文件加入到 TypeScript 中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = &quot;Calc.d.ts&quot; /&gt; </span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Runoob.Calc(); </span><br><span class="line"><span class="comment">// obj.doSum(&quot;Hello&quot;); // 编译错误</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.doSum(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>typescript</category>
      </categories>
  </entry>
  <entry>
    <title>Shimming 预置依赖</title>
    <url>/web/webpack/Shimming%20%E9%A2%84%E7%BD%AE%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>shim 用来处理老旧的库，给库设置全局模块、重置 this 变量为 window、自动添加 exports 语句等。</p>
<h1 id="设置全局模块"><a href="#设置全局模块" class="headerlink" title="设置全局模块"></a>设置全局模块</h1><p>使用 ProvidePlugin 设置全局模块</p>
<h1 id="重置模块内-this-变量"><a href="#重置模块内-this-变量" class="headerlink" title="重置模块内 this 变量"></a>重置模块内 this 变量</h1><p>使用 imports-loader 来重置匹配模块内 this 取值。</p>
<h1 id="自动添加-exports-语句"><a href="#自动添加-exports-语句" class="headerlink" title="自动添加 exports 语句"></a>自动添加 exports 语句</h1><p>使用 exports-loader 来自动给模块添加 exports 语句。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack Plugins</title>
    <url>/web/webpack/webpack%20Plugins/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Plugins 本质上是一个包含 <code>apply</code> 方法的类，<code>apply</code> 会被 webpack compiler 调用。</p>
<p>在 <code>apply</code> 方法中可以访问到 compiler 对象，进而对其挂上钩子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">&#x27;ConsoleLogOnBuildWebpackPlugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    compiler.hooks.run.tap(pluginName, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;webpack 构建过程开始！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConsoleLogOnBuildWebpackPlugin;</span><br></pre></td></tr></table></figure>

<p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中重复使用。</p>
<h1 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h1><p>plugin 可于执行更广泛的任务，如 打包优化、资源管理、注入环境变量。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol>
<li>如果是外部 Plugins，则需要先安装</li>
<li>然后在 webpack 中 require 进来</li>
<li>通过 new 创建插件实例，将其添加到 plugins 数组中</li>
<li>可根据不同目的多次使用同一个插件</li>
<li>使用对象给插件实例传递参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); // 通过 npm 安装</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;); // 访问内置的插件</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./path/to/my/entry/file.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;my-first-webpack.bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(js|jsx)$/,</span><br><span class="line">        use: &#x27;babel-loader&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.ProgressPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &#x27;./src/index.html&#x27;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack loader</title>
    <url>/web/webpack/webpack%20loader/</url>
    <content><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>loader 本质是一个导出函数的模块。</p>
<h2 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h2><p>loader 的作用就是对源码进行转换（在 import 或 load 时进行预处理），可以通过 loader 将 webpack 不认识的资源转换为 webpack 可以识别的。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="配置文件（推荐）"><a href="#配置文件（推荐）" class="headerlink" title="配置文件（推荐）"></a>配置文件（推荐）</h3><p>在 webpack 配置文件（默认为 webpack.config.js）中进行配置。</p>
<p>module.rules 字段用来配置 loader。配置多个 loader 时，执行顺序为从后向前（从右到左）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [<span class="comment">// 配置 loader</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="comment">//执行顺序为： sass-loader css-loader style-loader</span></span><br><span class="line">          <span class="comment">// style-loader</span></span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">          <span class="comment">// css-loader</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">modules</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// sass-loader</span></span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h3><ul>
<li>可以通过 <code>import</code> 语句来导入 loader，多个 loader 间用<code>!</code> 分隔。loader 会相对于当前路径进行解析。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Styles from &#x27;style-loader!css-loader?modules!./styles.css&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过为内联 <code>import</code> 语句添加前缀，可以覆盖 <a href="https://webpack.docschina.org/configuration">配置</a> 中的所有 loader, preLoader 和 postLoader：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 ! 前缀，将禁用所有已配置的 normal loader(普通 loader)</span></span><br><span class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">&#x27;!style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 -! 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders</span></span><br><span class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">&#x27;-!style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 !! 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）</span></span><br><span class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">&#x27;!!style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p>通过 CLI 使用 loader：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">对 .jade 文件使用 pug-loader，以及对 .css 文件使用 style-loader 和 css-loader</span></span><br><span class="line">webpack --module-bind pug-loader --module-bind &#x27;css=style-loader!css-loader&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作。</li>
<li>loader 可以通过 <code>options</code> 对象配置（仍然支持使用 <code>query</code> 参数来设置选项，但是这种方式已被废弃）。</li>
<li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>loader 遵循标准 <a href="https://webpack.docschina.org/concepts/module-resolution/">模块解析</a> 规则。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack tree shaking</title>
    <url>/web/webpack/webpack%20tree%20shaking/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>tree shaking 用于移除 js 上下文中未引用的代码。</p>
<p>tree shaking 依赖于 es6 模块语法（ import 、 export）的静态结构特性。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>1、使用 es6 模块语法（即 import export）</p>
<p>2、确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块</p>
<p>3、在项目 <code>package.json</code> 文件中，添加一个 “sideEffects” 属性</p>
<p>4、通过将 <code>mode</code> 选项设置为 <a href="https://webpack.docschina.org/concepts/mode/#mode-production"><code>production</code></a>，启用 minification(代码压缩) 和 tree shaking。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube(<span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: &#123;</span><br><span class="line">		<span class="attr">main</span>: path.resolve(__dirname, <span class="string">&quot;src/js/index.js&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">filename</span>: <span class="string">&quot;./js/[name].[contenthash:5].js&quot;</span>,</span><br><span class="line">		<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">	<span class="attr">optimization</span>: &#123;</span><br><span class="line">		<span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">// 会用注释标记哪些导出被使用了，一些优化代码的插件会使用此注释进行 treeshaking</span></span><br><span class="line">		<span class="attr">minimize</span>: <span class="literal">true</span>, <span class="comment">//设置为 true 时，webpack 会使用 TerserPlugin 压缩 bundle，会删除 usedExports 标记的未使用导出</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// 设置成 production 时，会默认设置 usedExports 和 minimize 为 true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://webpack.js.org/guides/tree-shaking/">https://webpack.js.org/guides/tree-shaking/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/40052192">https://zhuanlan.zhihu.com/p/40052192</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32831172">https://zhuanlan.zhihu.com/p/32831172</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>webpack 性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 中 DefinePlugin 和 ProvidePlugin 区别</title>
    <url>/web/webpack/webpack%20%E4%B8%AD%20DefinePlugin%20%E5%92%8C%20ProvidePlugin%20%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h1><p>DefinePlugin 是 webpack 内置插件，使用此插件可以设置全局变量。常用于区分开发模块和生产模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [</span><br><span class="line">		<span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">			<span class="comment">// DefinePlugin 内部通过直接替换的方式替换变量，所以需要用 JSON.stringify 来包裹，否则会被替换成 dev 而不是 &quot;dev&quot;</span></span><br><span class="line">			<span class="attr">PRODUCTIION</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&quot;dev&quot;</span>),</span><br><span class="line">		&#125;),</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模块文件中直接使用变量 PRODUCTIION</span></span><br><span class="line"><span class="keyword">if</span> (PRODUCTIION === <span class="string">&quot;dev&quot;</span>) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;pro&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h1><p>ProvidePlugin 是 webpack 的内置插件，使用此插件可以设置全局模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [</span><br><span class="line">		<span class="comment">//当至少有模块使用 $zz 时，webpack 才会将 jquery 设置为全局模块并参与打包</span></span><br><span class="line">		<span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">			<span class="attr">$zz</span>: <span class="string">&quot;jquery&quot;</span>,</span><br><span class="line">		&#125;),</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$zz(<span class="string">&quot;body&quot;</span>).text(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 代码分离</title>
    <url>/web/webpack/webpack%20%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="代码分离是什么"><a href="#代码分离是什么" class="headerlink" title="代码分离是什么"></a>代码分离是什么</h1><p>代码分离指将代码分离到不同的 bundle 中。</p>
<h1 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h1><p>代码分离后就可以按需加载或并行加载这些文件。</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ol>
<li>入口起点</li>
<li>使用 <code>SplitChunksPlugin</code>  去重和分离 chunk</li>
<li>动态导入（也叫 懒加载、延迟加载）</li>
</ol>
<h2 id="1、入口起点"><a href="#1、入口起点" class="headerlink" title="1、入口起点"></a>1、入口起点</h2><p>在 webpack.config.js 中配置多个 entry 入口，能够分离代码，进而产生多个 bundle。</p>
<p>缺点： 多个 entry 引用的重复文件会被重复打包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: &#123;<span class="comment">//配置多个 entry 入口</span></span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">another</span>: <span class="string">&#x27;./src/another-module.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2、使用-SplitChunksPlugin"><a href="#2、使用-SplitChunksPlugin" class="headerlink" title="2、使用 SplitChunksPlugin"></a>2、使用 SplitChunksPlugin</h2><p><code>SplitChunkksPlugin</code> 可以将多个 entry 入口中的公共模块提取出来，达到去重公共模块的效果。</p>
<p>webpack 的 <code>optimization.splitChunks</code> 选项默认使用 <code>SplitChunkPlugin</code> 插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">	mode: &quot;development&quot;,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		index: &quot;./src/js/index.js&quot;,</span><br><span class="line">		other: &quot;./src/js/other.js&quot;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: &quot;./js/[name].[contenthash:5].js&quot;,</span><br><span class="line">		path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">	&#125;,</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">			chunks: &quot;all&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、动态导入"><a href="#3、动态导入" class="headerlink" title="3、动态导入"></a>3、动态导入</h2><p><strong>动态导入（也叫 懒加载 或 延迟加载）</strong>，这个加载方式建立在<strong>代码分离</strong>的基础上，使得一些 trunk 可以在浏览器空闲 或 业务逻辑需要时才被加载。</p>
<p>懒加载的作用是 <strong>为了提高应用的初始加载速度</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: &#123;</span><br><span class="line">		<span class="attr">main</span>: <span class="string">&quot;./src/js/index.js&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">filename</span>: <span class="string">&quot;[name].[contenthash:10].js&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;The print.js module has loaded! See the network tab in dev tools...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Button Clicked: Here\&#x27;s &quot;some text&quot;!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;hello add&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码在 onclick 事件中通过 import 语句动态加载模块，从而提高首屏加载速度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> br = <span class="built_in">document</span>.createElement(<span class="string">&quot;br&quot;</span>);</span><br><span class="line"></span><br><span class="line">	button.innerHTML = <span class="string">&quot;Click me and look at the console!&quot;</span>;</span><br><span class="line">	element.appendChild(br);</span><br><span class="line">	element.appendChild(button);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 onclick 事件中通过 import 语句动态加载模块，从而提高首屏加载速度</span></span><br><span class="line">	button.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span></span><br><span class="line">		<span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;print&quot; */</span> <span class="string">&quot;./print&quot;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="built_in">module</span>); <span class="comment">//&#123;add:f add(), default: ()=&gt;&#123;...&#125;,...&#125;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> print = <span class="built_in">module</span>.default;</span><br><span class="line"></span><br><span class="line">			print();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(component());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>webpack 性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 中 imports-loader exports-loader expose-loader 区别</title>
    <url>/web/webpack/webpack%20%E4%B8%AD%20imports-loader%20exports-loader%20expose-loader%20%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="1-imports-loader"><a href="#1-imports-loader" class="headerlink" title="1 imports-loader"></a>1 imports-loader</h1><h2 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h2><p>通过 imports-loader 能够给匹配文件自动导入配置模块。比如，对于某个依赖 jquery 的 a.js，通过 imports-loader 导入 a.js 时，webpack 会自动在 a.js 文件中添加 import jquery 语句，而省去了手动导入 jquery 的过程。</p>
<h2 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install imports-loader --save-dev</span><br></pre></td></tr></table></figure>

<h2 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h2><h3 id="1-3-1-inline-方式"><a href="#1-3-1-inline-方式" class="headerlink" title="1.3.1 inline 方式"></a>1.3.1 inline 方式</h3><p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;imports-loader?imports=default|jquery|$!./lib.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面语句会在 lib.js 中添加如下代码:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// import $ from &quot;jquery&quot;;</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-配置文件方式"><a href="#1-3-2-配置文件方式" class="headerlink" title="1.3.2 配置文件方式"></a>1.3.2 配置文件方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">	<span class="attr">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="built_in">require</span>.resolve(<span class="string">&quot;./src/index.js&quot;</span>),</span><br><span class="line">				<span class="attr">use</span>: &#123;</span><br><span class="line">					<span class="attr">loader</span>: <span class="string">&quot;imports-loader&quot;</span>,</span><br><span class="line">					<span class="attr">options</span>: &#123;</span><br><span class="line">						<span class="attr">imports</span>: [<span class="string">&quot;default jquery $&quot;</span>],</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.js 中会添加如下语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="2-exports-loader"><a href="#2-exports-loader" class="headerlink" title="2 exports-loader"></a>2 exports-loader</h1><h2 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h2><p>通过 exports-loader 可以在源码中添加 exports 语句。适用于源码中没有 exports 语句的旧库。</p>
<h2 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install exports-loader --save-dev</span><br></pre></td></tr></table></figure>

<h2 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h2><h3 id="2-3-1-inline-方式"><a href="#2-3-1-inline-方式" class="headerlink" title="2.3.1 inline 方式"></a>2.3.1 inline 方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;exports-loader?exports=myFunction!./file.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 上面语句会在 file.js 源码中添加如下语句:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export &#123; myFunction &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-配置文件方式"><a href="#2-3-2-配置文件方式" class="headerlink" title="2.3.2 配置文件方式"></a>2.3.2 配置文件方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="built_in">require</span>.resolve(<span class="string">&#x27;./path/to/vendor.js&#x27;</span>),</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;exports-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">          <span class="attr">exports</span>: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">//vender.js 中会添加如下语句</span></span><br><span class="line"><span class="keyword">export</span> &#123; Foo &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-expose-loader"><a href="#3-expose-loader" class="headerlink" title="3 expose-loader"></a>3 expose-loader</h1><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><p>expose-loader 可以将模块添加到全局对象，并使模块参与打包。</p>
<h2 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install expose-loader --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-inline-方式"><a href="#3-2-1-inline-方式" class="headerlink" title="3.2.1 inline 方式"></a>3.2.1 inline 方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;expose-loader?exposes[]=$&amp;exposes[]=jQuery!jquery&#x27;</span>;</span><br><span class="line"><span class="comment">//上面代码添加 $ 和 jQuery 变量到全局对象上，在控制台可以通过 window.$ 来使用jquery</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-2-配置文件方式"><a href="#3-2-2-配置文件方式" class="headerlink" title="3.2.2 配置文件方式"></a>3.2.2 配置文件方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> 	<span class="attr">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="built_in">require</span>.resolve(<span class="string">&quot;jquery&quot;</span>),</span><br><span class="line">				<span class="attr">loader</span>: <span class="string">&quot;expose-loader&quot;</span>,</span><br><span class="line">				<span class="attr">options</span>: &#123;</span><br><span class="line">					<span class="attr">exposes</span>: [<span class="string">&quot;$zz&quot;</span>, <span class="string">&quot;jQuery&quot;</span>],</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须用 import 语句导入 $zz 才能使 $zz 添加到全局 window 上</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> $zz <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./test.js&quot;</span>; <span class="comment">//test.js 无需再使用 import 语句导入 $zz</span></span><br><span class="line"></span><br><span class="line">$zz(<span class="string">&quot;#test1&quot;</span>).text(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js 无需再使用 import 语句导入 $zz</span></span><br><span class="line">$zz(<span class="string">&quot;#test2&quot;</span>).text(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 中 noParse extertals IgnorePlugin 区别</title>
    <url>/web/webpack/webpack%20%E4%B8%AD%20noParse%20extertals%20ignorePlugin%20%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><code>noParse</code> 是 module 的配置项，通过配置 <code>webpack.module.noParse</code> 可以让 webpack 不对匹配到的文件进行依赖解析，进而提高打包效率。</p>
<p>只是忽略解析匹配到的文件，匹配到的文件<strong>依旧会参与打包</strong>。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>如果公共库中没有依赖其他模块（即没有导入其他模块，如 jquery 中没有导入其他模块），则可以通过 noParse 来配置此公共库，使 webpack 不会对其进行依赖解析，来提高打包效率。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: &#123;</span><br><span class="line">		<span class="attr">main</span>: path.resolve(__dirname, <span class="string">&quot;src/js/index.js&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">filename</span>: <span class="string">&quot;./js/[name].[contenthash:5].js&quot;</span>,</span><br><span class="line">		<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">module</span>: &#123;</span><br><span class="line">		<span class="attr">noParse</span>: <span class="regexp">/lodash/</span>, <span class="comment">//不会解析 lodash 文件中的依赖库，但打包结果中依旧包含 lodash</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p><code>externals</code> 是 webpack 顶层配置项，通过配置 <code>webpack.externals</code> 可以使 webpack <strong>忽略对匹配文件的打包</strong>，进而提高打包效率。</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于通过 CDN 引用的公共库，可以通过 <code>webpack.externals</code>  来进行配置，使其不参与 webpack 的打包。        library 的开发者也可以使用此 externals 来配置不需要参与打包的其他依赖。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="attr">externals</span>: &#123;</span><br><span class="line">		<span class="attr">jquery</span>: <span class="string">&quot;jQuery&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html文件 --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用 jquery 的文件</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h1><h2 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h2><p><code>IngroePlugin</code> 是 webpack 的内置插件，作用和 <code>webpack.externals</code> 类似，都可以让匹配到的文件<strong>不参与打包</strong>。 </p>
<h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于如 moment 等第三方库，内置一些了我们用不到的文件，可以使用 <code>IngorePlugin</code> 来使这些无用文件不参与打包。</p>
<h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">//不会默认加载 moment 库中 ./local 目录下的文件</span></span><br><span class="line">		<span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, <span class="regexp">/moment/</span>),</span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 moment 的库，需要手动引入所需的语言包</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&quot;moment&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动引入所需要的语言包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;moment/locale/zh-cn&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置语言</span></span><br><span class="line">moment.locale(<span class="string">&quot;zh-cn&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>noParse</tag>
        <tag>externals</tag>
        <tag>IgnorePlugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 处理 CSS</title>
    <url>/web/webpack/webpack%20%E5%A4%84%E7%90%86%20CSS/</url>
    <content><![CDATA[<p>在 webpack 中，根据项目需要，可能会需要下面 loader 来处理 css。</p>
<h1 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h1><p>css-loader 可以解析 import require @import url 对 css 文件的引用，将 css 文件转换成 webpack 可以识别的 js 模板，转换后内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Imports</span></span><br><span class="line"><span class="keyword">var</span> ___CSS_LOADER_API_IMPORT___ = __webpack_require__(<span class="comment">/*! ../../node_modules/css-loader/dist/runtime/api.js */</span> <span class="string">&quot;../node_modules/css-loader/dist/runtime/api.js&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span> = ___CSS_LOADER_API_IMPORT___(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// Module</span></span><br><span class="line"><span class="built_in">exports</span>.push([<span class="built_in">module</span>.i, <span class="string">&quot;body &#123;\r\n\tbackground-color: red;\r\n&#125;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>]);</span><br><span class="line"><span class="comment">// Exports</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">exports</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/i,</span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h1><p>可以将转换后的 css 文件插入到 html 文件中，默认以 style 的方式插入。</p>
<ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<ul>
<li><p>默认以 style 形式插入 html 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">				use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>如果想以 link 的方式插入，则可以参考如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">				use: [</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">						<span class="attr">options</span>: &#123;</span><br><span class="line">							<span class="attr">injectType</span>: <span class="string">&quot;linkTag&quot;</span>,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="string">&quot;file-loader&quot;</span>,<span class="comment">//css-loader-&gt;file-loader</span></span><br><span class="line">				],</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h1><p>可以将 less 转换成 css 。</p>
<ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install less-loader --save-dev</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">			test: /\.css$/,</span><br><span class="line">			use: [&quot;style-loader&quot;, &quot;css-loader&quot;],</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			test: /\.less$/,</span><br><span class="line">			use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;],</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h1><p>使用 postcss-loader 可以对 css 进行后置处理，如添加兼容各个浏览器的前缀等。 </p>
<p>postcss-loader 内部其实是通过其他插件完成各个功能的。</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i postcss-import postcss-preset-env cssnano postcss-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用</p>
<ul>
<li><p>项目根目录创建 postcss.config.js 配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> <span class="comment">//	parser: &quot;sugarss&quot;,</span></span><br><span class="line"> 	<span class="attr">plugins</span>: &#123;</span><br><span class="line">         <span class="comment">//postcss-import：通过 @import，整合多个 CSS 文件</span></span><br><span class="line"> 		<span class="string">&quot;postcss-import&quot;</span>: &#123;&#125;,</span><br><span class="line">         <span class="comment">//postcss-preset-env： 支持现代的 css 语法。</span></span><br><span class="line"> 		<span class="string">&quot;postcss-preset-env&quot;</span>: &#123;&#125;,</span><br><span class="line">         <span class="comment">//cssnano： 可以压缩 css 代码</span></span><br><span class="line"> 		<span class="attr">cssnano</span>: &#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>webpack.config.js 中配置 postcss-loader</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/\.(less|css)$/</span>,</span><br><span class="line">				use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="MiniCssExtractPlugin"><a href="#MiniCssExtractPlugin" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h1><p>使用 MiniCssExtractPlugin 可以将 CSS 提取到单独的文件。为每个包含 CSS 的文件单独创建一个 CSS 文件。</p>
<p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="comment">//1、引入插件</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">	<span class="attr">output</span>: &#123;</span><br><span class="line">		<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">	<span class="attr">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/\.(less|css)$/</span>,</span><br><span class="line">				use: [</span><br><span class="line">					MiniCssExtractPlugin.loader, <span class="comment">//2、使用插件的 loader</span></span><br><span class="line">					<span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">					<span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">					<span class="string">&quot;less-loader&quot;</span>,</span><br><span class="line">				],</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			<span class="attr">filenmame</span>: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">			<span class="attr">template</span>: <span class="string">&quot;./tpl.html&quot;</span>,</span><br><span class="line">		&#125;),</span><br><span class="line">		<span class="keyword">new</span> MiniCssExtractPlugin(),<span class="comment">//3、创建插件实例</span></span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://segmentfault.com/a/1190000020293006">https://segmentfault.com/a/1190000020293006</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack css</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 处理 JS</title>
    <url>/web/webpack/webpack%20%E5%A4%84%E7%90%86%20JS/</url>
    <content><![CDATA[<h3 id="转译-JS"><a href="#转译-JS" class="headerlink" title="转译  JS"></a>转译  JS</h3><ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#babel转译 核心代码 和 所需插件集合</span></span><br><span class="line">npm install -D babel-loader @babel/core @babel/preset-env</span><br><span class="line"></span><br><span class="line"><span class="comment">#支持 @decorators 语法</span></span><br><span class="line">npm install -D @babel/plugin-proposal-decorators</span><br><span class="line"></span><br><span class="line"><span class="comment">#支持类语法</span></span><br><span class="line">npm install -D @babel/plugin-proposal-class-properties</span><br><span class="line"></span><br><span class="line"><span class="comment">#复用 babel 生成的各种 helper 函数，并提供沙箱环境避免污染全局</span></span><br><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime-corejs3</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">				exclude: <span class="regexp">/(node_module|bower_components)/</span>,</span><br><span class="line">				use: &#123;</span><br><span class="line">					<span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">					<span class="attr">options</span>: &#123;</span><br><span class="line">						<span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">						<span class="attr">plugins</span>: [</span><br><span class="line">							[<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">							[<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>, &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">							[<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>, &#123; <span class="attr">corejs</span>: <span class="number">3</span> &#125;],</span><br><span class="line">						],</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="校验-JS"><a href="#校验-JS" class="headerlink" title="校验 JS"></a>校验 JS</h3><ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -D eslint eslint-loader babel-eslint</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        enforce: &#x27;pre&#x27;,</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        loader: &#x27;eslint-loader&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>在 .eslintrc.json 中，将 babel-eslint 配置成 eslint 的解析器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class="line">	&quot;parserOptions&quot;: &#123;</span><br><span class="line">		//...</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 处理图片</title>
    <url>/web/webpack/webpack%20%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>使用图片的场景：</p>
<ul>
<li>在 JS 中创建图片： <code>new Image()</code></li>
<li>在 CSS 中使用背景图片：<code>background: url(&#39;image.png&#39;)</code></li>
<li>在 HTML 中通过 src 等属性引用图片 <code>&lt;img src=&quot;image.png&quot; &gt;</code></li>
</ul>
<h2 id="1-file-loader"><a href="#1-file-loader" class="headerlink" title="1 file-loader"></a>1 file-loader</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p><code>file-loader</code> 会解析导入文件语句 <code>import</code> / <code>require</code> ，将 url 参数文件输出到 output 目录。</p>
<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="1-3-配置"><a href="#1-3-配置" class="headerlink" title="1.3 配置"></a>1.3 配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h3><p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file-loader 会将 test.png 输出到 output 目录，并取一个新名字，img 为新创建图片的名字</span></span><br><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">&quot;./test.png&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;image name:&quot;</span>, img);</span><br><span class="line">image.src = img;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#hello</span> &#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;./test.png&quot;</span>);</span><br><span class="line">	<span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-url-loader"><a href="#2-url-loader" class="headerlink" title="2 url-loader"></a>2 url-loader</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p><code>url-loader</code> 内部默认使用 <code>file-loader</code>。当文件小于 limit 属性设置时，可以将文件编译成 DataURI（可以减少 HTTP 请求），否则将使用 <code>file-loader</code> 来编译文件。</p>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	<span class="attr">rules</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|git)$/i</span>,</span><br><span class="line">			use: [</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">loader</span>: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">					<span class="attr">options</span>: &#123;</span><br><span class="line">						<span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>, <span class="comment">//当图片小于  8 * 1024 字节时，将图片转换成 base64，否则使用 file-loader 处理</span></span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			],</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h3><p>同 <code>file-loader</code></p>
<h2 id="3-html-loader"><a href="#3-html-loader" class="headerlink" title="3 html-loader"></a>3 html-loader</h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h3><p><code>html-loader</code> 可以将 HTML 导出为字符串，并支持压缩。</p>
<p>对于 HTML 文件中的可加载属性（如 <code>&lt;img src=&quot;image.png&quot;&gt;</code>），<code>html-loader</code> 会将其转换为导入语句（如  <code>const img = require (&#39;./image.png&#39;)</code> 或 <code>import img from &quot;./image.png&quot;&quot;</code> ）。</p>
<p>默认支持如下标签和属性：</p>
<ul>
<li><code>audio</code> 标签的 <code>src</code> 属性</li>
<li><code>embed</code> 标签的 <code>src</code> 属性</li>
<li><code>img</code> 标签的 <code>src</code> 属性</li>
<li><code>img</code> 标签的 <code>srcset</code> 属性</li>
<li><code>input</code> 标签的 <code>src</code> 属性</li>
<li><code>link</code> 标记的 <code>href</code> 属性（仅适用于样式表）</li>
<li><code>object</code> 标签的 <code>data</code> 属性</li>
<li><code>script</code> 标签的 <code>src</code> 属性</li>
<li><code>source</code> 标签的 <code>src</code> 属性</li>
<li><code>source</code> 标签的 <code>srcset</code> 属性</li>
<li><code>track</code> 标记的 <code>src</code> 属性</li>
<li><code>video</code> 标签的 <code>poster</code> 属性</li>
<li><code>video</code> 代码的 <code>src</code> 属性</li>
</ul>
<h3 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-loader</span><br></pre></td></tr></table></figure>

<h3 id="3-3-配置"><a href="#3-3-配置" class="headerlink" title="3.3 配置"></a>3.3 配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">	<span class="attr">rules</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="regexp">/\.html/</span>,</span><br><span class="line">			use: <span class="string">&quot;html-loader&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="3-4-使用"><a href="#3-4-使用" class="headerlink" title="3.4 使用"></a>3.4 使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello html-webpack-plugin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>hello <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/src/test.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 打包过程调试</title>
    <url>/web/webpack/webpack%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>webpack 本质上是 node 应用，所以可以使用 node 调试方法对 webpack 打包过程进行调试：</p>
<ol>
<li><p>进入项目目录，在控制台执行如下命令启动调试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node --inspect-brk .\node_modules\webpack\bin\webpack.js</span><br></pre></td></tr></table></figure></li>
<li><p>在 chrome 地址栏输入 chrome://inspect/#devices </p>
<img src="/web/webpack/webpack%20%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%E8%B0%83%E8%AF%95/chrome_inspect.png" class=""></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack 打包过程调试</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 模块路径解析规则</title>
    <url>/web/webpack/webpack%20%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>webpack 使用 <code>enhanced-resolve</code> 来解析模块路径。</p>
<h1 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;/home/me/file&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;C:\\Users\\me\\file&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于绝对路径，webpack 不会对其进行解析。</p>
<h1 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../src/file1&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./file2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于相对路径，webpack 会使用当前 import 语句所在文件的路径作为上下文路径进行解析。</p>
<h1 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;module/lib/file&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>webpack 首先会在 resolve.modules（ webpack 配置项） 配置的目录中进行检索。</p>
<p>解析出路径后，可能会是文件或文件夹：</p>
<ul>
<li>文件<ul>
<li>有扩展名时，直接将文件打包</li>
<li>没扩展名时，使用 <a href="https://webpack.docschina.org/configuration/resolve/#resolveextensions"><code>resolve.extensions</code></a> （webpack 配置项）来解析文件扩展名</li>
</ul>
</li>
<li>文件夹<ol>
<li>包含 package.json 文件时，会在此文件中查找第一个符合 <a href="https://webpack.docschina.org/configuration/resolve/#resolve-mainfields"><code>resolve.mainFields</code></a> 配置的字段来确定文件路径</li>
<li>不包含 package.json 或 <a href="https://webpack.docschina.org/configuration/resolve/#resolvemainfields"><code>resolve.mainFields</code></a> 没有返回有效路径，则会根据 <a href="https://webpack.docschina.org/configuration/resolve/#resolvemainfiles"><code>resolve.mainFiles</code></a> 配置项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。</li>
<li>然后使用 <a href="https://webpack.docschina.org/configuration/resolve/#resolveextensions"><code>resolve.extensions</code></a> 选项，以类似的方式解析文件扩展名。</li>
</ol>
</li>
</ul>
<h1 id="loader-解析"><a href="#loader-解析" class="headerlink" title="loader 解析"></a>loader 解析</h1><p>loader 的解析规则也遵循上面的规范。但是 <a href="https://webpack.docschina.org/configuration/resolve/#resolveloader"><code>resolveLoader</code></a> 配置项可以为 loader 设置独立的解析规则。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 自动生成 html 模板文件</title>
    <url>/web/webpack/webpack%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%20html%20%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过 <code>html-webpack-plugin</code> 插件，可以自动生成 html 文件到 output.path 目录，并将 webpack输出的 bundle 文件自动插入到 html 文件中。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、引入 html-webpack-plugin</span></span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;index_bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2、在 plugins 中创建插件实例</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面两个步骤会自动在 dist 目录生成 index.html 文件，并将 webpack 生成的 bundle.js 插入到 index.hml 中，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>在实际工作场景中，我们很少使用 html-webpack-plugin 默认的 html 模板文件，为了使生成的 html 文件中的内容更符合项目的需要，通常会重新生成一份 html 文件，然后通过插件参数 <code>template</code> 配置成插件使用的 html 模板。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、引入 html-webpack-plugin</span></span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;index_bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2、在 plugins 中创建插件实例</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="comment">// 3、通过给 HtmlWebpackPlugin 传递对象来配置参数</span></span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          <span class="attr">filenmame</span>: <span class="string">&quot;index.html&quot;</span>,<span class="comment">// 配置输出 html 的名称</span></span><br><span class="line">          <span class="attr">template</span>: <span class="string">&quot;./tpl.html&quot;</span>,<span class="comment">//配置模板 html 路径</span></span><br><span class="line">      &#125;),</span><br><span class="line">  ]</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面例子只使用了插件的部分功能，更多功能可以在 <a href="https://www.npmjs.com/package/html-webpack-plugin">https://www.npmjs.com/package/html-webpack-plugin</a> 进行查看。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>html-webpack-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 跨平台设置环境变量</title>
    <url>/web/webpack/webpack%20%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>windows 和 unix 中环境变量设置方法不一致。目前在 webpack 中，可以使用 cross-env 来跨平台设置 node 环境变量。</p>
<ul>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<p>在 package.json 中使用 cross-env 关键字设置环境变量</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env  NODE_ENV=development webpack --config build/webpack.config.js&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<p>在 node 环境中使用 process.env.NODE_ENV 来获取环境变量 NODE_ENV</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV);<span class="comment">//development</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>跨平台环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 魔法注释</title>
    <url>/web/webpack/webpack%20%E9%AD%94%E6%B3%95%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1 id="webpack-魔法注释"><a href="#webpack-魔法注释" class="headerlink" title="webpack 魔法注释"></a>webpack 魔法注释</h1><p>使用 import 语句导入模块时，可以使用使用 webpack 魔法注释完成一些配置，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个目标</span></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="comment">/* webpackChunkName: &quot;my-chunk-name&quot; */</span></span><br><span class="line">  <span class="comment">/* webpackMode: &quot;lazy&quot; */</span></span><br><span class="line">  <span class="comment">/* webpackExports: [&quot;default&quot;, &quot;named&quot;] */</span></span><br><span class="line">  <span class="string">&#x27;module&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个可能的目标</span></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="comment">/* webpackInclude: /\.json$/ */</span></span><br><span class="line">  <span class="comment">/* webpackExclude: /\.noimport\.json$/ */</span></span><br><span class="line">  <span class="comment">/* webpackChunkName: &quot;my-chunk-name&quot; */</span></span><br><span class="line">  <span class="comment">/* webpackMode: &quot;lazy&quot; */</span></span><br><span class="line">  <span class="comment">/* webpackPrefetch: true */</span></span><br><span class="line">  <span class="comment">/* webpackPreload: true */</span></span><br><span class="line">  <span class="string">`./locale/<span class="subst">$&#123;language&#125;</span>`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackIgnore: true */</span> <span class="string">&#x27;ignored-module.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>webpackIgnore：设置为 true 时，禁用动态导入解析。</li>
<li>webpackChunkName：设置 chunk 名称，从 webpack 2.6.0 开始，占位符 <code>[index]</code> 和 <code>[request]</code> 分别支持递增的数字或实际的解析文件名。 添加此注释后，会将 chunk 命名为 [my-chunk-name].js 而不是 [id].js。</li>
<li>webpackMode：从 webpack 2.6.0 开始，可以指定以不同的模式解析动态导入<ul>
<li><code>&#39;lazy&#39;</code> (默认值)：为每个 <code>import()</code> 导入的模块生成一个可延迟加载（lazy-loadable）的 chunk。</li>
<li><code>&#39;lazy-once&#39;</code>：只生成一个可以满足所有调用的可延迟加载（lazy-loadable）的 chunk。此 chunk 将在第一次 <code>import()</code> 时获取，随后的 <code>import()</code> 则使用之前的请求结果。这个模式仅在部分动态语句中有意义，例如 <code>import(</code>./locales/${language}.json<code>)</code>，这条语句可能会请求多个模块。</li>
<li><code>&#39;eager&#39;</code>：不会生成额外的 chunk。所有的模块都被当前的 chunk 引入，并且没有额外的网络请求。但是仍会返回一个 resolved 状态的 <code>Promise</code>。与静态导入相比，在调用 <code>import()</code> 完成之前，该模块不会被执行。</li>
<li><code>&#39;weak&#39;</code>：尝试加载模块，如果该模块函数已经以其他方式加载，（即另一个 chunk 导入过此模块，或包含模块的脚本被加载）。 但是只有在客户端上已存在该 chunk 时才会成功解析，返回 <code>Promise</code>。如果该模块不可用，则返回 rejected 状态的 <code>Promise</code>。网络请求永远都不会执行。</li>
</ul>
</li>
<li>webpackPrefetch：告诉浏览器将来可能会调转到该资源</li>
<li>webpackPreload：告诉浏览器在当前导航期间可能需要该资源</li>
<li>webpackInclude：配置需要导入模块的正则，匹配到的模块才会被打包</li>
<li>webpackExclude：配置不需要导入模块的正则，匹配到的模块不会被打包</li>
<li>webpackExports： 告诉 webpack 在使用动态导入时，只打包这个模块使用的导出项。它可以减小 chunk 的大小。从 <a href="https://github.com/webpack/webpack/releases/tag/v5.0.0-beta.18">webpack 5.0.0-beta.18</a> 起可用。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 自动编译</title>
    <url>/web/webpack/webpack%20%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>可以使用下面方法来自动编译发生变化后的代码：</p>
<ul>
<li>webpack –watch 参数</li>
<li>webpack-dev-server</li>
<li>webpack-dev-middlewaire </li>
</ul>
<h1 id="watch-参数"><a href="#watch-参数" class="headerlink" title="watch 参数"></a>watch 参数</h1><p>启动 webpack 时，添加 –watch 参数，即可开启观察者模式的自动编译。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">+     <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,<span class="comment">//添加 --watch 参数</span></span><br><span class="line">      <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^0.1.16&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.28.4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;csv-loader&quot;</span>: <span class="string">&quot;^2.1.1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^0.11.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^2.29.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.18.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;xml-loader&quot;</span>: <span class="string">&quot;^1.2.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>缺点：需要手动刷新浏览器。</p>
<h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p>webpack-dev-server 可启动一个可以实时重新加载的 web 服务器。</p>
<p>使用方法：</p>
<p>1、安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>2、配置 webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">      <span class="attr">app</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">      <span class="attr">print</span>: <span class="string">&#x27;./src/print.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">+   devServer: &#123;</span><br><span class="line">+     contentBase: <span class="string">&#x27;./dist&#x27;</span></span><br><span class="line">+   &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Development&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>3、配置 package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,</span><br><span class="line">+     <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^0.1.16&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.28.4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;csv-loader&quot;</span>: <span class="string">&quot;^2.1.1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^0.11.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^2.29.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.18.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;xml-loader&quot;</span>: <span class="string">&quot;^1.2.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="webpack-dev-middlewaire"><a href="#webpack-dev-middlewaire" class="headerlink" title="webpack-dev-middlewaire"></a>webpack-dev-middlewaire</h1><p><code>webpack-dev-middleware</code> 是一个容器，它可以把 webpack 处理后的文件传递给一个服务器(server)。 <code>webpack-dev-server</code> 在内部使用了它。</p>
<p>使用方法：</p>
<p>1、配置 webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">      <span class="attr">app</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">      <span class="attr">print</span>: <span class="string">&#x27;./src/print.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">+     publicPath: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell express to use the webpack-dev-middleware and use the webpack.config.js</span></span><br><span class="line"><span class="comment">// configuration file as a base.</span></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serve the files on port 3000.</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Example app listening on port 3000!\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span>,</span><br><span class="line">+     <span class="attr">&quot;server&quot;</span>: <span class="string">&quot;node server.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^0.1.16&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.28.4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;csv-loader&quot;</span>: <span class="string">&quot;^2.1.1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;express&quot;</span>: <span class="string">&quot;^4.15.3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^0.11.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^2.29.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.18.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;webpack-dev-middleware&quot;</span>: <span class="string">&quot;^1.12.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;xml-loader&quot;</span>: <span class="string">&quot;^1.2.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 入门</title>
    <url>/web/webpack/webpack%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>webpack 是前端模块化打包工具。</p>
<p>对于webpack 来说，万物（js|img|css|sass|less..）皆模块，webpack 会根据模块依赖关系进行静态分析，将所有模块打包生成对应的静态资源（bundle）。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1、通过模块化解决了全局污染、命名冲突、依赖管理混乱问题</p>
<p>2、兼容 AMD CMD</p>
<p>3、适合大型项目</p>
<p>4、与 react、vue 有很好的契合度</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>1、node（通过 node 官网下载安装）</p>
<p>2、通过 npm 命令初始化项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>3、安装 webpack 和 webpack-cli</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>通过 entry 来配置 webpack 的入口文件，webpack 从 entry 开始分析模块间的依赖关系。</p>
<p>webpack 将存在依赖关系的模块，打包为 trunk（代码分片），trunk 为代码在打包过程中的中间状态。</p>
<p>由 trunk 最终产生的打包产物叫做bundle。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>通过 output 来配置 webpack 的输出文件夹和输出文件名称。默认输出到文件夹 <code>./dist</code>，默认输出的文件为 <code>./dist/main.js</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="comment">/*path 和 filename配置共同决定了bundles的输出地址*/</span></span><br><span class="line">      <span class="comment">//__dirname 为当前 webpack.config.js 所在文件夹名称</span></span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack 只能识别 js 和 json 文件，可以通过 loader 将 webpack 不认识的资源转换为 webpack 可以识别的。</p>
<p>使用 loader 时，需要先安装，然后配置到 module.rules 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//loader 需要定义在module.rules 中</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; </span><br><span class="line">          <span class="comment">//test 用于指定需要转换的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, </span><br><span class="line">          <span class="comment">//use 用于指定使用哪个 loader 转换 test 指定的文件</span></span><br><span class="line">        use: <span class="string">&#x27;raw-loader&#x27;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>plugin 可于执行更广泛的任务，如 打包优化、资源管理、注入环境变量。</p>
<p><strong>使用方法</strong>：</p>
<ol>
<li>外部插件需要使用 npm 安装</li>
<li>使用 require 来引用 </li>
<li>通过 new 创建插件实例，将其添加到 plugins 数组中</li>
<li>可根据不同目的多次使用同一个插件</li>
<li>使用对象给插件实例传递参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>可以设置为 development、productions、none 中的一个，webpack 会根据不同的配置进行不同的默认优化。默认值为 production。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;production&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h1><p>webpack 默认支持 es5 标准（不支持 ie8 及以下）。如果想要支持旧版本浏览器，在使用这些表达式之前，需要 <a href="https://webpack.docschina.org/guides/shimming/">提前加载 polyfill</a>。</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html">https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>requestAnimationFrame</title>
    <url>/web/%E6%B5%8F%E8%A7%88%E5%99%A8/requestAnimationFrame/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>是 window 对象的 API，可以通过调用 window.requestAnimationFrame( callback ) 来配置下次浏览器<strong>重绘前</strong>需要执行的功能（即传入的 callback 参数）。</p>
<h1 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h1><p>通过 window.requestAnimationFrame 来更新动画，可以有效提升页面的帧率，使得动画更流畅。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame( callback );</span><br></pre></td></tr></table></figure>

<ul>
<li><p>callback</p>
<p>callback 参数是下次重回前需要调用的函数，该回调函数会被传入 <code>requestAnimationFrame()</code> 开始去执行回调函数的时刻。</p>
</li>
<li><p>返回值</p>
<p>一个 <code>long</code> 整数的请求 ID（非零） ，是回调列表中唯一的标识。可以传这个值给 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame"><code>window.cancelAnimationFrame()</code></a> 来取消回调函数</p>
</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;SomeElementYouWantToAnimate&#x27;</span>);</span><br><span class="line">element.style.position = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  element.style.left = <span class="built_in">Math</span>.min(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>在同一个帧中的多个回调函数，会接受到相同的时间戳，该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)</li>
<li>在大多数浏览器里，当 <code>requestAnimationFrame()</code>  运行在后台标签页或者隐藏的 iframe 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>浏览器</category>
        <category>API</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>requestAnimationFrame</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器 fps</title>
    <url>/web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8fps/</url>
    <content><![CDATA[<h1 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h1><p>在网络传输中，帧是传输的数据单位。</p>
<p>在屏幕显示中，帧是动画中最小的单位，每一帧都是一幅静止的图片，连续显示的帧形成了运动的假象。</p>
<p>下面对帧相关的解释都从屏幕显示角度出发。</p>
<h1 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h1><p>帧数即帧的数量，即图片的数量。</p>
<h1 id="帧率（fps）"><a href="#帧率（fps）" class="headerlink" title="帧率（fps）"></a>帧率（fps）</h1><p>帧率（fps Frame Per Second），帧率为每秒的帧数，帧率 = 帧数 / 时间。因此帧率越高显示越流畅。</p>
<p>一般浏览器的帧率（fps）为 60 fps，即 16.67 ms（1000 / 60） 渲染一次。</p>
<p>浏览器的帧率由显示器的刷新率决定，当显示器的刷新率能够大于 60 fps 时，那么浏览器的帧率也可以相应提高。</p>
<h1 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h1><p>屏幕刷新率是指屏幕每秒能够显示图像的次数，单位为 hz（赫兹）。屏幕的刷新率由显卡性能决定。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>浏览器帧率（fps） 是浏览器每一秒的帧数，当 fps 越大，动画就越流畅。</p>
<p>浏览器的帧率（fps）小于等于显示器的刷新率。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>性能</tag>
        <tag>fps</tag>
        <tag>帧</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF</title>
    <url>/web/%E5%AE%89%E5%85%A8/CSRF/</url>
    <content><![CDATA[<h1 id="CSRF-是什么"><a href="#CSRF-是什么" class="headerlink" title="CSRF 是什么"></a>CSRF 是什么</h1><p>CSRF（Cross-site request forgery，跨站请求伪造）也被称作 one-click attack 或 session riding，通常被缩写为 CSRF 或 XSRF。</p>
<p>CSRF 利用网站对用户浏览器的信任，在用户当前已登录的网站上执行非用户本意的操作。</p>
<h1 id="CSRF-攻击细节"><a href="#CSRF-攻击细节" class="headerlink" title="CSRF 攻击细节"></a>CSRF 攻击细节</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><img src="/web/%E5%AE%89%E5%85%A8/CSRF/csrf.jpg" class="">

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>假如一家银行用以运行转账操作的 URL 地址如下： <code>https://bank.example.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code></p>
<p>攻击者可以在另一个网站上放置如下代码： <code>&lt;img src=&quot;https://bank.example.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot; /&gt;</code>。如果有账户名为 Alice 的用户在访问过银行，且登录信息未过期的情况下访问了恶意站点，那么她将会被转走 1000 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完成 CSRF 攻击必须的前提条件有：</p>
<ol>
<li>用户在 A 网站 Cookie 没失效的情况下访问恶意 B 网站</li>
<li>A 网站只通过 Cookie 来校验用户认证</li>
</ol>
<p>CSRF 攻击者并不能直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，<strong>利用用户已有的认证信息，以用户的名义发送恶意请求</strong>。</p>
<p>恶意网址 B 有很多种形式，攻击者甚至不需要管理放置恶意网址的网站。例如攻击者可以将恶意地址藏在论坛、博客等任何<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B6%E7%94%9F%E6%88%90%E5%85%A7%E5%AE%B9">用户生成内容</a>的网站中。这意味着<strong>如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险</strong>。</p>
<h1 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h1><p>将下面方法结合起来对 CSRF 进行防御：</p>
<ul>
<li>通过添加 CSP HTTP 头部来设置有效域</li>
<li>对于修改操作的接口一定要设置成 POST 请求</li>
<li>对于 POST 请求必须携带 token ，后端接到请求对 token 进行校验<ul>
<li>前端可以将请求接口封装起来，在接口内部对请求同一携带 token</li>
</ul>
</li>
</ul>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0</a></p>
<p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p>
<p><a href="https://juejin.im/post/6844903689702866952#heading-6">https://juejin.im/post/6844903689702866952#heading-6</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器跨域之 CORS</title>
    <url>/web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E4%B9%8B-CORS/</url>
    <content><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>出于安全考虑，浏览器限制在脚本内（如 XMLHttpRequest 和 Fetch）进行跨域访问。</p>
<p>CORS（跨域资源共享）是一种可以让浏览器进行跨域访问的机制。这个机制的本质是，当请求和响应的头部分别配置了特定的 HTTP 头部时，浏览器将判定此跨域请求是安全的，进而允许进行跨域访问。</p>
<h1 id="2-使用-CORS-的场景"><a href="#2-使用-CORS-的场景" class="headerlink" title="2 使用 CORS 的场景"></a>2 使用 CORS 的场景</h1><ul>
<li>使用 XMLHttpRequest 或 Fetch 发起的跨域请求</li>
<li>Web 字体（CSS 通过 @font-face 使用跨域字体资源）</li>
<li>WebGL 贴图</li>
<li>使用 drawImage 将 Image/video 画面绘制到 canvas</li>
</ul>
<h1 id="3-CORS-的使用方式"><a href="#3-CORS-的使用方式" class="headerlink" title="3 CORS 的使用方式"></a>3 CORS 的使用方式</h1><p>不同的请求类型，会使用不同的方式使用 CORS。</p>
<h2 id="3-1-简单请求"><a href="#3-1-简单请求" class="headerlink" title="3.1 简单请求"></a>3.1 简单请求</h2><h3 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h3><p>满足下面所有条件时，被定义为 <strong>简单请求</strong>，该请求不会触发 <strong>CORS 预检请求</strong>：</p>
<ol>
<li>使用下面方法之一：<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
</li>
<li>请求头不超过如下集合：<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
</li>
<li>Content-Type 为下面三者之一：<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
</li>
</ol>
<p>4、请求中的任意<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload"><code>XMLHttpRequest.upload</code></a> 属性访问。</p>
<p>5、请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 对象。</p>
<h3 id="3-1-2-代码示例"><a href="#3-1-2-代码示例" class="headerlink" title="3.1.2 代码示例"></a>3.1.2 代码示例</h3><p>站点 <a href="http://foo.example/">http://foo.example</a> 的网页应用访问 <a href="http://bar.other/">http://bar.other</a> 的资源 js 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://bar.other/resources/public-data/&#x27;</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation) &#123;    </span><br><span class="line">    invocation.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器发送的 HTTP 请求如下，第10行 的请求首部字段 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 表明该请求来源于 <code>http://foo.example</code>。：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/resources/public-data/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://foo.example</span><br></pre></td></tr></table></figure>

<p>服务器返回的 HTTP 请求如下，服务端返回的 <code>Access-Control-Allow-Origin: *</code> 表明，该资源可以被<strong>任意</strong>外域访问。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 </span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/xml</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3、总结"><a href="#3-1-3、总结" class="headerlink" title="3.1.3、总结"></a>3.1.3、总结</h3><p>简单请求使用 <code>Origin</code>和 <code>Access-Control-Allow-Origin</code> 完成 CORS 的访问控制。</p>
<p><code>Access-Control-Allow-Origin</code>  的值应当为 * 或者包含 Origin 首部字段所指明的域名，来使得此跨域请求成功返回。</p>
<h2 id="3-2-需预检请求"><a href="#3-2-需预检请求" class="headerlink" title="3.2 需预检请求"></a>3.2 需预检请求</h2><h3 id="3-2-1-定义"><a href="#3-2-1-定义" class="headerlink" title="3.2.1 定义"></a>3.2.1 定义</h3><p><strong>需预检请求</strong> 指浏览器在发送实际请求前，先发送一个 OPTION 请求，当服务器响应为允许时，才发送的实际请求。当条件不满足 <strong>简单请求</strong> 时，为 <strong>需预检请求</strong>。</p>
<h3 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h3><p>下面的代码使用 POST 请求包含了一个<strong>自定义的请求首部字段</strong>（X-PINGOTHER: pingpong），并且该请求的 <strong>Content-Type 为 application/xml</strong>。因此，该请求需要首先发起“<strong>预检请求</strong>”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://bar.other/resources/post-here/&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> body = <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation)</span><br><span class="line">    &#123;</span><br><span class="line">      invocation.open(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">      invocation.setRequestHeader(<span class="string">&#x27;X-PINGOTHER&#x27;</span>, <span class="string">&#x27;pingpong&#x27;</span>);</span><br><span class="line">      invocation.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/xml&#x27;</span>);</span><br><span class="line">      invocation.onreadystatechange = handler;</span><br><span class="line">      invocation.send(body); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器发起<strong>预检请求</strong>（OPTIONS 方法）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/1.1----&gt; 1、预检请求的方法</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>POST---&gt;2、告知服务器实际请求的方法为 POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-PINGOTHER, Content-Type---&gt;3、告知服务器实际请求包含这两个自定义头部</span><br></pre></td></tr></table></figure>

<p>服务器返回<strong>对预检请求的响应</strong>：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://foo.example--&gt;1、告知浏览器跨域请求允许的源客户端</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>POST, GET, OPTIONS-&gt;2、告知浏览器跨域请求允许的方法</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-PINGOTHER, Content-Type--&gt;3、告知浏览器跨域齐全允许的自定义头部</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>86400--&gt;告知浏览器该跨域请求被允许的有效时间，在此有效时间内，浏览器不会对此请求再次发起预检请求</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding, Origin</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure>

<p>得到服务器允许后，浏览器才会发送下面实际请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/resources/post-here/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">X-PINGOTHER</span><span class="punctuation">: </span>pingpong</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/xml; charset=UTF-8</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://foo.example/examples/preflightInvocation.html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>55</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://foo.example</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure>

<p>下面是服务器对实际请求的响应：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:40 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://foo.example</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding, Origin</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>235</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=99</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-总结"><a href="#3-2-3-总结" class="headerlink" title="3.2.3 总结"></a>3.2.3 总结</h3><p>预检请求会使用 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 告知服务器实际请求的来源、方法、自定义头部。</p>
<p>预检响应通过 Access-Control-Allow-Origin、Access-Control-Allow-Methods 、Access-Control-Allow-Headers 头部来告知浏览器，请求是否被允许。</p>
<p>当预检请求被重定向时，大多浏览器会报错，可通过如下方法规避：</p>
<p>1、在服务端去掉预检请求的重定向</p>
<p>2、将实际请求变成简单请求</p>
<h1 id="4-附带身份凭证的请求"><a href="#4-附带身份凭证的请求" class="headerlink" title="4 附带身份凭证的请求"></a>4 附带身份凭证的请求</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>​    对于跨域的 XMLHttpRequest 或 Fetch 请求，浏览器默认不会发送身份凭证，当需要发送身份凭证时，需要给请求添加特殊标志位。</p>
<h2 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h2><p>下面示例是配置了 cookie 的请求，将 <code>XMLHttpRequest </code>的 <code>withCredentials</code> 标志设置为 <code>true</code>，从而告知浏览器此请求发送给服务器时需要携带 Cookies。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://bar.other/resources/credentialed-content/&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation) &#123;</span><br><span class="line">    invocation.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    invocation.withCredentials = <span class="literal">true</span>;<span class="comment">// 添加 withCredentials = true 告知浏览器此跨域请求需要携带 cookie</span></span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是浏览器向服务器发送的携带 cookie 的跨域请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/resources/access-control-with-credentials/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://foo.example/examples/credential.html</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://foo.example</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>pageAccess=2</span><br></pre></td></tr></table></figure>

<p>下面是服务器对携带 cookie 的跨域请求的响应：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:34:52 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://foo.example--》1、对于附带凭证的请求，此字段值需为请求发起者，而不是*,否则请求将失败</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true--&gt;2、此字段为 true 时，浏览器才会将响应返回给请求发起者</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT--&gt;3、将用户将浏览器端设置为拒绝第三方 cookie 时，此设置会失败</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding, Origin</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>106</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure>

<h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><p>请求中需要设置 <code>withCredentials</code> 为 true，浏览器才会将 cookie 携带给服务器。</p>
<p>响应中不能缺失 <code>Access-Control-Allow-Credentials</code>: true（第 17 行），否则响应内容不会返回给请求的发起者。</p>
<p>服务器必须将 <code>Access-Control-Allow-Origin</code> 的值设置为请求发起者，而不是“<code>*</code>”，必否则请求将失败。</p>
<h1 id="5-CORS-相关头部总结"><a href="#5-CORS-相关头部总结" class="headerlink" title="5 CORS 相关头部总结"></a>5 CORS 相关头部总结</h1><h2 id="5-1-请求头部"><a href="#5-1-请求头部" class="headerlink" title="5.1 请求头部"></a>5.1 请求头部</h2><h3 id="5-1-1-Origin"><a href="#5-1-1-Origin" class="headerlink" title="5.1.1 Origin"></a>5.1.1 Origin</h3><p>Origin 表明实际请求的来源，它不包含任何路径信息，只是服务器名称。</p>
<p>无论是否跨域此头部都会被发送。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>origin </span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-Access-Control-Request-Method"><a href="#5-1-2-Access-Control-Request-Method" class="headerlink" title="5.1.2 Access-Control-Request-Method"></a>5.1.2 Access-Control-Request-Method</h3><p>该首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>&lt;method&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-Access-Control-Request-Headers"><a href="#5-1-3-Access-Control-Request-Headers" class="headerlink" title="5.1.3 Access-Control-Request-Headers"></a>5.1.3 Access-Control-Request-Headers</h3><p>该首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>&lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure>



<h2 id="5-2-响应头部"><a href="#5-2-响应头部" class="headerlink" title="5.2 响应头部"></a>5.2 响应头部</h2><h3 id="5-2-1-Access-Control-Allow-Origin"><a href="#5-2-1-Access-Control-Allow-Origin" class="headerlink" title="5.2.1 Access-Control-Allow-Origin"></a>5.2.1 Access-Control-Allow-Origin</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>&lt;origin&gt; | *</span><br></pre></td></tr></table></figure>

<p>此字段指定了允许访问该资源的跨域 URI，对于没携带身份凭证的请求，服务器可以指定该字段的值为通配符 “*”，表示允许来自所有域的请求。</p>
<p>如果服务端指定了具体的域名而非 “*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。</p>
<h3 id="5-2-2-Access-Control-Expose-Headers"><a href="#5-2-2-Access-Control-Expose-Headers" class="headerlink" title="5.2.2 Access-Control-Expose-Headers"></a>5.2.2 Access-Control-Expose-Headers</h3><p>在跨域访问时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置此响应头。</p>
<p>下面的响应使得请求发起者就能够通过 getResponseHeader 访问 <code>X-My-Custom-Header</code> 和  <code>X-Another-Custom-Header</code>  响应头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-Access-Control-Allow-Credentials"><a href="#5-2-3-Access-Control-Allow-Credentials" class="headerlink" title="5.2.3 Access-Control-Allow-Credentials"></a>5.2.3 Access-Control-Allow-Credentials</h3><p>该响应字段头指定了当浏览器的 <code>credentials</code> 设置为 true 时，是否允许请求发起者读取 response的内容。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-Access-Control-Max-Age"><a href="#5-2-4-Access-Control-Max-Age" class="headerlink" title="5.2.4 Access-Control-Max-Age"></a>5.2.4 Access-Control-Max-Age</h3><p>该响应字段指定了该预检请求响应的有效期为多少秒。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>&lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-5-Access-Control-Allow-Methods"><a href="#5-2-5-Access-Control-Allow-Methods" class="headerlink" title="5.2.5 Access-Control-Allow-Methods"></a>5.2.5 Access-Control-Allow-Methods</h3><p>该响应字段其指定了实际请求所允许使用的 HTTP 方法。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>&lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure>

<h3 id="5-2-6-Access-Control-Allow-Headers"><a href="#5-2-6-Access-Control-Allow-Headers" class="headerlink" title="5.2.6 Access-Control-Allow-Headers"></a>5.2.6 Access-Control-Allow-Headers</h3><p>该响应字段指定了实际请求中允许携带的首部字段。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>&lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p>
<p><a href="http://arunranga.com/examples/access-control/">http://arunranga.com/examples/access-control/</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>跨域 CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>Fetch</title>
    <url>/web/javascript/es6/Fetch/</url>
    <content><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><p>Fetch 基于 Primise 提供了获取资源的功能（包括跨域请求），与 XMLHttpRequest 的很多功能相似，但使用更方便，且更具有可扩展性和高效性。</p>
<p>Fetch 的核心在于为 Request、Response、Body、CORS、HTTP 等提供了一种通用的定义方法，取代了它们之前分离的定义方式。</p>
<h1 id="2-Fetch-与-jquery-ajax-的不同"><a href="#2-Fetch-与-jquery-ajax-的不同" class="headerlink" title="2 Fetch 与 jquery.ajax 的不同"></a>2 Fetch 与 jquery.ajax 的不同</h1><ul>
<li><p>当接收到错误的 HTTP 状态码时，从 Fetch 返回的 Promise 会被标记为 resolve （但会将 resolve 返回值的 ok 属性设置为 false），当且仅当网络故障或请求被终止时，才会才会被标记为 reject。</p>
</li>
<li><p>默认 Fetch 不会给服务器发送或接收服务器的 cookie，除非设置 credentials 选项。（自 2017 年 8 月 25 日以后，默认的 credentials 政策变更为 <code>same-origin</code>。Firefox 也在 61.0b13 版本中进行了修改）</p>
</li>
</ul>
<h1 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise&lt;Response&gt; fetch(input[, init]);</span><br></pre></td></tr></table></figure>

<h2 id="3-1-参数"><a href="#3-1-参数" class="headerlink" title="3.1 参数"></a>3.1 参数</h2><p><em>?input</em></p>
<p>定义要获取的资源。这可能是：</p>
<ul>
<li>一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString"><code>USVString</code></a> 字符串，包含要获取资源的 URL。一些浏览器会接受 <code>blob:</code> 和 <code>data:</code> 作为 schemes.</li>
<li>一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 对象。</li>
</ul>
<p><em>init</em> 可选</p>
<p>一个配置项对象，包括所有对请求的设置。可选的参数有：</p>
<ul>
<li><code>method</code>: 请求使用的方法，如 <code>GET</code>、<code>POST</code>。</li>
<li><code>headers</code>: 请求的头信息，形式为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers"><code>Headers</code></a> 的对象或包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ByteString"><code>ByteString</code></a> 值的对象字面量。</li>
<li><code>body</code>: 请求的 body 信息：可能是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/BufferSource"><code>BufferSource</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString"><code>USVString</code></a> 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。</li>
<li><code>mode</code>: 请求的模式，如 <code>cors、</code> <code>no-cors 或者</code> <code>same-origin。</code></li>
<li><code>credentials</code>: 请求的 credentials，如 <code>omit、same-origin 或者 include。为了在当前域名内自动发送 cookie ， 必须设置该选项为 same-origin， 从 Chrome 50 开始， 这个属性也可以接受</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FederatedCredential"><code>FederatedCredential</code></a> 实例或是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PasswordCredential"><code>PasswordCredential</code></a> 实例。</li>
<li><code>cache</code>:  请求的 cache 模式: <code>default </code>、 <code>no-store 、</code> <code>reload 、</code> <code>no-cache 、</code> <code>force-cache </code>或者 <code>only-if-cached 。</code></li>
<li><code>redirect</code>: 可用的 redirect 模式: <code>follow</code> (自动重定向), <code>error</code> (如果产生重定向将自动终止并且抛出一个错误), 或者 <code>manual</code> (手动处理重定向). 在Chrome中，Chrome 47之前的默认值是 follow，从 Chrome 47开始是 manual。</li>
<li><code>referrer</code>: 一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString"><code>USVString</code></a> 可以是 <code>no-referrer、``client</code>或一个 URL。默认是 <code>client。</code></li>
<li><code>referrerPolicy</code>: 指定了HTTP头部referer字段的值。可能为以下值之一： <code>no-referrer、</code> <code>no-referrer-when-downgrade、</code> <code>origin、</code> <code>origin-when-cross-origin、</code> <code>unsafe-url 。</code></li>
<li><code>integrity</code>: 包括请求的  <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">subresource integrity</a> 值 （ 例如： <code>sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。</code></li>
</ul>
<h2 id="3-2-返回值"><a href="#3-2-返回值" class="headerlink" title="3.2 返回值"></a>3.2 返回值</h2><p>一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Promise"><code>Promise</code></a>，resolve 时会传 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象。</p>
<h1 id="4-示例"><a href="#4-示例" class="headerlink" title="4 示例"></a>4 示例</h1><h2 id="4-1-判断请求是否成功"><a href="#4-1-判断请求是否成功" class="headerlink" title="4.1 判断请求是否成功"></a>4.1 判断请求是否成功</h2><p>当response.ok 为 true 时，请求才成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;flowers.jpg&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(response.ok) &#123;<span class="comment">//当response.ok 为 true 时，请求才成功</span></span><br><span class="line">    <span class="keyword">return</span> response.blob();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Network response was not ok.&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> objectURL = URL.createObjectURL(myBlob); </span><br><span class="line">  myImage.src = objectURL; </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span>, error.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-2-发送带凭证的请求"><a href="#4-2-发送带凭证的请求" class="headerlink" title="4.2 发送带凭证的请求"></a>4.2 发送带凭证的请求</h2><p>通过 credentials 选项配置凭证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://example.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">//include 表示携带凭证，即使是跨域请求  </span></span><br><span class="line">  <span class="comment">//same-origin 表示同源时才携带凭证  </span></span><br><span class="line">  <span class="comment">//omit 表示不携带凭证  </span></span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-3-上传-JSON-数据"><a href="#4-3-上传-JSON-数据" class="headerlink" title="4.3 上传 JSON 数据"></a>4.3 上传 JSON 数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://example.com/profile&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">username</span>: <span class="string">&#x27;example&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// or &#x27;PUT&#x27;</span></span><br><span class="line">  <span class="comment">//通过 body 字段发送 json 数据</span></span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(data), <span class="comment">// data can be `string` or &#123;object&#125;!</span></span><br><span class="line">  <span class="attr">headers</span>: <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Error:&#x27;</span>, error))</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Success:&#x27;</span>, response));</span><br></pre></td></tr></table></figure>

<h2 id="4-4-上传文件"><a href="#4-4-上传文件" class="headerlink" title="4.4 上传文件"></a>4.4 上传文件</h2><p>可以通过 HTML <code>&lt;input type=&quot;file&quot; /&gt;</code> 元素，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData"><code>FormData()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a> 上传文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> fileField = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;abc123&#x27;</span>);</span><br><span class="line">formData.append(<span class="string">&#x27;avatar&#x27;</span>, fileField.files[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;https://example.com/profile/avatar&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Error:&#x27;</span>, error))</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Success:&#x27;</span>, response));</span><br></pre></td></tr></table></figure>

<h2 id="4-5-上传多个文件"><a href="#4-5-上传多个文件" class="headerlink" title="4.5 上传多个文件"></a>4.5 上传多个文件</h2><p>可以通过HTML <code>&lt;input type=&quot;file&quot; mutiple/&gt;</code> 元素，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData"><code>FormData()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a> 上传文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> photos = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input[type=&#x27;file&#x27;][multiple]&quot;</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;My Vegas Vacation&#x27;</span>);</span><br><span class="line"><span class="comment">// formData 只接受文件、Blob 或字符串，不能直接传递数组，所以必须循环嵌入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; photos.files.length; i++) &#123; </span><br><span class="line">    formData.append(<span class="string">&#x27;photo&#x27;</span>, photos.files[i]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;https://example.com/posts&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Success:&#x27;</span>, <span class="built_in">JSON</span>.stringify(response)))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br></pre></td></tr></table></figure>

<h2 id="4-6-自定义请求对象"><a href="#4-6-自定义请求对象" class="headerlink" title="4.6 自定义请求对象"></a>4.6 自定义请求对象</h2><p>除了传给 <code>fetch()</code> 一个资源的地址，你还可以通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request"><code>Request()</code></a> 构造函数来创建一个 request 对象，然后再作为参数传给 <code>fetch()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myInit = &#123; <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">               <span class="attr">headers</span>: myHeaders,</span><br><span class="line">               <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">               <span class="attr">cache</span>: <span class="string">&#x27;default&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRequest = <span class="keyword">new</span> Request(<span class="string">&#x27;flowers.jpg&#x27;</span>, myInit);</span><br><span class="line"></span><br><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.blob();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  myImage.src = objectURL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Request()</code> 和 <code>fetch()</code> 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherRequest = <span class="keyword">new</span> Request(myRequest,myInit);</span><br></pre></td></tr></table></figure>

<p>这个很有用，因为 request 和 response bodies 只能被使用一次（这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 <code>init</code> 参数。</p>
<p><strong>注意</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request/clone"><code>clone()</code></a> 方法也可以用于创建一个拷贝。它和上述方法一样，如果 request 或 response 的 body 已经被读取过，那么 clone 将执行失败。区别在于， <code>clone()</code> 出的 body 被读取不会导致原 body 被标记为已读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy 和 Reflect</title>
    <url>/web/javascript/es6/Proxy%20%E5%92%8C%20Reflect/</url>
    <content><![CDATA[<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以通过 Proxy 来代理对象，然后定制该对象的基本操作（如属性查找、赋值、枚举、函数调用等）。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p>target：被代理的对象，可以是任何类型的对象，包括原生数组，函数，甚至另一个代理。</p>
</li>
<li><p>handler：以函数为属性值的对象，key 为操作名称，value 为自定义实现。</p>
<ul>
<li><p>支持的 key：</p>
<ul>
<li>get：function(target, property, receiver) {//…}<ul>
<li>属性读取操作的捕捉器。</li>
</ul>
</li>
<li>set(target, prop,value, receiver) {//…}<ul>
<li>属性设置操作的捕捉器。</li>
</ul>
</li>
<li>has(target, prop) {//…}<ul>
<li><code>in</code> 操作符的捕捉器。</li>
</ul>
</li>
<li>deleteProperty(target, prop) {//…}<ul>
<li><code>delete</code> 操作符的捕捉器。</li>
</ul>
</li>
<li>getPrototypeOf(target) { //…}<ul>
<li><code>Object.getPrototypeOf</code> 方法的捕捉器。</li>
</ul>
</li>
<li>setPrototypeOf(target, newProto) {//…}<ul>
<li><code>Object.setPrototypeOf</code> 方法的捕捉器。</li>
</ul>
</li>
<li>isExtensible(target) {//…}<ul>
<li><code>Object.isExtensible</code>方法的捕捉器。</li>
</ul>
</li>
<li>preventExtensions(target) {//…}<ul>
<li><code>Object.preventExtensions</code>方法的捕捉器。</li>
</ul>
</li>
<li>getOwnPropertyDescriptor(target, prop) {//…}<ul>
<li><code>Object.getOwnPropertyDescriptor</code> 方法的捕捉器。</li>
<li>defineProperty(target, prop, descriptor ) {//…}<ul>
<li><code>Object.defineProperty</code>方法的捕捉器。</li>
</ul>
</li>
<li>ownKeys(target) {//…}<ul>
<li><code>Object.getOwnPropertyNames</code> 方法和 <code>Object.getOwnPropertySymbols</code> 方法的捕捉器。</li>
</ul>
</li>
<li>apply(target, thisArg, argumentsList) {//…}<ul>
<li>函数调用操作的捕捉器。</li>
</ul>
</li>
<li>construct(target, args) {//…}<ul>
<li><code>new</code> 操作符的捕捉器。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The default behavior to store the value</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age); </span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="string">&#x27;young&#x27;</span>; </span><br><span class="line"><span class="comment">// 抛出异常: Uncaught TypeError: The age is not an integer</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="number">300</span>; </span><br><span class="line"><span class="comment">// 抛出异常: Uncaught RangeError: The age seems invalid</span></span><br></pre></td></tr></table></figure>



<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>可以把 Reflect 当做 Object 的升级版，但没有构造函数，不能使用 new 操作符。</p>
<p>Reflect 所有的属性和方法都是静态的，所有的方法名和 Proxy handle 提供的方法名一致。 </p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ul>
<li><p>可以和 Object 一样操作对象。</p>
</li>
<li><p>修改 Object 操作的一些返回值，</p>
</li>
<li><p>让 Object 的操作变成函数行为</p>
</li>
<li><p>Reflect 和 Proxy 的方法一一对应，Proxy 对象可使用 Reflect 完成默认操作的调用</p>
</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> duck = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Maurice&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  <span class="attr">greeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Quaaaack! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;color&#x27;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;haircut&#x27;</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&quot;prop&quot;</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// true</span></span><br><span class="line">obj.prop; <span class="comment">// &quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;duck&quot;</span>, <span class="string">&quot;duck&quot;</span>, <span class="string">&quot;duck&quot;</span>];</span><br><span class="line"><span class="built_in">Reflect</span>.set(arr, <span class="number">2</span>, <span class="string">&quot;goose&quot;</span>); <span class="comment">// true</span></span><br><span class="line">arr[<span class="number">2</span>]; <span class="comment">// &quot;goose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It can truncate an array.</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(arr, <span class="string">&quot;length&quot;</span>, <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">arr; <span class="comment">// [&quot;duck&quot;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// With just one argument, propertyKey and value are &quot;undefined&quot;.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line"><span class="comment">// &#123; value: undefined, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>es6 之 class（一） 基础用法</title>
    <url>/web/javascript/es6/class%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><code>class</code> 能够让 js 像传统的面向对象语言（如 c++， java）一样定义类。</p>
<p><code>class</code> 的所有实例方法都定义在类的 <code>prototype</code> 属性上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTT</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x=x;    </span><br><span class="line">        <span class="built_in">this</span>.y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">printMe</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x:&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;,y:&#x27;</span> + <span class="built_in">this</span>.y; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">TTT.prototype = &#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">	<span class="function"><span class="title">printMe</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h1><h2 id="2-1-不存在变量提升"><a href="#2-1-不存在变量提升" class="headerlink" title="2.1 不存在变量提升"></a>2.1 不存在变量提升</h2><p>​    使用的位置必须在定义之后，否则报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//console(TTT);//ReferenceError: TTT is not defined ,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTT</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-不允许重复定义"><a href="#2-2-不允许重复定义" class="headerlink" title="2.2 不允许重复定义"></a>2.2 不允许重复定义</h2><p>​    重复定义类时，会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;; </span><br><span class="line"><span class="comment">// Uncaught TypeError: Identifier &#x27;Foo&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;; </span><br><span class="line"><span class="comment">// Uncaught TypeError: Identifier &#x27;Foo&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-constructor-即构造函数"><a href="#2-3-constructor-即构造函数" class="headerlink" title="2.3 constructor 即构造函数"></a>2.3 constructor 即构造函数</h2><ol>
<li><p>构造函数中的 <code>this</code> 代表实例对象</p>
</li>
<li><p>类名可被当成是构造函数的别名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;<span class="comment">//...&#125;;</span></span><br><span class="line"></span><br><span class="line">A.prototype.constructor === A    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-4-原型对象-prototype"><a href="#2-4-原型对象-prototype" class="headerlink" title="2.4 原型对象 prototype"></a>2.4 原型对象 prototype</h2><ol>
<li>类的所有实例共享原型 <code>prototype</code></li>
<li>类的原型 <code>prototype</code> 的 <code>constructor</code> 属性指向类本身</li>
<li>实例的 <code>constructor</code> 属性指向类本身</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;<span class="comment">//...&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A.prototype.constructor === A    <span class="comment">//true</span></span><br><span class="line">a.constructor === A      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-属性"><a href="#2-5-属性" class="headerlink" title="2.5 属性"></a>2.5 属性</h2><h3 id="2-5-1-字段"><a href="#2-5-1-字段" class="headerlink" title="2.5.1 字段"></a>2.5.1 字段</h3><p>公有字段都是可编辑、可遍历、可配置、可继承的。</p>
<h4 id="2-5-1-2-实例字段"><a href="#2-5-1-2-实例字段" class="headerlink" title="2.5.1.2 实例字段"></a>2.5.1.2 实例字段</h4><p>实例字段是基于实例的变量或属性，用于保存实例的状态，由实例来调用。</p>
<p>可以在 constructor 、 实例方法 中定义，也可以在类的顶部定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    prop2 = <span class="number">2</span>; <span class="comment">//在类的顶部定义</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prop1 = <span class="number">1</span>;   <span class="comment">//在 constructor 中定义实例属性</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">setProp3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props = <span class="number">3</span>; <span class="comment">//在实例方法中定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.setProp3();</span><br><span class="line"><span class="built_in">console</span>.log(a.prop1, a.prop2, a.props); <span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-2-类字段（静态字段）"><a href="#2-5-1-2-类字段（静态字段）" class="headerlink" title="2.5.1.2 类字段（静态字段）"></a>2.5.1.2 类字段（静态字段）</h4><p>使用 <code>static</code> 关键字修饰的字段，通常用于创建工具函数。</p>
<p>1.可以在类的顶层定义</p>
<p>2.可以在类的外部定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> sProp3 = <span class="number">3</span>;   <span class="comment">//定义在类的顶层，并且用static 关键字修饰  （新方法）</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">A.sProp4 = <span class="number">4</span>; <span class="comment">//定义在类的外部 （旧方法）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A.sProp3, A.sProp4); <span class="comment">// 3 4</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5-2-方法"><a href="#2-5-2-方法" class="headerlink" title="2.5.2 方法"></a>2.5.2 方法</h3><h4 id="2-5-2-1-实例方法"><a href="#2-5-2-1-实例方法" class="headerlink" title="2.5.2.1 实例方法"></a>2.5.2.1 实例方法</h4><p>是所有实例共享的方法，由实例来调用</p>
<ol>
<li>无需写 <code>function</code> 关键字，方法间无需用逗号分隔</li>
<li>方法中的 <code>this</code> 代表实例对象</li>
<li>方法不可枚举（<strong>与ES5不同</strong>）</li>
</ol>
<h4 id="2-5-2-2-类方法（静态方法）"><a href="#2-5-2-2-类方法（静态方法）" class="headerlink" title="2.5.2.2 类方法（静态方法）"></a>2.5.2.2 类方法（静态方法）</h4><p>使用 <code>static</code> 关键字修饰的方法。静态方法不可遍历。</p>
<p>1、类的静态方法属于类，不属于类的原型，不能通过类的实例进行调用</p>
<p>2、 静态方法中的 this 表示类，而不是实例</p>
<p>3、 静态方法可以和实例方法重名</p>
<p>4、 静态方法可以被子类继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sNameA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;static sNameA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sNameB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sNameA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prop3 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sName&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A.sName();</span><br><span class="line">B.sNameA();  <span class="comment">//继承A的静态方法</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-类的属性名，可以使用表达式"><a href="#2-6-类的属性名，可以使用表达式" class="headerlink" title="2.6 类的属性名，可以使用表达式"></a>2.6 类的属性名，可以使用表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;getName&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	[name]()&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-name属性返回类名"><a href="#2-7-name属性返回类名" class="headerlink" title="2.7 name属性返回类名"></a>2.7 name属性返回类名</h2><h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不存在变量提升，类必须定义后才能使用</span></span><br><span class="line"><span class="comment">//console(TTT);//ReferenceError: TTT is not defined ,</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTT</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    constructor即构造函数,this代表实例对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x=x;    </span><br><span class="line">        <span class="built_in">this</span>.y=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法无需写function关键字,函数间无需用逗号分隔</span></span><br><span class="line"><span class="comment">    this代表实例对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">printMe</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x:&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;,y:&#x27;</span> + <span class="built_in">this</span>.y; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    类可被当成是构造函数的另一种写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;typeof(TTT): \n&#x27;</span>,<span class="keyword">typeof</span>(TTT));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nTTT === TTT.prototype.constructor \n&#x27;</span>, TTT === TTT.prototype.constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法不可枚举</span></span><br><span class="line"><span class="keyword">let</span> t=<span class="keyword">new</span> TTT(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nObject.keys(TTT.prototype) : \n&#x27;</span>, <span class="built_in">Object</span>.keys(TTT.prototype)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//类的 name 返回类名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nTTT.name \n&#x27;</span>,TTT.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的所有实例共享原型对象</span></span><br><span class="line"><span class="keyword">let</span> t2 = <span class="keyword">new</span> TTT(<span class="number">3.4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nt2.__proto__ == t.__proto__\n&#x27;</span>,t2.__proto__ == t.__proto__);</span><br><span class="line">t2.__proto__.printMe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;t2 modify printMe&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nt.printMe()\n&#x27;</span>,t.printMe());</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类中，定义在 this 上的才是实例属性，否则都是原型属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nt.hasOwnProperty(x)\n&#x27;</span>,t.hasOwnProperty(<span class="string">&#x27;x&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nt.hasOwnProperty(printMe)\n&#x27;</span>,t.hasOwnProperty(<span class="string">&#x27;printMe&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\nt.__proto__.hasOwnProperty(printMe)\n&#x27;</span>,t.__proto__.hasOwnProperty(<span class="string">&#x27;printMe&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof(TTT):</span><br><span class="line"> function</span><br><span class="line"></span><br><span class="line">TTT === TTT.prototype.constructor</span><br><span class="line"> true</span><br><span class="line"></span><br><span class="line">Object.keys(TTT.prototype) :</span><br><span class="line"> []</span><br><span class="line"></span><br><span class="line">TTT.name</span><br><span class="line"> TTT</span><br><span class="line"></span><br><span class="line">t2.__proto__ == t.__proto__</span><br><span class="line"> true</span><br><span class="line"></span><br><span class="line">t.printMe()</span><br><span class="line"> t2 modify printMe</span><br><span class="line"></span><br><span class="line">t.hasOwnProperty(x)</span><br><span class="line"> true</span><br><span class="line"></span><br><span class="line">t.hasOwnProperty(printMe)</span><br><span class="line"> false</span><br><span class="line"></span><br><span class="line">t.__proto__.hasOwnProperty(printMe)</span><br><span class="line"> true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>class 基础用法</tag>
      </tags>
  </entry>
  <entry>
    <title>es6 解构赋值</title>
    <url>/web/javascript/es6/es6%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值"></a>什么是解构赋值</h1><p>解构赋值是 es6 新增语法，通过解构赋值可以从对象（数组 / 字符串）中将属性值（元素 / 字符）提取出来，赋值或初始化给其他变量。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];<span class="comment">//给 a b 变量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> [one, two, three] = foo;<span class="comment">//初始化 one two three 变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;p, q&#125; = o;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(q); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">(&#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);<span class="comment">//在使用对象字面量无声明解构赋值时是必须的</span></span><br></pre></td></tr></table></figure>

<h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">[a=<span class="number">5</span>, b=<span class="number">7</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">a</span>:aa = <span class="number">10</span>, <span class="attr">b</span>:bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(bb); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure>

<h2 id="接收函数返回值"><a href="#接收函数返回值" class="headerlink" title="接收函数返回值"></a>接收函数返回值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b; </span><br><span class="line">[a, b] = f(); <span class="comment">//a = 1  b = 2</span></span><br><span class="line">[, b] = f();<span class="comment">//b = 2</span></span><br></pre></td></tr></table></figure>

<h2 id="将剩余数组赋值给一个变量"><a href="#将剩余数组赋值给一个变量" class="headerlink" title="将剩余数组赋值给一个变量"></a>将剩余数组赋值给一个变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;</span><br><span class="line">a; <span class="comment">// 10 </span></span><br><span class="line">b; <span class="comment">// 20 </span></span><br><span class="line">rest; <span class="comment">// &#123; c: 30, d: 40 &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="解构对象时会查找原型链"><a href="#解构对象时会查找原型链" class="headerlink" title="解构对象时会查找原型链"></a>解构对象时会查找原型链</h2><p>如果属性不在对象自身，将从原型链中查找</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明对象 和 自身 self 属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">self</span>: <span class="string">&#x27;123&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// 在原型链中定义一个属性 prot</span></span><br><span class="line">obj.__proto__.prot = <span class="string">&#x27;456&#x27;</span>;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> &#123;self, prot&#125; = obj;</span><br><span class="line"><span class="comment">// self &quot;123&quot;</span></span><br><span class="line"><span class="comment">// prot &quot;456&quot;（访问到了原型链）</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值是浅拷贝"><a href="#解构赋值是浅拷贝" class="headerlink" title="解构赋值是浅拷贝"></a>解构赋值是浅拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;a&#125;  = src;</span><br><span class="line"></span><br><span class="line">a.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(a) );<span class="comment">//&#123;&quot;b&quot;:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(src) );<span class="comment">//&#123;&quot;a&quot;:&#123;&quot;b&quot;:2&#125;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>es6 之 class（二） 继承</title>
    <url>/web/javascript/es6/class%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li><p>class通过extends关键字来实现继承，es5通过修改原型链实现继承</p>
</li>
<li><p>es6的子类this是基于父类this进行修改的，es5是先创造子类this，然后将父类的方法添加到子类this上</p>
<ol>
<li>子类必须在构造函数中调用super方法（创建父类实例），否则创建实例会失败</li>
<li>子类只有调用完super方法后，才能使用this关键字</li>
<li>在子类中，super关键字代表父类实例（即父类的this）</li>
</ol>
<p>3.可以通过Object.getPrototypeOf(childClass) === parentClass来判断继承关系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b=<span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>

<h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数指的是js原生对象的构造函数，如String()、Number()、Array()、Object()等。</p>
<p>es5是新建子类后，再将父类的属性添加到子类上，而父类的属性无法获取到，导致无法继承自动父类的内部属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype,&#123;</span><br><span class="line">    <span class="attr">constructor</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:MyArray,</span><br><span class="line">        <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumberable</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;fff&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr.length:\n&#x27;</span>,arr.length);<span class="comment">//输出为0</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>class 继承</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 详解</title>
    <url>/web/javascript/es6/promise%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-Promise-是什么"><a href="#1-Promise-是什么" class="headerlink" title="1 Promise 是什么"></a>1 Promise 是什么</h1><p>Promise 可以被理解为对象（或值）的代理，被代理的对象在被创建时状态是未知的，当被代理对象执行完成时，可以通过设置 Promise 的状态来触发相应的回调函数。</p>
<p>Promise 有下面三种状态：</p>
<ul>
<li>pending：初始状态，既不是成功，也不是失败</li>
<li>fulfiled：操作成功</li>
<li>rejected：操作失败</li>
</ul>
<p>下面例子中，通过 Promise 的构造函数参数来配置异步操作，通过 then 的回调来配置成功、失败回调函数。当异步操作完成后，根据其执行结果，通过调用 resolve 或 reject 来设置 Promise 的对应状态，进而触发相应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做一些异步操作，根据执行结果调用下面两者之一:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   resolve(someValue); //执行成功时，调用 resolve 来触发 fulfilled 状态</span></span><br><span class="line">  <span class="comment">// ?或</span></span><br><span class="line">  <span class="comment">//   reject(&quot;failure reason&quot;); //执行失败时，调用 reject 来触发 rejected 状态</span></span><br><span class="line">  <span class="comment">//   当操作抛出异常时，会触发 promise 的 reject 状态  </span></span><br><span class="line"> </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">resolveCall</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当构造函数中调用 resolve 时，promise 状态变为 fulfiled， 进而触发 resolveCall 回调</span></span><br><span class="line">        &#125;), <span class="function"><span class="keyword">function</span> <span class="title">rejectCall</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当构造函数中调用 reject 时，promise 状态变为 rejected，进而会触发 rejectCall 回调</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="2-Promise-的作用"><a href="#2-Promise-的作用" class="headerlink" title="2 Promise 的作用"></a>2 Promise 的作用</h1><p>Promise 可以将异步操作和其回调函数按照<strong>同步的方式进行书写</strong>，从而解决多层异步调用产生的<strong>回调地狱</strong>问题。</p>
<h1 id="3-Promise-使用方法"><a href="#3-Promise-使用方法" class="headerlink" title="3 Promise 使用方法"></a>3 Promise 使用方法</h1><p>下面所有方法的返回值都是<strong>新的 Promise 对象</strong>。</p>
<h2 id="3-1-创建-Promise"><a href="#3-1-创建-Promise" class="headerlink" title="3.1 创建 Promise"></a>3.1 创建 Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;...&#125; <span class="comment">/*executor*/</span>)</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>​    executor</p>
<p>executor 回调有两个参数 <code>resolve</code> 和 <code>reject</code> ，这两个参数是函数类型。创建 <code>Promise</code> 时 <code>executor</code>会被立即执行。当 <code>resolve</code> 或 <code>reject</code> 函数被调用时，表示需要将 Promise 对象的状态设置为 fullfilled 或 rejected，并触发对应状态的回调函数的执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFirstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something asynchronous which eventually calls either:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   resolve(someValue)        // fulfilled</span></span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  <span class="comment">//   reject(&quot;failure reason&quot;)  // rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-类方法"><a href="#3-2-类方法" class="headerlink" title="3.2 类方法"></a>3.2 类方法</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><p>参数：interable 是多个 Promsie 对象的集合    </p>
<p>作用：用于<strong>并行运行</strong>多个 Promsie 对象。</p>
<p>特点：</p>
<p>​        一旦有一个子 Promsie 参数失败，会触发父 Promsie 对象的失败状态，并将失败信息传递给父 Promsie 的失败回调函数。 </p>
<p>​        当所有子 Promsie 参数都成功时，会触发父 Promsie 对象的成功状态，并将所有子 Promsie 参数的返回值按照顺序，以数组的形式传递给父 promise 的成功回调函数。</p>
<h3 id="Promise-allSettled-iterable"><a href="#Promise-allSettled-iterable" class="headerlink" title="Promise.allSettled(iterable)"></a>Promise.allSettled(iterable)</h3><p>参数：interable 是多个 Promsie 对象的集合    </p>
<p>作用：用于<strong>并行运行</strong>多个 Promsie 对象。</p>
<p>特点：</p>
<p>​        当所有子 Promsie 参数都完成（无论成功还是失败）时，会触发父 Promsie 对象完成状态，并将所有子 Promsie 参数的返回值按照顺序，以数组的形式返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result.status)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output:</span></span><br><span class="line"><span class="comment">// &quot;fulfilled&quot;</span></span><br><span class="line"><span class="comment">// &quot;rejected&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><p>参数：interable 是多个 Promsie 对象的集合    </p>
<p>作用：用于<strong>并行运行</strong> 多个 Promsie 对象。</p>
<p>特点：</p>
<p>父 Promsie  的状态会和最快产生状态的子 Promsie 保持一致，并将最快子 Promsie 的返回值作为父 Promsie 相应状态回调的参数。</p>
<h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h3><p>作用：创建一个状态为失败的 Promise 对象，并将 reason 参数传递给对应的处理方法</p>
<h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h3><p>作用：创建一个状态由给定 value 决定的 Promise 对象。</p>
<p>特点：</p>
<p>如果 value 是 thenable (即，带有then方法的对象)，返回的 Promise 对象的最终状态由then方法执行决定；否则的话(value 为空、基本类型或者不带 then 方法的对象)，返回的 Promise 对象状态为 fulfilled，并且将该value 传递给对应的 then 方法。</p>
<p>通常而言，如果你不知道一个值是否是 Promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象，这样就能将 value 作为 Promise 对象来使用。</p>
<h2 id="3-3-实例方法"><a href="#3-3-实例方法" class="headerlink" title="3.3 实例方法"></a>3.3 实例方法</h2><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//异步操作   </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;.catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="Promise-prototype-then-onFulfilled-onRejected"><a href="#Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then(onFulfilled, onRejected)"></a>Promise.prototype.then(onFulfilled, onRejected)</h3><p>给 Promise 对象添加 fulfiled 和 rejected 状态的回调。</p>
<h3 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a>Promise.prototype.catch(onRejected)</h3><p>给 Promise 对象添加 rejected 状态的回调。</p>
<h3 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a>Promise.prototype.finally(onFinally)</h3><p>给 Promise 对象添加一个一定会执行的回调。无论当前 Promise 的状态是完成(fulfilled)还是失败(rejected)</p>
<h1 id="4-注意"><a href="#4-注意" class="headerlink" title="4 注意"></a>4 注意</h1><h2 id="4-1-回调执行时序"><a href="#4-1-回调执行时序" class="headerlink" title="4.1 回调执行时序"></a>4.1 回调执行时序</h2><p>1、Promise 被创建时，配置给 Promise 构造函数的回调会被立即执行。</p>
<p>2、当多次添加 then 回调时，这些回调会按照被插入顺序独立执行。 配置给 Promise.then 的回调会被放入<strong>微队列</strong>，本轮事件循环运行完成之前这些回调都不会被执行。</p>
<h2 id="4-2-链式调用"><a href="#4-2-链式调用" class="headerlink" title="4.2 链式调用"></a>4.2 链式调用</h2><p>Promise 的链式调用，可以解决按顺序执行多个异步调用的诉求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = doSomething();</span><br><span class="line"><span class="keyword">const</span> promise2 = promise.then(successCallback, failureCallback);</span><br></pre></td></tr></table></figure>

<p>promise2 代表 doSomething 、successCallback/failureCallback 已完成。</p>
<p>任何 promise2 新增的回调，都会在doSomething 、successCallback/failureCallback 之后执行。如果 successCallback/failureCallback 返回了新的 Promise 对象，则 promise2 会在 新 Promise 对象之后执行。</p>
<p>每一个 promise 的返回值，都是下一个promsie 回调函数的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);<span class="comment">// 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-3-组合"><a href="#4-3-组合" class="headerlink" title="4.3 组合"></a>4.3 组合</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a> 是并行运行异步操作的两个组合式工具。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([func1(), func2(), func3()])</span><br><span class="line">.then(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123; <span class="comment">/* use result1, result2 and result3 */</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>也可以使用 JavaScript 写法实现时序组合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func1 = <span class="function"><span class="keyword">function</span>(<span class="params">lastValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastValue + <span class="string">&quot; fun1&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func2 = <span class="function"><span class="keyword">function</span>(<span class="params">lastValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastValue + <span class="string">&quot; fun2&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func3 = <span class="function"><span class="keyword">function</span>(<span class="params">lastValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastValue + <span class="string">&quot; fun3&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[func1, func2, func3]</span><br><span class="line">    .reduce(<span class="function">(<span class="params">totalValue, curArrItem</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalValue.then(curArrItem);</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(<span class="string">&quot;start&quot;</span>))</span><br><span class="line">    .then(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;results:&quot;</span>, result3);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码实现，相当于一个 Promise 链，如：</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(func1).then(func2).then(func3);</span><br></pre></td></tr></table></figure>

<h2 id="4-4-嵌套"><a href="#4-4-嵌套" class="headerlink" title="4.4 嵌套"></a>4.4 嵌套</h2><p>最好不好嵌套 Promise，容易出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">doSomethingCritical()</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span></span><br><span class="line">        doSomethingOptional()</span><br><span class="line">            .then(<span class="function"><span class="params">optionalResult</span> =&gt;</span> doSomethingExtraNice(optionalResult))</span><br><span class="line">            .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(e.message);</span><br><span class="line">            &#125;)</span><br><span class="line">    ) <span class="comment">// 即使有异常也会忽略，继续运行;(最后会输出)</span></span><br><span class="line">    .then(<span class="function">() =&gt;</span> moreCriticalStuff())</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Critical failure: &quot;</span> + e.message)); <span class="comment">// 没有输出</span></span><br></pre></td></tr></table></figure>

<p>这个内部的 catch 语句仅能捕获到 <code>doSomethingOptional()</code> 和 <code>doSomethingExtraNice()</code> 的失败，之后会继续<code>moreCriticalStuff()</code> 的运行。</p>
<h2 id="4-5-异常"><a href="#4-5-异常" class="headerlink" title="4.5 异常"></a>4.5 异常</h2><p>当有异常时，Promise 会中断，然后执行离的最近的 catch 或 rejectCallBack 回调来处理异常，当异常处理完成后，如果后面还有 then，则继续执行后面的 then 回调。</p>
<h2 id="4-6-Promise-拒绝事件"><a href="#4-6-Promise-拒绝事件" class="headerlink" title="4.6 Promise 拒绝事件"></a>4.6 Promise 拒绝事件</h2><p>当 Promise 触发 rejected 状态时，会有下面事件之一被派发到全局作用域（通常而言，就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>window</code></a>；如果是在 web worker 中使用的话，就是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker"><code>Worker</code></a> 或者其他 worker-based 接口）：</p>
<p><code>rejectionhandled</code></p>
<p>当 Promise 被拒绝、并且在 <code>reject</code> 函数处理该 rejection 之后会派发此事件</p>
<p><code>unhandledrejection</code></p>
<p>当 Promise 被拒绝，但没有提供 <code>reject</code> 函数来处理该 rejection 时，会派发此事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 你可以在这里添加一些代码，以便检查</span></span><br><span class="line"><span class="comment">     event.promise 中的 promise 和</span></span><br><span class="line"><span class="comment">     event.reason 中的 rejection 原因 */</span></span><br><span class="line"></span><br><span class="line">  event.preventDefault();<span class="comment">//告诉 JavaScript 引擎当 promise 被拒绝时不要执行默认操作，默认操作一般会包含把错误打印到控制台</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数</title>
    <url>/web/javascript/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h1><p>可以用于需要匿名函数的地方，能够简化函数书写。</p>
<h1 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h1><h2 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125; </span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"><span class="comment">//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>

<p>当函数体放在 {} 中时，必须有明确的 return 语句，否则返回值为 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">x</span> =&gt;</span> x * x;                  </span><br><span class="line"><span class="comment">// 简写函数 省略return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y; &#125;; </span><br><span class="line"><span class="comment">//常规编写 明确的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; x + y; &#125;;<span class="comment">// func(1,2) 返回值为 undefined </span></span><br><span class="line"><span class="comment">//常规编写 没有的返回值</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-高级语法"><a href="#2-2-高级语法" class="headerlink" title="2.2 高级语法"></a>2.2 高级语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回对象字面量表达式时函数体需要加括号：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; </span><br><span class="line">statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>返回对象字面量时，需要用圆括号括起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;               </span><br><span class="line"><span class="comment">// Calling func() returns undefined!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> (&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="3-特点"><a href="#3-特点" class="headerlink" title="3 特点"></a>3 特点</h1><h2 id="3-1-this"><a href="#3-1-this" class="headerlink" title="3.1 this"></a>3.1 this</h2><h3 id="3-1-1-没有自己的-this"><a href="#3-1-1-没有自己的-this" class="headerlink" title="3.1.1 没有自己的 this"></a>3.1.1 没有自己的 this</h3><p>箭头函数不会创建自己的 this，它的 this 由箭头函数被创建时的上一层作用域链决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// |this| 正确地指向 p 实例，函数被创建时的上一层作用域 Persion 的实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>作为对象的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.i, <span class="built_in">this</span>),<span class="comment">// 上层作用域为 window</span></span><br><span class="line">  <span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.i, <span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b(); </span><br><span class="line"><span class="comment">// undefined, Window&#123;...&#125;</span></span><br><span class="line">obj.c(); </span><br><span class="line"><span class="comment">// 10, Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-1-2-通过-call-apply-bind-绑定"><a href="#3-1-2-通过-call-apply-bind-绑定" class="headerlink" title="3.1.2 通过 call apply bind 绑定"></a>3.1.2 通过 call apply bind 绑定</h3><p>通过 call apply bind 绑定箭头函数时，第一个参数会被忽略（即无法绑定 this），其他参数会被正常接收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  <span class="attr">base</span> : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  <span class="attr">add</span> : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addThruCall</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      <span class="attr">base</span> : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-arguments-参数"><a href="#3-2-arguments-参数" class="headerlink" title="3.2 arguments 参数"></a>3.2 arguments 参数</h2><p>箭头函数不绑定 arguments，只是引用了外层作用域内的 arguments。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr = <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">arr(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + n; <span class="comment">// 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n,即传给foo函数的第一个参数</span></span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">foo(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">foo(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//6 </span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-new-操作符"><a href="#3-3-new-操作符" class="headerlink" title="3.3 new 操作符"></a>3.3 new 操作符</h2><p>箭头函数不用用作构造函数，使用 new 操作符会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-prototype-属性"><a href="#3-4-prototype-属性" class="headerlink" title="3.4 prototype 属性"></a>3.4 prototype 属性</h2><p>箭头函数没有 prototype 属性。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Foo = () =&gt; &#123;&#125;;</span><br><span class="line">console.log(Foo.prototype); // undefined</span><br></pre></td></tr></table></figure>

<h2 id="3-5-运算符优先级"><a href="#3-5-运算符优先级" class="headerlink" title="3.5 运算符优先级"></a>3.5 运算符优先级</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">() =&gt;</span> &#123;&#125;;      </span><br><span class="line"><span class="comment">// SyntaxError: invalid arrow-function arguments</span></span><br><span class="line"></span><br><span class="line">callback = callback || (<span class="function">() =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>箭头函数</tag>
      </tags>
  </entry>
</search>
